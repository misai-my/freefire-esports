<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Clash Squad JSON Viewer</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg:#060b18;
      --panel:#081226;
      --line:rgba(124,172,255,.14);
      --ink:#eef4ff;
      --muted:#9fb0d1;
      --orange:#ff7f32;
      --cyan:#2dafff;
      --shadow:0 24px 60px rgba(0,0,0,.45);
      --radius:24px;
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;
      background:
        radial-gradient(circle at 0% 10%, rgba(0,180,255,.12), transparent 20%),
        radial-gradient(circle at 100% 10%, rgba(255,90,0,.10), transparent 20%),
        linear-gradient(180deg,#030814 0%,#071122 100%);
      color:var(--ink);
    }

    .app{
      max-width:1880px;
      margin:0 auto;
      padding:18px;
      min-width:0;
    }

    .title{
      margin:0 0 6px;
      font-size:28px;
      font-weight:900;
      letter-spacing:.02em;
    }

    .sub{
      margin:0 0 16px;
      color:var(--muted);
      font-size:14px;
      line-height:1.5;
    }

    .panel{
      background:linear-gradient(180deg, rgba(10,20,42,.94), rgba(7,14,30,.96));
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      min-width:0;
    }

    .input-panel{
      padding:16px;
      margin-bottom:18px;
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    .field label{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.12em;
      color:var(--muted);
    }

    textarea{
      width:100%;
      min-height:220px;
      resize:vertical;
      border-radius:16px;
      border:1px solid var(--line);
      background:#08111f;
      color:var(--ink);
      padding:12px;
      outline:none;
      font:13px/1.5 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
    }

    textarea:focus{
      border-color:rgba(45,175,255,.45);
      box-shadow:0 0 0 3px rgba(45,175,255,.10);
    }

    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:12px;
      align-items:center;
    }

    button{
      border:0;
      border-radius:12px;
      padding:10px 16px;
      font-weight:800;
      cursor:pointer;
      background:linear-gradient(90deg, var(--cyan), #68ffd7);
      color:#08101d;
    }

    button.ghost{
      background:transparent;
      color:var(--ink);
      border:1px solid var(--line);
    }

    .status{
      margin-top:12px;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(255,255,255,.03);
      border:1px solid var(--line);
      color:var(--muted);
      font-size:13px;
      white-space:pre-wrap;
    }

    .status.error{
      color:#ffd7d7;
      border-color:rgba(255,123,123,.35);
      background:rgba(255,123,123,.08);
    }

    .note{
      margin-top:14px;
      font-size:12px;
      color:var(--muted);
      border-top:1px dashed var(--line);
      padding-top:12px;
      line-height:1.5;
    }

    code{
      background:rgba(255,255,255,.05);
      padding:2px 6px;
      border-radius:6px;
    }

    .match-head{
      display:grid;
      grid-template-columns:minmax(0,1fr) auto minmax(0,1fr);
      gap:12px;
      align-items:center;
      padding:12px 16px;
      margin-bottom:16px;
      border-radius:20px;
      min-width:0;
    }

    .match-team-name{
      min-width:0;
      font-size:24px;
      font-weight:900;
      color:var(--orange);
      text-transform:uppercase;
      line-height:1.1;
      white-space:normal;
      word-break:break-word;
    }

    .match-team-name.right{
      text-align:right;
    }

    .match-round{
      padding:8px 14px;
      border-radius:14px;
      border:1px solid rgba(124,172,255,.18);
      background:rgba(3,12,28,.72);
      font-size:16px;
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      color:#fff;
      white-space:nowrap;
    }

    .arena-wrap{
      display:grid;
      grid-template-columns:minmax(0,1fr) minmax(0,1fr);
      gap:16px;
      align-items:start;
      min-width:0;
    }

    .team-panel{
      position:relative;
      min-width:0;
      overflow:hidden;
      border-radius:24px;
      padding:14px;
      border:1px solid rgba(124,172,255,.12);
      background:
        linear-gradient(180deg, rgba(7,18,38,.95), rgba(5,14,30,.96)),
        linear-gradient(90deg, rgba(45,175,255,.04), rgba(255,127,50,.03));
      box-shadow:var(--shadow);
    }

    .team-panel::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:24px;
      pointer-events:none;
      box-shadow:inset 0 0 0 1px rgba(255,255,255,.025);
    }

    .team-glow{
      position:absolute;
      width:220px;
      height:220px;
      filter:blur(70px);
      opacity:.22;
      pointer-events:none;
    }

    .team-glow-left{
      top:-40px;
      left:-60px;
      background:#12b7ff;
    }

    .team-glow-right{
      top:-40px;
      right:-60px;
      background:#ff5a2d;
    }

    .team-inner{
      position:relative;
      z-index:1;
      display:grid;
      gap:12px;
      min-width:0;
    }

    .player-grid,
    .detail-grid{
      display:grid;
      grid-template-columns:repeat(4, minmax(0,1fr));
      gap:10px;
      align-items:start;
      min-width:0;
    }

    .player-card{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:10px;
      border-radius:16px;
      border:1px solid rgba(124,172,255,.10);
      background:rgba(255,255,255,.02);
    }

    .hero-card{
      position:relative;
      border-radius:18px;
      padding:4px;
      background:linear-gradient(180deg, rgba(55,133,255,.25), rgba(255,127,50,.10));
      border:1px solid rgba(124,172,255,.14);
    }

    .hero-card-inner{
      position:relative;
      height:120px;
      border-radius:15px;
      overflow:hidden;
      background:
        radial-gradient(circle at 50% 10%, rgba(255,255,255,.08), transparent 35%),
        linear-gradient(180deg, rgba(7,14,27,.75), rgba(2,8,18,.92));
      display:flex;
      align-items:flex-end;
      justify-content:center;
    }

    .hero-card-inner img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      padding:10px;
    }

    .hero-fallback{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-size:11px;
      text-align:center;
      padding:8px;
      line-height:1.2;
    }

    .char-name{
      text-align:center;
      font-size:13px;
      font-weight:800;
      color:#dfe9ff;
      line-height:1.2;
      white-space:normal;
      word-break:break-word;
      min-height:30px;
    }

    .player-tag{
      border:1px solid rgba(124,172,255,.14);
      background:rgba(255,255,255,.03);
      border-radius:999px;
      min-height:34px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:6px 8px;
      text-align:center;
      font-size:12px;
      font-weight:800;
      color:#f2f6ff;
      line-height:1.2;
      white-space:normal;
      word-break:break-word;
    }

    .skill-chip-row{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      gap:6px;
      min-height:40px;
    }

    .skill-chip{
      position:relative;
      width:64px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      min-width:0;
    }

    .skill-chip-icon{
      width:42px;
      height:42px;
      border-radius:10px;
      border:1px solid rgba(124,172,255,.18);
      background:rgba(255,255,255,.04);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      flex:0 0 auto;
    }

    .skill-chip-icon img{
      width:100%;
      height:100%;
      object-fit:contain;
      padding:4px;
    }

    .skill-chip-label{
      width:100%;
      font-size:10px;
      line-height:1.15;
      text-align:center;
      font-weight:800;
      color:#dfe9ff;
      white-space:normal;
      word-break:break-word;
    }

    .icon-fallback{
      font-size:10px;
      color:var(--muted);
      padding:4px;
      text-align:center;
      line-height:1.2;
    }

    .hover-wrap{
      position:relative;
      outline:none;
    }

    .hover-popup{
      position:absolute;
      left:50%;
      bottom:calc(100% + 10px);
      transform:translateX(-50%) translateY(6px);
      width:min(320px, calc(100vw - 32px));
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(124,172,255,.18);
      background:rgba(5,12,24,.98);
      box-shadow:0 18px 36px rgba(0,0,0,.45);
      opacity:0;
      pointer-events:none;
      transition:opacity .16s ease, transform .16s ease;
      z-index:50;
      text-align:left;
    }

    .hover-popup::after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-7px;
      width:12px;
      height:12px;
      transform:translateX(-50%) rotate(45deg);
      background:rgba(5,12,24,.98);
      border-right:1px solid rgba(124,172,255,.18);
      border-bottom:1px solid rgba(124,172,255,.18);
    }

    .hover-wrap:hover .hover-popup,
    .hover-wrap:focus-within .hover-popup{
      opacity:1;
      transform:translateX(-50%) translateY(0);
    }

    .hover-title{
      font-size:12px;
      font-weight:900;
      color:#fff;
      margin-bottom:4px;
      line-height:1.3;
    }

    .hover-meta{
      font-size:11px;
      color:#7fe0ff;
      font-weight:800;
      margin-bottom:6px;
      line-height:1.3;
    }

    .hover-body{
      font-size:11px;
      color:#d3dffc;
      line-height:1.45;
      white-space:normal;
    }

    .section-box{
      border-radius:16px;
      border:1px solid rgba(124,172,255,.10);
      background:rgba(255,255,255,.025);
      padding:8px;
      display:grid;
      gap:8px;
      min-width:0;
    }

    .section-title{
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
      font-weight:900;
      line-height:1.25;
      white-space:normal;
      word-break:break-word;
    }

    .single-card{
      min-height:46px;
      border-radius:12px;
      border:1px solid rgba(124,172,255,.10);
      background:rgba(255,255,255,.03);
      display:flex;
      align-items:flex-start;
      gap:6px;
      padding:6px;
      min-width:0;
    }

    .single-card.primary{
      border-color:rgba(255,173,58,.55);
      box-shadow:inset 0 0 0 1px rgba(255,173,58,.18);
    }

    .card-thumb{
      width:30px;
      height:30px;
      border-radius:8px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(124,172,255,.14);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      flex:0 0 auto;
    }

    .card-thumb img{
      width:100%;
      height:100%;
      object-fit:contain;
      padding:3px;
    }

    .card-copy{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:3px;
      width:100%;
    }

    .card-title{
      font-size:11px;
      font-weight:800;
      color:#eef4ff;
      line-height:1.15;
      white-space:normal;
      word-break:break-word;
    }

    .details-panel{
      margin-top:16px;
      padding:14px;
    }

    .details-panel-title{
      font-size:14px;
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      color:#eef4ff;
      margin-bottom:10px;
    }

    .details-wrap{
      display:grid;
      grid-template-columns:minmax(0,1fr) minmax(0,1fr);
      gap:16px;
      min-width:0;
    }

    .details-team-block{
      border-radius:18px;
      border:1px solid rgba(124,172,255,.10);
      background:rgba(255,255,255,.02);
      padding:10px;
      min-width:0;
      display:grid;
      gap:10px;
    }

    .details-team-title{
      font-size:12px;
      font-weight:900;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:#eef4ff;
      white-space:normal;
      word-break:break-word;
    }

    .detail-col{
      min-width:0;
      display:grid;
      gap:8px;
      align-content:start;
    }

    .detail-col-head{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(124,172,255,.10);
      background:rgba(255,255,255,.03);
      font-size:11px;
      font-weight:900;
      color:#eef4ff;
      line-height:1.25;
      text-align:center;
      white-space:normal;
      word-break:break-word;
    }

    .row-fold{
      border-radius:12px;
      border:1px solid rgba(124,172,255,.08);
      background:rgba(255,255,255,.02);
      overflow:hidden;
      min-width:0;
      margin-top:10px;
    }

    .row-fold:first-child{
      margin-top:0;
    }

    .row-fold summary{
      list-style:none;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:10px 12px;
      background:rgba(255,255,255,.02);
      color:#cfe0ff;
      font-size:10px;
      font-weight:900;
      text-transform:uppercase;
      letter-spacing:.08em;
      line-height:1.2;
    }

    .row-fold summary::-webkit-details-marker{
      display:none;
    }

    .row-fold summary::after{
      content:"▸";
      font-size:12px;
      color:#cfe0ff;
      flex:0 0 auto;
      transition:transform .18s ease;
    }

    .row-fold[open] summary::after{
      transform:rotate(90deg);
    }

    .row-fold-body{
      padding:10px;
      border-top:1px solid rgba(124,172,255,.08);
    }

    .stats-sections{
      display:grid;
      gap:8px;
      min-width:0;
    }

    .stats-category{
      border-radius:12px;
      border:1px solid rgba(124,172,255,.08);
      background:rgba(255,255,255,.02);
      overflow:hidden;
      min-width:0;
    }

    .stats-category-title{
      padding:6px 8px;
      font-size:10px;
      font-weight:900;
      color:#cfe0ff;
      text-transform:uppercase;
      letter-spacing:.08em;
      background:rgba(255,255,255,.03);
      border-bottom:1px solid rgba(124,172,255,.08);
      white-space:normal;
      line-height:1.2;
      word-break:break-word;
    }

    .stats-table{
      display:grid;
      min-width:0;
    }

    .stats-row{
      display:grid;
      grid-template-columns:minmax(72px,.9fr) minmax(0,1.1fr);
      gap:6px;
      padding:6px 8px;
      border-top:1px solid rgba(124,172,255,.06);
      align-items:start;
      min-width:0;
    }

    .stats-row:first-child{
      border-top:0;
    }

    .stats-key{
      font-size:10px;
      font-weight:800;
      color:var(--muted);
      white-space:normal;
      line-height:1.2;
      word-break:break-word;
    }

    .stats-val{
      font-size:10px;
      font-weight:700;
      color:#eef4ff;
      white-space:normal;
      line-height:1.25;
      word-break:break-word;
      min-width:0;
    }

    .empty-lite{
      color:var(--muted);
      font-size:11px;
      line-height:1.3;
      white-space:normal;
      word-break:break-word;
    }

    .prompt-panel{
      margin-top:16px;
      padding:14px;
    }

    .prompt-head{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }

    .prompt-title{
      font-size:14px;
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      color:#eef4ff;
    }

    #aiPromptOutput{
      min-height:340px;
      background:#07101f;
    }

    .copy-note{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
    }

    @media (max-width: 1500px){
      .player-grid,
      .detail-grid{
        grid-template-columns:repeat(2, minmax(0,1fr));
      }

      .hero-card-inner{
        height:130px;
      }
    }

    @media (max-width: 980px){
      .match-head{
        grid-template-columns:1fr;
        justify-items:center;
        text-align:center;
      }

      .match-team-name,
      .match-team-name.right{
        text-align:center;
      }

      .arena-wrap,
      .details-wrap{
        grid-template-columns:1fr;
      }

      .player-grid,
      .detail-grid{
        grid-template-columns:repeat(2, minmax(0,1fr));
      }
    }

    @media (max-width: 640px){
      .player-grid,
      .detail-grid{
        grid-template-columns:1fr;
      }

      .hero-card-inner{
        height:150px;
      }

      .stats-row{
        grid-template-columns:1fr;
        gap:4px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1 class="title">Clash Squad JSON → Team Viewer</h1>
    <p class="sub">Paste your match JSON, then render.</p>

    <div class="panel input-panel">
      <div class="field">
        <label for="jsonInput">Paste Match JSON</label>
        <textarea id="jsonInput" placeholder='Paste the full JSON here...'></textarea>
      </div>

      <div class="actions">
        <button id="renderBtn">Render</button>
        <button id="reloadLookupBtn" class="ghost" type="button">Reload Lookup + Images</button>
        <button id="clearBtn" class="ghost" type="button">Clear</button>
      </div>

      <div id="status" class="status">Loading lookup and image catalogs…</div>

      <div class="note">
        Loadout uses <code>player.loadouts[0]</code> and matches to <code>loadout_id</code> in <code>loadout.json</code>.
        <br>Loadout description is shown in a popup.
        <br>Purchased items now ignore loadout-style IDs and sanitize bad lookup text from <code>match_api</code>.
        <br>In Player Stat Details, each category collapses across both teams, and the expanded content keeps player columns aligned inside each team.
        <br>An AI-ready analysis prompt is generated at the bottom after render.
      </div>
    </div>

    <div class="panel match-head">
      <div id="teamAName" class="match-team-name">—</div>
      <div id="matchRound" class="match-round">Round —</div>
      <div id="teamBName" class="match-team-name right">—</div>
    </div>

    <div class="arena-wrap">
      <section class="team-panel">
        <div class="team-glow team-glow-left"></div>
        <div id="teamAContent" class="team-inner"></div>
      </section>

      <section class="team-panel">
        <div class="team-glow team-glow-right"></div>
        <div id="teamBContent" class="team-inner"></div>
      </section>
    </div>

    <div class="panel details-panel">
      <div class="details-panel-title">Player Stat Details</div>
      <div id="globalPlayerDetails"></div>
    </div>

    <div class="panel prompt-panel">
      <div class="prompt-head">
        <div class="prompt-title">AI Analysis Prompt</div>
        <button id="copyPromptBtn" class="ghost" type="button">Copy Prompt</button>
      </div>
      <textarea id="aiPromptOutput" readonly placeholder="Render match JSON first to generate a copy-ready prompt for AI analysis..."></textarea>
      <div id="copyPromptStatus" class="copy-note">The generated prompt is built for an esports commentator / analyst / coach perspective.</div>
    </div>
  </div>

  <script>
    const client = supabase.createClient(
      'https://gkugecflfddkpitlrmws.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdrdWdlY2ZsZmRka3BpdGxybXdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwODMwNzQsImV4cCI6MjA2MTY1OTA3NH0.OgQOx9k71DDdK1yOa7VNKGSgoFD9kNGo8j-bR91zGKE'
    );

    const CHARACTER_JSON_URL = 'https://misai-my.github.io/freefire-esports/character.json';
    const PET_JSON_URL = 'https://misai-my.github.io/freefire-esports/pet.json';
    const LOADOUT_JSON_URL = 'https://misai-my.github.io/freefire-esports/loadout.json';

    const $ = (id) => document.getElementById(id);

    let matchApiLoaded = false;
    let assetsLoaded = false;

    const LOOKUPS = {
      storeItems: new Map(),
      items: new Map(),
      skills: new Map(),
      pets: new Map()
    };

    const ASSETS = {
      charactersById: new Map(),
      charactersByName: new Map(),
      petsByName: new Map(),
      loadoutsById: new Map()
    };

    const LOADOUT_FALLBACKS = [
      { loadout_id: 500000003, name: 'Super Leg Pocket', image_url: 'https://i.imgur.com/hVW6fWi.png', cs_description: 'Start each match with key items and extra protection.' },
      { loadout_id: 500000004, name: 'Tactical Market', image_url: 'https://i.imgur.com/OBnERWB.png', cs_description: 'Get a tactical panel each round and deploy a chosen gadget.' },
      { loadout_id: 500000005, name: 'Team Booster', image_url: 'https://i.imgur.com/RAG1acC.png', cs_description: 'Helper Bot revives teammates remotely and Secret Bazaar team buffs are available in the CS Store.' },
      { loadout_id: 500000008, name: 'Enhance Hammer', image_url: 'https://i.imgur.com/gClc4RN.png', cs_description: 'Earn tokens via eliminations and enhance weapons / gloo walls during purchase phase.' }
    ];

    function setStatus(message, isError = false) {
      const el = $("status");
      el.textContent = message;
      el.className = isError ? "status error" : "status";
    }

    function setCopyPromptStatus(message) {
      $("copyPromptStatus").textContent = message;
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function escapeHtmlWithBreaks(value) {
      return escapeHtml(value ?? "").replace(/\n/g, "<br>");
    }

    function normalizeKey(value) {
      return String(value ?? "")
        .trim()
        .toUpperCase()
        .replace(/[^A-Z0-9]+/g, "");
    }

    function toNum(value, fallback = 0) {
      const n = Number(value);
      return Number.isFinite(n) ? n : fallback;
    }

    function humanizeKey(key) {
      return String(key || "")
        .replace(/_/g, " ")
        .replace(/\b\w/g, c => c.toUpperCase());
    }

    function formatGenericValue(value) {
      if (value === null || value === undefined) return "—";
      if (typeof value === "boolean") return value ? "Yes" : "No";

      if (Array.isArray(value)) {
        if (!value.length) return "0";

        const allPrimitive = value.every(v =>
          v === null || ["string", "number", "boolean"].includes(typeof v)
        );

        if (allPrimitive) return value.map(v => formatGenericValue(v)).join(", ");
        return `${value.length} entries`;
      }

      if (typeof value === "object") {
        try { return JSON.stringify(value); }
        catch { return "[object]"; }
      }

      return String(value);
    }

    function scoreLookupName(name) {
      const s = String(name || "").trim();
      if (!s) return -999;

      let score = 0;

      if (!/\b500000\d+\b/.test(s)) score += 100;

      const wordCount = s.split(/\s+/).filter(Boolean).length;
      if (wordCount <= 4) score += 40;
      else if (wordCount <= 7) score += 15;
      else score -= 20;

      if (/[.!?]/.test(s)) score -= 25;
      if (/(will|obtain|marked on the map|once you open|head there)/i.test(s)) score -= 40;

      score -= Math.min(s.length, 120) * 0.15;

      return score;
    }

    function setBestLookupEntry(map, id, name) {
      const cleanName = String(name || "").trim();
      if (!cleanName) return;

      const current = map.get(id);
      if (!current) {
        map.set(id, cleanName);
        return;
      }

      if (scoreLookupName(cleanName) > scoreLookupName(current)) {
        map.set(id, cleanName);
      }
    }

    function sanitizeResolvedItemName(name) {
      let s = String(name || "").replace(/\s+/g, " ").trim();
      if (!s) return null;

      s = s.replace(/\s*\b500000\d+\b[\s\S]*$/, "").trim();

      const words = s.split(/\s+/).filter(Boolean);
      if (words.length > 6) {
        s = words.slice(0, 4).join(" ");
      }

      if (!s) return null;
      return s;
    }

    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to fetch ${url} (${res.status})`);
      return res.json();
    }

    function resolveItemName(id, preferStore = false) {
      const numId = Number(id);
      if (!Number.isFinite(numId)) return null;

      let raw = null;

      if (preferStore) {
        raw = LOOKUPS.storeItems.get(numId) || LOOKUPS.items.get(numId) || null;
      } else {
        raw = LOOKUPS.items.get(numId) || LOOKUPS.storeItems.get(numId) || null;
      }

      return sanitizeResolvedItemName(raw);
    }

    function getLookupName(type, id) {
      const numId = Number(id);
      if (!Number.isFinite(numId)) return null;

      if (type === 0) return LOOKUPS.storeItems.get(numId) || null;
      if (type === 1) return LOOKUPS.items.get(numId) || null;
      if (type === 2) return LOOKUPS.skills.get(numId) || null;
      if (type === 3) return LOOKUPS.pets.get(numId) || null;
      return null;
    }

    async function loadMatchApiLookups() {
      const { data, error } = await client
        .from("match_api")
        .select("id, type, name")
        .in("type", [0, 1, 2, 3]);

      if (error) throw error;

      LOOKUPS.storeItems.clear();
      LOOKUPS.items.clear();
      LOOKUPS.skills.clear();
      LOOKUPS.pets.clear();

      for (const row of (data || [])) {
        const id = Number(row.id);
        const type = Number(row.type);
        const name = String(row.name || "").trim();

        if (!Number.isFinite(id) || !name) continue;

        if (type === 0) setBestLookupEntry(LOOKUPS.storeItems, id, name);
        if (type === 1) setBestLookupEntry(LOOKUPS.items, id, name);
        if (type === 2) setBestLookupEntry(LOOKUPS.skills, id, name);
        if (type === 3) setBestLookupEntry(LOOKUPS.pets, id, name);
      }

      matchApiLoaded = true;

      return {
        storeItems: LOOKUPS.storeItems.size,
        items: LOOKUPS.items.size,
        skills: LOOKUPS.skills.size,
        pets: LOOKUPS.pets.size
      };
    }

    function seedFallbackLoadouts() {
      ASSETS.loadoutsById.clear();

      for (const row of LOADOUT_FALLBACKS) {
        ASSETS.loadoutsById.set(Number(row.loadout_id), {
          loadout_id: Number(row.loadout_id),
          name: row.name,
          image_url: row.image_url,
          cs_description: row.cs_description
        });
      }
    }

    function extractLoadoutRows(raw) {
      const rows = Array.isArray(raw) ? raw : [];

      for (const row of rows) {
        const loadoutId = Number(row?.loadout_id);
        if (!Number.isFinite(loadoutId)) continue;

        ASSETS.loadoutsById.set(loadoutId, {
          loadout_id: loadoutId,
          name: String(row?.name || "").trim(),
          image_url: String(row?.image_url || "").trim(),
          cs_description: String(row?.description?.cs || "").trim()
        });
      }
    }

    async function loadAssetCatalogs() {
      const [characters, pets, loadouts] = await Promise.allSettled([
        fetchJson(CHARACTER_JSON_URL),
        fetchJson(PET_JSON_URL),
        fetchJson(LOADOUT_JSON_URL)
      ]);

      ASSETS.charactersById.clear();
      ASSETS.charactersByName.clear();
      ASSETS.petsByName.clear();
      seedFallbackLoadouts();

      if (characters.status === "fulfilled") {
        for (const row of (characters.value || [])) {
          const imageUrl = row?.image_url || "";
          const apiId = Number(row?.api_id);
          const asset = {
            name: row?.name || "",
            image_url: imageUrl,
            skill: row?.skill || "",
            description: row?.description || ""
          };

          if (imageUrl && Number.isFinite(apiId)) {
            ASSETS.charactersById.set(apiId, asset);
          }

          if (row?.name) ASSETS.charactersByName.set(normalizeKey(row.name), asset);
          if (row?.skill) ASSETS.charactersByName.set(normalizeKey(row.skill), asset);
        }
      }

      if (pets.status === "fulfilled") {
        for (const row of (pets.value || [])) {
          if (!row?.name) continue;

          ASSETS.petsByName.set(normalizeKey(row.name), {
            name: row.name,
            image_url: row?.image_url || "",
            skill: row?.skill || "",
            description: row?.description || ""
          });
        }
      }

      if (loadouts.status === "fulfilled") {
        extractLoadoutRows(loadouts.value);
      }

      assetsLoaded = true;

      return {
        characters: ASSETS.charactersById.size,
        pets: ASSETS.petsByName.size,
        loadouts: ASSETS.loadoutsById.size
      };
    }

    async function warmUp() {
      setStatus("Loading lookup and image catalogs...");

      const [lookupResult, assetResult] = await Promise.allSettled([
        loadMatchApiLookups(),
        loadAssetCatalogs()
      ]);

      const errors = [];

      if (lookupResult.status === "rejected") {
        matchApiLoaded = false;
        errors.push(`match_api: ${lookupResult.reason?.message || lookupResult.reason}`);
      }

      if (assetResult.status === "rejected") {
        assetsLoaded = false;
        errors.push(`asset catalogs: ${assetResult.reason?.message || assetResult.reason}`);
      }

      if (errors.length) {
        setStatus(`Some data failed to load:\n${errors.join("\n")}`, true);
        return;
      }

      setStatus(
        `Ready.\n` +
        `match_api → Type0 ${lookupResult.value.storeItems}, Type1 ${lookupResult.value.items}, Skills ${lookupResult.value.skills}, Pets ${lookupResult.value.pets}\n` +
        `Assets → Characters ${assetResult.value.characters}, Pets ${assetResult.value.pets}, Loadouts ${assetResult.value.loadouts}`
      );
    }

    function getCharacterAsset(skillId, fallbackName = "") {
      const byId = ASSETS.charactersById.get(Number(skillId));
      if (byId) return byId;

      if (fallbackName) {
        const byName = ASSETS.charactersByName.get(normalizeKey(fallbackName));
        if (byName) return byName;
      }

      return null;
    }

    function getPetAsset(name = "") {
      if (!name) return null;
      return ASSETS.petsByName.get(normalizeKey(name)) || null;
    }

    function getLoadoutAsset(loadoutId) {
      const id = Number(loadoutId);
      if (!Number.isFinite(id)) return null;
      return ASSETS.loadoutsById.get(id) || null;
    }

    function getActiveSkillInfo(player) {
      const info = Array.isArray(player?.skill_info) ? player.skill_info : [];
      return info.find(s => s && s.skill_active === true) || info[0] || null;
    }

    function getActiveSkillId(player) {
      const activeInfo = getActiveSkillInfo(player);
      return activeInfo?.skill_id ?? (Array.isArray(player?.skill_ids) ? player.skill_ids[0] : null);
    }

    function getActiveSkillEntry(player) {
      const activeInfo = getActiveSkillInfo(player);
      const activeId = getActiveSkillId(player);

      if (!activeId) {
        return { id:null, label:"—", skill:"", description:"", image_url:"", slotType:"Active" };
      }

      const lookupName = getLookupName(2, activeId) || activeInfo?.skill_name || `Skill ID ${activeId}`;
      const asset = getCharacterAsset(activeId, lookupName);

      return {
        id: Number(activeId),
        label: asset?.name || lookupName,
        skill: asset?.skill || activeInfo?.skill_name || lookupName,
        description: asset?.description || "",
        image_url: asset?.image_url || "",
        slotType: "Active"
      };
    }

    function getPassiveSkillEntries(player) {
      const ids = Array.isArray(player?.skill_ids) ? player.skill_ids : [];
      const activeId = getActiveSkillId(player);

      const uniquePassiveIds = [...new Set(ids.filter(id => Number(id) !== Number(activeId)))];

      return uniquePassiveIds.map(id => {
        const lookupName = getLookupName(2, id) || `Skill ID ${id}`;
        const asset = getCharacterAsset(id, lookupName);

        return {
          id: Number(id),
          label: asset?.name || lookupName,
          skill: asset?.skill || lookupName,
          description: asset?.description || "",
          image_url: asset?.image_url || "",
          slotType: "Passive"
        };
      });
    }

    function getPetEntry(player) {
      const petId = player?.pet_skill_id;
      if (!petId) {
        return { id:null, label:"—", skill:"", description:"", image_url:"", slotType:"Pet" };
      }

      const lookupName = getLookupName(3, petId) || `Pet ID ${petId}`;
      const asset = getPetAsset(lookupName);

      return {
        id: Number(petId),
        label: asset?.name || lookupName,
        skill: asset?.skill || lookupName,
        description: asset?.description || "",
        image_url: asset?.image_url || "",
        slotType: "Pet"
      };
    }

    function getPlayerLoadoutId(player) {
      const arr = Array.isArray(player?.loadouts) ? player.loadouts : [];
      if (!arr.length) return null;

      const id = Number(arr[0]);
      return Number.isFinite(id) ? id : null;
    }

    function getPlayerLoadoutEntry(player) {
      const id = getPlayerLoadoutId(player);

      if (!Number.isFinite(id)) {
        return { loadout_id:null, name:"No loadout found", image_url:"", cs_description:"" };
      }

      const asset = getLoadoutAsset(id);

      return {
        loadout_id: id,
        name: asset?.name || `Loadout ${id}`,
        image_url: asset?.image_url || "",
        cs_description: asset?.cs_description || ""
      };
    }

    function getLatestRoundStat(player) {
      const rounds = Array.isArray(player?.round_stats) ? [...player.round_stats] : [];
      if (!rounds.length) return null;
      rounds.sort((a, b) => toNum(b?.round_index, -1) - toNum(a?.round_index, -1));
      return rounds[0];
    }

    function getLatestItems(player) {
      const round = getLatestRoundStat(player);
      const items = Array.isArray(round?.item_nums) ? round.item_nums : [];

      return items
        .filter(item => toNum(item?.item_num) > 0)
        .map(item => {
          const id = Number(item?.item_id);
          const name = resolveItemName(id, false) || item?.item_name || `Item ID ${id}`;
          return { id, name, count: toNum(item?.item_num) };
        })
        .sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));
    }

    function getLatestPurchasedItems(player) {
      const round = getLatestRoundStat(player);
      const purchased = Array.isArray(round?.purchased_items) ? round.purchased_items : [];
      const counts = new Map();

      for (const rawId of purchased) {
        const id = Number(rawId);
        if (!Number.isFinite(id)) continue;

        if (id >= 500000000) continue;

        const resolvedName = resolveItemName(id, true);
        if (!resolvedName) continue;

        counts.set(id, (counts.get(id) || 0) + 1);
      }

      return [...counts.entries()]
        .map(([id, count]) => ({
          id,
          name: resolveItemName(id, true),
          count
        }))
        .sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));
    }

    function getLatestWeaponUsages(player) {
      const round = getLatestRoundStat(player);
      const usages = Array.isArray(round?.weapon_usages) ? round.weapon_usages : [];

      return usages.map(weapon => ({
        raw: weapon || {},
        id: Number(weapon?.weapon_id),
        name: weapon?.weapon_name || `Weapon ID ${weapon?.weapon_id ?? "?"}`
      }));
    }

    function getDisplayRound(payload, teams = []) {
      let best = -1;

      const matchRounds = payload?.match?.match_stats_extra?.round_stats;
      if (Array.isArray(matchRounds)) {
        for (const r of matchRounds) best = Math.max(best, toNum(r?.round_index, -1));
      }

      for (const team of teams) {
        const players = Array.isArray(team?.player_stats) ? team.player_stats : [];
        for (const player of players) {
          const rounds = Array.isArray(player?.round_stats) ? player.round_stats : [];
          for (const r of rounds) best = Math.max(best, toNum(r?.round_index, -1));
        }
      }

      return best >= 0 ? `Round ${best + 1}` : "Round —";
    }

    function renderHeroImage(imageUrl, alt) {
      if (!imageUrl) return `<div class="hero-fallback">No Image</div>`;
      return `<img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(alt)}" loading="lazy">`;
    }

    function renderPopup(title, meta, body) {
      if (!body) return "";
      return `
        <div class="hover-popup">
          <div class="hover-title">${escapeHtml(title || "Info")}</div>
          <div class="hover-meta">${escapeHtml(meta || "")}</div>
          <div class="hover-body">${escapeHtmlWithBreaks(body)}</div>
        </div>
      `;
    }

    function renderTooltip(entry) {
      if (!entry || (!entry.skill && !entry.description)) return "";

      const meta = entry.slotType ? `${entry.slotType}${entry.label ? " • " + entry.label : ""}` : (entry.label || "");
      return renderPopup(entry.skill || entry.label || "Skill", meta, entry.description || "No description available.");
    }

    function renderSkillChip(entry) {
      if (!entry) return "";

      return `
        <div class="skill-chip hover-wrap" tabindex="0">
          <div class="skill-chip-icon">
            ${entry.image_url
              ? `<img src="${escapeHtml(entry.image_url)}" alt="${escapeHtml(entry.label)}" loading="lazy">`
              : `<span class="icon-fallback">N/A</span>`
            }
          </div>
          <div class="skill-chip-label">${escapeHtml(entry.label || "—")}</div>
          ${renderTooltip(entry)}
        </div>
      `;
    }

    function renderLoadoutCard(loadout) {
      const title = loadout?.name || "No loadout found";
      const desc = loadout?.cs_description || "";

      return `
        <div class="hover-wrap" tabindex="0">
          <div class="single-card primary">
            <div class="card-thumb">
              ${loadout?.image_url
                ? `<img src="${escapeHtml(loadout.image_url)}" alt="${escapeHtml(title)}" loading="lazy">`
                : `<span class="icon-fallback">N/A</span>`
              }
            </div>
            <div class="card-copy">
              <div class="card-title">${escapeHtml(title)}</div>
            </div>
          </div>
          ${desc ? renderPopup(title, "Loadout", desc) : ""}
        </div>
      `;
    }

    function categorizeRoundStats(round) {
      const sections = {
        "Round Outcome & Flags": [],
        "Combat Output": [],
        "Damage & Survival": [],
        "Support & Recovery": [],
        "Economy & Purchases": [],
        "Abilities & Utility": [],
        "Other Round Fields": []
      };

      const exclude = new Set(["purchased_items", "weapon_usages", "item_nums"]);

      const map = {
        round_index: "Round Outcome & Flags",
        is_win: "Round Outcome & Flags",
        is_dead: "Round Outcome & Flags",
        is_first_down: "Round Outcome & Flags",
        is_first_taken_down: "Round Outcome & Flags",

        kill: "Combat Output",
        assists: "Combat Output",
        knock_down: "Combat Output",
        headshots: "Combat Output",
        hits: "Combat Output",
        torso_hits: "Combat Output",
        leg_hits: "Combat Output",

        damage: "Damage & Survival",
        real_damage: "Damage & Survival",
        real_damage_taken: "Damage & Survival",

        healing_to_self: "Support & Recovery",
        healing_to_teammates: "Support & Recovery",
        rescue_count: "Support & Recovery",

        economy_spent_self: "Economy & Purchases",
        economy_spent_on_teammates: "Economy & Purchases",
        initial_item_value: "Economy & Purchases",
        airdrop_points: "Economy & Purchases",

        nb_skill_usages: "Abilities & Utility",
        medkit_use: "Abilities & Utility",
        grenade_use: "Abilities & Utility",
        icewall_use: "Abilities & Utility",
        throwable_use: "Abilities & Utility"
      };

      for (const [key, value] of Object.entries(round || {})) {
        if (exclude.has(key)) continue;
        const bucket = map[key] || "Other Round Fields";
        sections[bucket].push([key, value]);
      }

      return sections;
    }

    function buildCurrentItemsContent(player) {
      const items = getLatestItems(player);

      return `
        <div class="stats-category">
          <div class="stats-table">
            ${
              items.length
                ? items.map(item => `
                    <div class="stats-row">
                      <div class="stats-key">${escapeHtml(item.name)}</div>
                      <div class="stats-val">Count: ${item.count}</div>
                    </div>
                  `).join("")
                : `
                    <div class="stats-row">
                      <div class="stats-key">Items</div>
                      <div class="stats-val">No current item snapshot found.</div>
                    </div>
                  `
            }
          </div>
        </div>
      `;
    }

    function buildPurchasedItemsContent(player) {
      const items = getLatestPurchasedItems(player);

      return `
        <div class="stats-category">
          <div class="stats-table">
            ${
              items.length
                ? items.map(item => `
                    <div class="stats-row">
                      <div class="stats-key">${escapeHtml(item.name)}</div>
                      <div class="stats-val">Purchased x${item.count}</div>
                    </div>
                  `).join("")
                : `
                    <div class="stats-row">
                      <div class="stats-key">Purchased Items</div>
                      <div class="stats-val">No purchased items found in latest round.</div>
                    </div>
                  `
            }
          </div>
        </div>
      `;
    }

    function buildWeaponUsagesContent(player) {
      const usages = getLatestWeaponUsages(player);

      return `
        <div class="stats-sections">
          ${
            usages.length
              ? usages.map(weapon => {
                  const rows = Object.entries(weapon.raw).filter(([k]) => k !== "weapon_name" && k !== "weapon_id");

                  return `
                    <div class="stats-category">
                      <div class="stats-category-title">${escapeHtml(weapon.name)}</div>
                      <div class="stats-table">
                        <div class="stats-row">
                          <div class="stats-key">Weapon ID</div>
                          <div class="stats-val">${Number.isFinite(weapon.id) ? weapon.id : "No weapon ID"}</div>
                        </div>
                        ${
                          rows.length
                            ? rows.map(([key, value]) => `
                                <div class="stats-row">
                                  <div class="stats-key">${escapeHtml(humanizeKey(key))}</div>
                                  <div class="stats-val">${escapeHtml(formatGenericValue(value))}</div>
                                </div>
                              `).join("")
                            : `
                                <div class="stats-row">
                                  <div class="stats-key">Stats</div>
                                  <div class="stats-val">No weapon usage fields found.</div>
                                </div>
                              `
                        }
                      </div>
                    </div>
                  `;
                }).join("")
              : `<div class="empty-lite">No weapon usage data found in latest round.</div>`
          }
        </div>
      `;
    }

    function buildLatestRoundStatsContent(player) {
      const round = getLatestRoundStat(player);

      if (!round) {
        return `
          <div class="stats-category">
            <div class="stats-table">
              <div class="stats-row">
                <div class="stats-key">Round Stats</div>
                <div class="stats-val">No round_stats found for this player.</div>
              </div>
            </div>
          </div>
        `;
      }

      const sections = categorizeRoundStats(round);

      return `
        <div class="stats-sections">
          ${Object.entries(sections)
            .filter(([, rows]) => rows.length)
            .map(([title, rows]) => `
              <div class="stats-category">
                <div class="stats-category-title">${escapeHtml(title)}</div>
                <div class="stats-table">
                  ${rows.map(([key, value]) => `
                    <div class="stats-row">
                      <div class="stats-key">${escapeHtml(humanizeKey(key))}</div>
                      <div class="stats-val">${escapeHtml(formatGenericValue(value))}</div>
                    </div>
                  `).join("")}
                </div>
              </div>
            `).join("")}
        </div>
      `;
    }

    function renderPlayerSummaryCard(player) {
      const playerName = player?.nickname || player?.account_id || "Unknown";
      const activeSkill = getActiveSkillEntry(player);
      const passiveSkills = getPassiveSkillEntries(player);
      const pet = getPetEntry(player);
      const loadout = getPlayerLoadoutEntry(player);

      return `
        <div class="player-card">
          <div class="hover-wrap" tabindex="0">
            <div class="hero-card">
              <div class="hero-card-inner">
                ${renderHeroImage(activeSkill.image_url, activeSkill.label)}
              </div>
            </div>
            ${renderTooltip(activeSkill)}
          </div>

          <div class="char-name">${escapeHtml(activeSkill.label || "—")}</div>
          <div class="player-tag">${escapeHtml(playerName)}</div>

          <div class="section-box">
            <div class="section-title">Passive Skills</div>
            <div class="skill-chip-row">
              ${
                passiveSkills.length
                  ? passiveSkills.map(renderSkillChip).join("")
                  : `<div class="empty-lite">No passive skills found.</div>`
              }
            </div>
          </div>

          <div class="section-box">
            <div class="section-title">Pet</div>
            <div class="skill-chip-row">
              ${
                pet?.id
                  ? renderSkillChip(pet)
                  : `<div class="empty-lite">No pet found.</div>`
              }
            </div>
          </div>

          <div class="section-box">
            <div class="section-title">Loadout</div>
            ${renderLoadoutCard(loadout)}
          </div>
        </div>
      `;
    }

    function renderPlayerCategoryColumn(player, contentHtml) {
      const playerName = player?.nickname || player?.account_id || "Unknown";

      return `
        <div class="detail-col">
          <div class="detail-col-head">${escapeHtml(playerName)}</div>
          ${contentHtml}
        </div>
      `;
    }

    function renderCategoryContentForTeam(team, fallbackName, builderFn) {
      const players = Array.isArray(team?.player_stats) ? team.player_stats : [];
      const teamName = team?.team_name || fallbackName;

      return `
        <div class="details-team-block">
          <div class="details-team-title">${escapeHtml(teamName)}</div>
          ${
            players.length
              ? `<div class="detail-grid">${players.map(player => renderPlayerCategoryColumn(player, builderFn(player))).join("")}</div>`
              : `<div class="empty-lite">No players found.</div>`
          }
        </div>
      `;
    }

    function renderGlobalCategoryRow(teams, title, builderFn) {
      return `
        <details class="row-fold">
          <summary>${escapeHtml(title)}</summary>
          <div class="row-fold-body">
            <div class="details-wrap">
              ${renderCategoryContentForTeam(teams[0], "Team A", builderFn)}
              ${renderCategoryContentForTeam(teams[1], "Team B", builderFn)}
            </div>
          </div>
        </details>
      `;
    }

    function renderTeamContent(team) {
      const players = Array.isArray(team?.player_stats) ? team.player_stats : [];

      if (!players.length) {
        return `<div class="empty-lite">No players found.</div>`;
      }

      return `
        <div class="player-grid">
          ${players.map(renderPlayerSummaryCard).join("")}
        </div>
      `;
    }

    function renderGlobalPlayerDetails(teams) {
      return `
        ${renderGlobalCategoryRow(teams, "Current Items Latest Round Inventory", buildCurrentItemsContent)}
        ${renderGlobalCategoryRow(teams, "Purchased Items Latest Round Type 0 To Type 1 Fallback", buildPurchasedItemsContent)}
        ${renderGlobalCategoryRow(teams, "Weapon Usages Latest Round", buildWeaponUsagesContent)}
        ${renderGlobalCategoryRow(teams, "Latest Round Stats Broken Down By Section", buildLatestRoundStatsContent)}
      `;
    }

    function summarizeSimpleList(arr, mapper, emptyText = "None") {
      const out = (Array.isArray(arr) ? arr : [])
        .map(mapper)
        .map(v => String(v || "").trim())
        .filter(Boolean);
      return out.length ? out.join(", ") : emptyText;
    }

    function summarizeItemsForPrompt(items) {
      return (items && items.length)
        ? items.map(item => `${item.name} x${item.count}`).join(", ")
        : "None";
    }

    function summarizeWeaponsForPrompt(usages) {
      if (!usages || !usages.length) return "None";

      return usages.map(weapon => {
        const extra = Object.entries(weapon.raw || {})
          .filter(([k]) => k !== "weapon_name" && k !== "weapon_id")
          .map(([k, v]) => `${humanizeKey(k)}: ${formatGenericValue(v)}`)
          .join("; ");

        return `${weapon.name}${Number.isFinite(weapon.id) ? ` [ID ${weapon.id}]` : ""}${extra ? ` — ${extra}` : ""}`;
      }).join("\n      - ");
    }

    function summarizeRoundStatsForPrompt(player) {
      const round = getLatestRoundStat(player);
      if (!round) return "No round_stats found.";

      const sections = categorizeRoundStats(round);
      const lines = [];

      for (const [title, rows] of Object.entries(sections)) {
        if (!rows.length) continue;
        lines.push(`${title}: ${rows.map(([key, value]) => `${humanizeKey(key)} = ${formatGenericValue(value)}`).join("; ")}`);
      }

      return lines.length ? lines.join("\n      - ") : "No categorized round stats found.";
    }

    function buildPlayerPromptBlock(player, idx) {
      const activeSkill = getActiveSkillEntry(player);
      const passiveSkills = getPassiveSkillEntries(player);
      const pet = getPetEntry(player);
      const loadout = getPlayerLoadoutEntry(player);
      const currentItems = getLatestItems(player);
      const purchasedItems = getLatestPurchasedItems(player);
      const weaponUsages = getLatestWeaponUsages(player);

      const playerName = player?.nickname || player?.account_id || `Player ${idx + 1}`;
      const accountId = player?.account_id || "N/A";

      return [
        `${idx + 1}. ${playerName}`,
        `   - Account ID: ${accountId}`,
        `   - Active Skill: ${activeSkill.label || "None"}`,
        `   - Passive Skills: ${summarizeSimpleList(passiveSkills, s => s.label, "None")}`,
        `   - Pet: ${pet.label || "None"}`,
        `   - Loadout: ${loadout.name || "None"}`,
        `   - Current Items (Latest Round Inventory): ${summarizeItemsForPrompt(currentItems)}`,
        `   - Purchased Items (Latest Round): ${summarizeItemsForPrompt(purchasedItems)}`,
        `   - Weapon Usages (Latest Round):`,
        `      - ${summarizeWeaponsForPrompt(weaponUsages)}`,
        `   - Latest Round Stats By Section:`,
        `      - ${summarizeRoundStatsForPrompt(player)}`
      ].join("\n");
    }

    function buildTeamPromptBlock(team, fallbackName) {
      const teamName = team?.team_name || fallbackName;
      const players = Array.isArray(team?.player_stats) ? team.player_stats : [];

      return [
        `=== ${teamName} ===`,
        players.length
          ? players.map((player, idx) => buildPlayerPromptBlock(player, idx)).join("\n\n")
          : "No players found."
      ].join("\n");
    }

    function buildAiAnalysisPrompt(payload, teams) {
      const roundText = getDisplayRound(payload, teams);

      return [
        `You are an expert esports commentator, analyst, and coach reviewing a Free Fire Clash Squad match snapshot.`,
        ``,
        `Use the data below to produce a deep but practical analysis.`,
        ``,
        `Please provide:`,
        `1. A caster-ready overview of both teams and their likely game plan.`,
        `2. A coach-style breakdown of each team's strengths, weaknesses, win conditions, and risk factors.`,
        `3. Player-by-player insights, including who is carrying, enabling, struggling, or playing supportive roles.`,
        `4. A read on item economy, purchased utility, and what the loadouts suggest about team strategy.`,
        `5. A breakdown of weapon usage and what it says about preferred fight distances and execution.`,
        `6. A comparison of both teams' compositions, active/passive synergy, pet impact, and loadout value.`,
        `7. The most important storylines an esports commentator should highlight on broadcast.`,
        `8. Clear coaching adjustments for each team if they were going into the next round.`,
        `9. A short final verdict: which team currently looks better and why.`,
        ``,
        `Keep the response useful for:`,
        `- live shoutcasting / commentary`,
        `- analyst desk breakdown`,
        `- team coaching review`,
        ``,
        `Match Context:`,
        `- Display Round: ${roundText}`,
        `- Team A: ${teams[0]?.team_name || "Team A"}`,
        `- Team B: ${teams[1]?.team_name || "Team B"}`,
        ``,
        `Data:`,
        ``,
        buildTeamPromptBlock(teams[0], "Team A"),
        ``,
        buildTeamPromptBlock(teams[1], "Team B"),
        ``,
        `Now analyze this as an esports commentator / analyst / coach.`
      ].join("\n");
    }

    async function copyTextToClipboard(text) {
      if (!text) return false;

      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
          return true;
        }
      } catch {}

      const temp = document.createElement("textarea");
      temp.value = text;
      temp.style.position = "fixed";
      temp.style.opacity = "0";
      temp.style.pointerEvents = "none";
      document.body.appendChild(temp);
      temp.focus();
      temp.select();

      let ok = false;
      try {
        ok = document.execCommand("copy");
      } catch {
        ok = false;
      }

      document.body.removeChild(temp);
      return ok;
    }

    function clearRender() {
      $("teamAName").textContent = "—";
      $("teamBName").textContent = "—";
      $("matchRound").textContent = "Round —";
      $("teamAContent").innerHTML = "";
      $("teamBContent").innerHTML = "";
      $("globalPlayerDetails").innerHTML = "";
      $("aiPromptOutput").value = "";
      setCopyPromptStatus("The generated prompt is built for an esports commentator / analyst / coach perspective.");
    }

    function getPayload(data) {
      return Array.isArray(data) ? data[0] : data;
    }

    function getTeamsFromPayload(payload) {
      return Array.isArray(payload?.team_stats) ? payload.team_stats : [];
    }

    async function ensureResourcesLoaded() {
      const tasks = [];

      if (!matchApiLoaded) tasks.push(loadMatchApiLookups());
      if (!assetsLoaded) tasks.push(loadAssetCatalogs());

      if (!tasks.length) return;

      setStatus("Loading missing lookup/image resources...");
      await Promise.all(tasks);

      setStatus(
        `Ready.\n` +
        `match_api → Type0 ${LOOKUPS.storeItems.size}, Type1 ${LOOKUPS.items.size}, Skills ${LOOKUPS.skills.size}, Pets ${LOOKUPS.pets.size}\n` +
        `Assets → Characters ${ASSETS.charactersById.size}, Pets ${ASSETS.petsByName.size}, Loadouts ${ASSETS.loadoutsById.size}`
      );
    }

    async function renderJson() {
      try {
        const raw = $("jsonInput").value.trim();

        if (!raw) {
          clearRender();
          setStatus("Paste JSON first.", true);
          return;
        }

        await ensureResourcesLoaded();

        let data;
        try {
          data = JSON.parse(raw);
        } catch (err) {
          clearRender();
          setStatus(`Invalid JSON:\n${err.message}`, true);
          return;
        }

        const payload = getPayload(data);
        const teams = getTeamsFromPayload(payload);

        if (teams.length < 2) {
          clearRender();
          setStatus("This JSON needs at least 2 teams inside team_stats.", true);
          return;
        }

        $("teamAName").textContent = teams[0]?.team_name || "—";
        $("teamBName").textContent = teams[1]?.team_name || "—";
        $("matchRound").textContent = getDisplayRound(payload, teams);

        $("teamAContent").innerHTML = renderTeamContent(teams[0]);
        $("teamBContent").innerHTML = renderTeamContent(teams[1]);
        $("globalPlayerDetails").innerHTML = renderGlobalPlayerDetails(teams);
        $("aiPromptOutput").value = buildAiAnalysisPrompt(payload, teams);

        let message = `Rendered ${teams[0]?.team_name || "Team A"} vs ${teams[1]?.team_name || "Team B"}.`;
        if (teams.length > 2) {
          message += ` Found ${teams.length} teams total, so only the first 2 were shown.`;
        }

        setStatus(message);
        setCopyPromptStatus("AI prompt generated. Use Copy Prompt to paste it into another AI tool.");
      } catch (err) {
        setStatus(`Render failed:\n${err.message || err}`, true);
      }
    }

    $("renderBtn").addEventListener("click", renderJson);

    $("reloadLookupBtn").addEventListener("click", async () => {
      matchApiLoaded = false;
      assetsLoaded = false;
      try {
        await warmUp();
      } catch (err) {
        setStatus(`Reload failed:\n${err.message || err}`, true);
      }
    });

    $("clearBtn").addEventListener("click", () => {
      $("jsonInput").value = "";
      clearRender();
      setStatus("Cleared. Paste new JSON to render.");
    });

    $("copyPromptBtn").addEventListener("click", async () => {
      const text = $("aiPromptOutput").value.trim();
      if (!text) {
        setCopyPromptStatus("No prompt to copy yet. Render match JSON first.");
        return;
      }

      const ok = await copyTextToClipboard(text);
      setCopyPromptStatus(ok ? "AI prompt copied to clipboard." : "Copy failed. You can still manually select and copy the prompt.");
    });

    warmUp();
  </script>
</body>
</html>
