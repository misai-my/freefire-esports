<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FF Stats — Teams & Players</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;800&family=Roboto:wght@400;500;700;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#07090f;
      --bg2:#0b1020;
      --panel: rgba(20, 26, 38, .72);
      --panel2: rgba(14, 18, 28, .70);
      --line: rgba(255,255,255,.08);
      --ink:#f4f6ff;
      --muted:#aab1c5;

      --brand:#ffbd59;
      --brand2:#ff7733;
      --accent:#4dd3ff;

      --radius:16px;
      --radius-lg:22px;
      --shadow: 0 22px 70px rgba(0,0,0,.55);

      --tile-w:96px;
      --tile-h:104px;
      --logo:44px;

      --heat-rgb:255,189,89;
      --heat-min:.06;
      --heat-max:.22;
      --heat-top-outline:.42;

      --good:#62e887;
      --bad:#ff6b6b;

      color-scheme: dark;
    }

    *{box-sizing:border-box}
    html,body{min-height:100%}
    body{
      margin:0;
      font-family: Roboto, system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      color:var(--ink);
      background:
        radial-gradient(900px 500px at 18% 12%, rgba(77,211,255,.15), transparent 60%),
        radial-gradient(700px 420px at 85% 18%, rgba(255,189,89,.12), transparent 60%),
        radial-gradient(900px 620px at 50% 110%, rgba(255,119,51,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      overflow-x:hidden;
      overflow-y:auto;
    }
    body::before, body::after{
      content:"";
      position:fixed;
      inset:auto auto 0 0;
      width:520px; height:520px;
      border-radius:50%;
      border:10px solid rgba(77,211,255,.14);
      transform: translate(-45%, -35%);
      filter: blur(.2px);
      pointer-events:none;
      z-index:0;
    }
    body::after{
      inset: -120px 0 auto auto;
      width:420px; height:420px;
      border:10px solid rgba(77,211,255,.10);
      transform: translate(38%, 0%);
    }

    a{color:inherit}
    button{font:inherit}
    select{color-scheme: dark;background: rgba(0,0,0,.28);color: var(--ink)}
    select option{ background:#0b1020; color:var(--ink); }

    :focus-visible{
      outline: 2px solid rgba(77,211,255,.65);
      outline-offset: 2px;
      border-radius: 12px;
    }

    header{
      position:sticky;
      top:0;
      z-index:50;
      background: var(--panel);
      border-bottom: 1px solid var(--line);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
    }
    .hdr-inner{
      max-width: 1440px;
      margin: 0 auto;
      padding: 12px 14px;
      display:flex;
      align-items:center;
      gap:12px;
    }
    h1{
      margin:0;
      font-family: Orbitron, sans-serif;
      font-size: 1.05rem;
      letter-spacing:.6px;
      color: var(--brand);
      text-shadow: 0 0 18px rgba(255,189,89,.20);
      white-space:nowrap;
    }
    .user-controls{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .shell{
      position:relative;
      z-index:1;
      max-width:1440px;
      margin: 16px auto;
      padding: 0 14px 18px;
    }

    .gerr{
      display:none;
      margin: 0 0 12px;
      background: rgba(255,77,77,.12);
      border: 1px solid rgba(255,77,77,.28);
      color: #ffb4b4;
      border-radius: 14px;
      padding: 10px 12px;
      white-space:pre-wrap;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .gerr.show{display:block}

    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(244,246,255,.86);
      font-weight:800;
      font-size:.82rem;
      white-space:nowrap;
      max-width: 46vw;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .btn{
      padding: 9px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: rgba(244,246,255,.88);
      cursor:pointer;
      font-weight:900;
      font-size:.82rem;
      transition:.2s ease;
      white-space:nowrap;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    .btn:hover{
      background: rgba(0,0,0,.28);
      box-shadow: 0 0 0 3px rgba(77,211,255,.10);
      border-color: rgba(77,211,255,.22);
      transform: translateY(-1px);
    }
    .btn.secondary{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.10);
      color: rgba(244,246,255,.88);
    }
    .btn.brand{
      background: linear-gradient(135deg, rgba(255,189,89,.18), rgba(255,119,51,.10));
      border-color: rgba(255,189,89,.20);
    }
    .btn.brand:hover{
      box-shadow: 0 0 0 3px rgba(255,189,89,.12);
      border-color: rgba(255,189,89,.28);
    }

    .input{
      background: rgba(0,0,0,.22);
      color: var(--ink);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 9px 12px;
      outline:none;
      min-height: 40px;
    }
    .input::placeholder{color: rgba(170,177,197,.75)}
    .input:focus{
      box-shadow: 0 0 0 3px rgba(77,211,255,.10);
      border-color: rgba(77,211,255,.22);
    }

    .section{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      padding: 14px;
      margin-bottom: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      overflow:hidden;
    }
    .section h2{
      margin:0 0 10px;
      font-family: Orbitron, sans-serif;
      letter-spacing:.4px;
      font-size: 1.02rem;
      color: rgba(244,246,255,.92);
    }
    .muted{color:var(--muted)}
    .grid2{display:grid;grid-template-columns:repeat(2,minmax(260px,1fr));gap:12px}

    .card{
      background: rgba(14, 18, 28, .55);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius-lg);
      padding: 12px;
      box-shadow: 0 14px 45px rgba(0,0,0,.30);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      overflow:hidden;
    }
    .card h3{
      margin:0 0 8px;
      color: var(--brand2);
      font-family: Orbitron, sans-serif;
      letter-spacing:.4px;
      font-size: .98rem;
    }

    .kpis{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0}
    .kpi{
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 7px 10px;
      font-size: .88rem;
      color: rgba(244,246,255,.88);
    }
    .kpi strong{font-weight:900;color:rgba(244,246,255,.96)}

    .bar{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom: 10px;
      flex-wrap:wrap;
    }
    .bar label{color:var(--muted);font-size:.9rem;font-weight:800}

    .team-grid{
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(var(--tile-w),1fr));
      gap:10px;
    }
    .team-tile{
      height:var(--tile-h);
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding: 8px 8px 10px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:6px;
      cursor:pointer;
      transition:transform .18s ease,border-color .18s ease, background .18s ease;
      overflow:hidden;
      -webkit-tap-highlight-color: transparent;
    }
    .team-tile:hover{
      transform: translateY(-2px);
      border-color: rgba(255,189,89,.22);
      background: rgba(255,255,255,.06);
    }
    .team-tile.active{
      outline: 2px solid rgba(255,119,51,.55);
      border-color: rgba(255,119,51,.35);
      background: linear-gradient(135deg, rgba(255,189,89,.10), rgba(77,211,255,.06));
    }
    .team-logo{
      width:var(--logo);
      height:var(--logo);
      object-fit:contain;
      filter:drop-shadow(0 0 10px rgba(0,0,0,.40));
    }
    .team-code{
      font-weight:1000;
      font-size:.78rem;
      line-height:1.1;
      letter-spacing:.35px;
      color: rgba(244,246,255,.92);
      text-align:center;
    }

    .table-wrap{
      width: 100%;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      border-radius: 16px;
      scroll-behavior: smooth;
      overscroll-behavior-x: contain;
      position: relative;
    }
    .table-wrap table{
      width: max-content;
      min-width: 100%;
      border-collapse: separate;
      border-spacing: 0 8px;
      font-size:.92rem;
    }
    thead th{
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      position: sticky;
      top: 0;
      text-align:left;
      border-radius: 12px;
      padding: 10px 10px;
      z-index:3;
      color: rgba(244,246,255,.90);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    th,td{padding:8px 10px;vertical-align:top}
    .right{text-align:right}

    tbody tr td{
      background: rgba(0,0,0,.16);
      border: 1px solid rgba(255,255,255,.08);
      transition:background-color .18s ease, box-shadow .18s ease;
      background-clip:padding-box;
    }
    tbody tr td:first-child{border-radius: 12px 0 0 12px}
    tbody tr td:last-child{border-radius: 0 12px 12px 0}
    td.heat-top{ box-shadow: inset 0 0 0 1px rgba(var(--heat-rgb), var(--heat-top-outline)); }

    details.accordion{
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      overflow:hidden;
      margin-bottom: 14px;
    }
    details.accordion > summary{
      list-style:none;
      cursor:pointer;
      padding: 12px 14px;
      color: var(--brand);
      font-weight: 1000;
      font-family: Orbitron, sans-serif;
      letter-spacing: .4px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
    }
    details.accordion > summary::-webkit-details-marker{display:none}
    details.accordion > .accordion-body{padding: 12px 14px}

    /* small helpers for the “players list” cell */
    .mini-details{margin:0}
    .mini-details > summary{
      cursor:pointer;
      color: rgba(244,246,255,.92);
      font-weight:900;
      list-style:none;
    }
    .mini-details > summary::-webkit-details-marker{display:none}
    .mini-details .mini{
      margin-top:8px;
      color: rgba(244,246,255,.86);
      font-size:.9rem;
      line-height:1.35;
    }
    .mini .pill{
      display:inline-block;
      margin:2px 6px 2px 0;
      padding:3px 8px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:999px;
      background: rgba(0,0,0,.18);
      color: rgba(244,246,255,.88);
      font-weight:800;
      font-size:.82rem;
    }

    #veil{
      position:fixed;
      inset:0;
      display:grid;
      place-items:center;
      background: rgba(0,0,0,.70);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      z-index:9999;
    }
    #veil .box{
      background: rgba(14, 18, 28, .92);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius-lg);
      padding: 14px 16px;
      color: rgba(244,246,255,.88);
      box-shadow: 0 26px 80px rgba(0,0,0,.55);
    }
    #veil.hide{display:none}

    @media (max-width: 980px){
      body::before, body::after{display:none;}
      .shell{padding: 0 10px 16px}
      .hdr-inner{padding: 10px 10px}
    }
    @media (max-width: 860px){
      .grid2{grid-template-columns:1fr}
      .user-controls{width:100%;justify-content:space-between}
      .chip{max-width: 90vw}
    }
    @media (prefers-reduced-motion: reduce){
      *{scroll-behavior:auto !important; transition:none !important; animation:none !important}
      .btn:hover, .team-tile:hover{transform:none}
    }
  </style>
</head>

<body>
<header>
  <div class="hdr-inner">
    <h1>FF Stats — Teams & Players</h1>
    <div class="user-controls">
      <a class="btn secondary" href="home.html">← Back to Dashboard</a>
      <span class="chip" id="scopeChip">Scope: —</span>
      <span class="chip" id="user-info">Checking login…</span>
      <button class="btn brand" id="logoutBtn">Logout</button>
    </div>
  </div>
</header>

<div id="veil"><div class="box">Loading data…</div></div>

<div class="shell">
  <div id="globalErr" class="gerr"></div>

  <div class="section">
    <h2>Diagnostics</h2>
    <div class="bar">
      <span class="chip" id="diagCount">ff_stats_raw rows: —</span>
      <span class="chip" id="diagSchema">Detected schema: —</span>
      <span class="chip" id="diagMap">match_api mapping: —</span>
      <span class="chip" id="diagChar">character.json mapping: —</span>
      <button class="btn secondary" id="reloadBtn">Reload</button>
    </div>
    <div class="muted" id="diagNote">
      Loadout source: <strong>player_stats_loadout</strong> (preferred). If missing/empty, it falls back to skill_ids_* + pet fields.
    </div>
  </div>

  <div class="section">
    <h2>Filters</h2>
    <div class="bar">
      <label>Tournament
        <select id="fTournament" class="input" style="min-width:280px">
          <option value="__all__">All</option>
        </select>
      </label>
      <label>Year
        <select id="fYear" class="input" style="min-width:140px">
          <option value="__all__">All</option>
        </select>
      </label>
      <label>Week
        <select id="fWeek" class="input" style="min-width:140px">
          <option value="__all__">All</option>
        </select>
      </label>
      <label>Day
        <select id="fDay" class="input" style="min-width:140px">
          <option value="__all__">All</option>
        </select>
      </label>
      <label>Match #
        <select id="fMatchNo" class="input" style="min-width:140px">
          <option value="__all__">All</option>
        </select>
      </label>
      <button class="btn secondary" id="resetFilters">Reset to Latest</button>
    </div>
    <div class="muted" id="filterHint">—</div>
  </div>

  <details class="accordion" id="accOverall">
    <summary>Overall — Team Summary</summary>
    <div class="accordion-body">
      <div class="bar">
        <label>Sort by
          <select id="overallSortKey" class="input">
            <option value="dmg_pm" selected>Damage / match</option>
            <option value="elims_pm">Elims / match</option>
            <option value="booyahs">Booyahs</option>
            <option value="matches">Matches</option>
            <option value="avg_place">Avg Placement</option>
            <option value="damage">Total Damage</option>
            <option value="elims">Total Elims</option>
            <option value="team">Team (A→Z)</option>
          </select>
        </label>
        <button class="btn secondary" id="overallSortDir" data-dir="desc">Desc</button>
      </div>
      <div class="card" style="margin:0">
        <div id="tblOverall">Loading…</div>
      </div>
    </div>
  </details>

  <div class="section">
    <h2>Team Selection</h2>
    <div class="bar">
      <input type="search" id="teamSearch" placeholder="Search team…" class="input" style="flex:1;max-width:420px">
      <span class="chip">Selected: <span id="selectedTeamChip">—</span></span>
    </div>
    <div id="teamGrid" class="team-grid">Loading teams…</div>
  </div>

  <div class="section" id="teamHeader">
    <h2 id="teamTitle">Team Overview</h2>
    <div class="grid2">
      <div class="card">
        <h3>Key KPIs</h3>
        <div id="teamKpis">Select a team.</div>
      </div>
      <div class="card">
        <h3>Skill/Pet Snapshot (Team)</h3>
        <div id="teamLoadoutSnap" class="muted">—</div>
      </div>
    </div>
  </div>

  <details class="accordion" id="accPlayers">
    <summary>Players — Stats + Loadout (Active/Passive/Pet)</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <div id="tblPlayers">Select a team…</div>
      </div>

      <div class="grid2" style="margin-top:12px">
        <div class="card">
          <h3>Team Active Skill Usage</h3>
          <div class="bar">
            <label>Top
              <select id="topActive" class="input">
                <option>10</option><option>20</option><option>50</option><option>100</option>
              </select>
            </label>
          </div>
          <div id="tblActive">—</div>
        </div>

        <div class="card">
          <h3>Team Passive Skill Usage</h3>
          <div class="bar">
            <label>Top
              <select id="topPassive" class="input">
                <option>10</option><option>20</option><option>50</option><option>100</option>
              </select>
            </label>
          </div>
          <div id="tblPassive">—</div>
        </div>
      </div>

      <div class="card" style="margin-top:12px">
        <h3>Team Pet Usage</h3>
        <div class="bar">
          <label>Top
            <select id="topPet" class="input">
              <option>10</option><option>20</option><option>50</option><option>100</option>
            </select>
          </label>
        </div>
        <div id="tblPet">—</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="accAllTeamsSkills">
    <summary>All Teams — Skill Summary (Top 3 Active / Top 6 Passive / Players + Loadout)</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <div class="muted" style="margin-bottom:8px">
          Uses current scope filters. Active/Passive comes from <strong>character.json api_id</strong> mapping to skill IDs (with “last digit” variations when needed).
        </div>
        <div id="tblAllTeamsSkills">—</div>
      </div>
    </div>
  </details>

</div>

<script>
/* ============ Supabase init ============ */
const client = supabase.createClient(
  'https://gkugecflfddkpitlrmws.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdrdWdlY2ZsZmRka3BpdGxybXdzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwODMwNzQsImV4cCI6MjA2MTY1OTA3NH0.OgQOx9k71DDdK1yOa7VNKGSgoFD9kNGo8j-bR91zGKE'
);

const TABLE = 'ff_stats_raw';
const MAP_TABLE = 'match_api';

/* ✅ Set this to your hosted character.json URL */
const CHARACTER_JSON_URL = 'character.json';

/* ============ Small utils ============ */
const el = id => document.getElementById(id);
const n = x => Number(x ?? 0) || 0;
const norm = v => (v==null ? '' : String(v).trim());
const fmtPct = x => isFinite(x) ? (x*100).toFixed(1)+'%' : '—';

function gerr(msg){
  const box=el('globalErr');
  box.textContent = msg;
  box.classList.add('show');
  console.error('[FF_STATS]', msg);
}
function clearErr(){ el('globalErr').classList.remove('show'); el('globalErr').textContent=''; }

function pickKey(keys, patterns){
  for(const rx of patterns){
    const k = keys.find(k => rx.test(k));
    if(k) return k;
  }
  return null;
}

function groupBy(arr, fn){
  const m=new Map();
  for(const r of arr){
    const k=fn(r);
    if(!m.has(k)) m.set(k, []);
    m.get(k).push(r);
  }
  return m;
}

function escapeHtml(s){
  return String(s ?? '')
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'","&#039;");
}

function renderSimpleTable(list, cols){
  if(!list.length) return '<div class="muted">No rows.</div>';

  const head = `<thead><tr>${cols.map(c =>
    `<th data-key="${c.key}" class="${c.right?'right':''}">${c.label}</th>`
  ).join('')}</tr></thead>`;

  const body = `<tbody>${list.map((r,i)=>`<tr>${
    cols.map(c=>{
      let v;
      if (typeof c.html==='function'){ v=c.html(r,i); }
      else{
        v=r[c.key];
        if (c.format==='pct') v=isFinite(v)?(v*100).toFixed(1)+'%':'—';
        else if (c.format==='1d') v=isFinite(v)?Number(v).toFixed(1):'—';
        else if (c.format==='0d') v=isFinite(v)?Number(v).toFixed(0):'—';
      }
      return `<td data-key="${c.key}" class="${c.right?'right':''}">${(v==null||v==='')?'—':v}</td>`;
    }).join('')
  }</tr>`).join('')}</tbody>`;

  return `<div class="table-wrap"><table>${head}${body}</table></div>`;
}

function applyColumnHeatmap(containerId, keys){
  const wrap=el(containerId);
  const table=wrap?.querySelector('table');
  if(!table) return;

  table.querySelectorAll('td[data-key]').forEach(td=>{
    td.style.backgroundColor='';
    td.classList.remove('heat-top');
  });

  const styles=getComputedStyle(document.documentElement);
  const rgb=styles.getPropertyValue('--heat-rgb')||'255,189,89';
  const minA=parseFloat(styles.getPropertyValue('--heat-min'))||.06;
  const maxA=parseFloat(styles.getPropertyValue('--heat-max'))||.22;
  const BANDS=5;

  for(const key of keys){
    const cells=[...table.querySelectorAll(`td[data-key="${key}"]`)];
    if(!cells.length) continue;

    const entries=cells.map((td,i)=>{
      const raw=(td.textContent||'').trim().replace('%','').replace(/,/g,'');
      const v=parseFloat(raw);
      return {td,i,v:isFinite(v)?v:null};
    }).filter(e=>e.v!=null);

    if(!entries.length) continue;

    const asc=entries.slice().sort((a,b)=>a.v-b.v);
    const N=asc.length;
    const bandByIndex=new Map();
    asc.forEach((e,rank)=>{
      const p=(N<=1)?1:(rank/(N-1));
      const band=Math.min(BANDS-1, Math.floor(p*BANDS));
      bandByIndex.set(e.i, band);
    });

    const topVal=asc[N-1].v;

    cells.forEach((td,i)=>{
      const band=bandByIndex.get(i);
      if(band==null) return;
      const alpha=minA + (band/(BANDS-1))*(maxA-minA);
      td.style.backgroundColor=`rgba(${rgb}, ${alpha.toFixed(3)})`;
      const v=parseFloat((td.textContent||'').trim().replace(/,/g,''));
      if(isFinite(v) && v===topVal) td.classList.add('heat-top');
    });
  }
}

/* ============ Session chip ============ */
(async () => {
  try{
    const { data: { session } } = await client.auth.getSession();
    el('user-info').textContent = session?.user?.email ? `Logged in: ${session.user.email}` : 'Anon access';
  }catch{
    el('user-info').textContent = 'Anon access';
  }
})();
el('logoutBtn').onclick = async () => { await client.auth.signOut(); location.reload(); };

/* ============ State ============ */
let RAW = [];
let FILTERED = [];
let CURRENT_TEAM = null;

let KEYS = {
  team: null,
  player: null,
  tournament: null,
  year: null,
  week: null,
  day: null,
  matchNo: null,
  matchId: null,
  kills: null,
  damage: null,
  rank: null,
  booyah: null,
  petName: null,
  petId: null,
  loadout: null,      // ✅ NEW (player_stats_loadout)
  skillIds: []
};

let ID_TO_NAME = new Map();          // all types
let SKILL_ID_TO_NAME = new Map();    // ONLY type=2 (skills)
let MAP_READY = false;

/* ===== character.json skill id -> kind (active/passive) ===== */
let CHAR_SKILLID_TO_KIND = new Map();   // "api_id" -> active|passive
let CHAR_READY = false;

/* ============ Schema detection ============ */
function detectSchema(sample){
  const keys = Object.keys(sample||{});

  KEYS.team = pickKey(keys, [/^team_name$/i, /team.*(tag|name)/i, /^tag$/i, /^team$/i]);
  KEYS.player = pickKey(keys, [/player_stats_nickname/i, /nickname/i, /\bign\b/i, /player.*name/i, /^name$/i]);

  KEYS.tournament = pickKey(keys, [/^tournament$/i, /\btournament\b/i]);
  KEYS.year = pickKey(keys, [/^year$/i, /\byear\b/i]);
  KEYS.week = pickKey(keys, [/^week$/i, /\bweek\b/i]);
  KEYS.day = pickKey(keys, [/^day$/i, /\bday\b/i]);
  KEYS.matchNo = pickKey(keys, [/matchnumber/i, /match_number/i, /matchno/i, /\bmatch\b.*\bno\b/i]);
  KEYS.matchId = pickKey(keys, [/match_id/i, /game_id/i, /battle_id/i, /round_id/i]);

  KEYS.kills = pickKey(keys, [/player_stats_kills/i, /\bkills\b/i, /\belims?\b/i, /\belimination\b/i]);
  KEYS.damage = pickKey(keys, [/player_stats_damage/i, /\bdamage\b/i]);

  KEYS.rank = pickKey(keys, [/\brank\b/i, /placement/i, /\bplace\b/i, /team_rank/i, /final_rank/i]);
  KEYS.booyah = pickKey(keys, [/booyah/i, /is_booyah/i, /winner/i, /is_winner/i]);

  KEYS.petName = pickKey(keys, [/pet_skill_name/i, /pet.*name/i]);
  KEYS.petId = pickKey(keys, [/pet_skill_id/i, /pet.*id/i]);

  // ✅ NEW: prefer this
  KEYS.loadout = pickKey(keys, [/player_stats_loadout/i, /\bloadout\b/i]);

  const skillKeys = keys
    .filter(k => /skill_ids_/i.test(k))
    .sort((a,b)=>{
      const ai = Number((a.match(/(\d+)$/)||[])[1]||0);
      const bi = Number((b.match(/(\d+)$/)||[])[1]||0);
      return ai-bi;
    });
  KEYS.skillIds = skillKeys.slice(0,4);

  const summary = [
    KEYS.team ? `team=${KEYS.team}` : 'team=—',
    KEYS.player ? `player=${KEYS.player}` : 'player=—',
    KEYS.tournament ? `tournament=${KEYS.tournament}` : 'tournament=—',
    KEYS.year ? `year=${KEYS.year}` : 'year=—',
    KEYS.week ? `week=${KEYS.week}` : 'week=—',
    KEYS.day ? `day=${KEYS.day}` : 'day=—',
    KEYS.matchNo ? `matchNo=${KEYS.matchNo}` : 'matchNo=—',
    KEYS.matchId ? `matchId=${KEYS.matchId}` : 'matchId=—',
    KEYS.loadout ? `loadout=${KEYS.loadout}` : 'loadout=—',
    KEYS.skillIds.length ? `skills=${KEYS.skillIds.join(',')}` : 'skills=—',
    KEYS.petName ? `pet=${KEYS.petName}` : (KEYS.petId ? `petId=${KEYS.petId}` : 'pet=—'),
    KEYS.kills ? `kills=${KEYS.kills}` : 'kills=—',
    KEYS.damage ? `dmg=${KEYS.damage}` : 'dmg=—',
    KEYS.rank ? `rank=${KEYS.rank}` : 'rank=—',
    KEYS.booyah ? `booyah=${KEYS.booyah}` : 'booyah=—',
  ].join(' • ');

  el('diagSchema').textContent = 'Detected schema: ' + summary;
}

/* ============ match_api mapping (skills only type=2) ============ */
function mapNameFromId(id, fallback=''){
  const key = String(id ?? '').trim();
  if(!key) return fallback || '—';
  if(ID_TO_NAME.has(key)) return ID_TO_NAME.get(key);
  return fallback || `ID ${key}`;
}
function mapSkillFromId(id, fallback=''){
  const key = String(id ?? '').trim();
  if(!key) return fallback || '—';
  if(SKILL_ID_TO_NAME.has(key)) return SKILL_ID_TO_NAME.get(key);
  return fallback || `ID ${key}`;
}

async function loadMatchApi(){
  MAP_READY = false;
  ID_TO_NAME.clear();
  SKILL_ID_TO_NAME.clear();

  try{
    const { data, error } = await client
      .from(MAP_TABLE)
      .select('*')
      .limit(20000);

    if(error) throw error;

    const rows = data || [];
    if(!rows.length){
      el('diagMap').textContent = 'match_api mapping: 0 rows';
      MAP_READY = false;
      return;
    }

    const allKeys = [...new Set(rows.flatMap(r=>Object.keys(r||{})))];
    const idKey = pickKey(allKeys, [/^id$/i, /_id$/i, /\bid\b/i]) || 'id';
    const nameKeyK = pickKey(allKeys, [/^name$/i, /title/i, /label/i]) || 'name';
    const typeKey = pickKey(allKeys, [/^type$/i, /api_type/i, /kind/i]) || 'type';

    for(const r of rows){
      const id = String(r?.[idKey] ?? '').trim();
      const nm = String(r?.[nameKeyK] ?? '').trim();
      if(!id || !nm) continue;

      ID_TO_NAME.set(id, nm);

      const t = Number(r?.[typeKey]);
      if(t === 2) SKILL_ID_TO_NAME.set(id, nm);
    }

    el('diagMap').textContent =
      `match_api mapping: all=${ID_TO_NAME.size} • skills(type=2)=${SKILL_ID_TO_NAME.size}`;

    MAP_READY = SKILL_ID_TO_NAME.size > 0;
  }catch(e){
    el('diagMap').textContent = 'match_api mapping: unavailable (RLS?)';
    console.warn('match_api load failed:', e?.message || e);
    MAP_READY = false;
  }
}

/* ============ character.json load (api_id -> active/passive) ============ */
function normKind(v){
  const s = String(v ?? '').trim().toLowerCase();
  if(!s) return '';
  if(s.includes('active')) return 'active';
  if(s.includes('passive')) return 'passive';
  return '';
}

function normId(v){
  if(v==null) return '';
  const s = String(v).trim();
  if(!s) return '';
  // normalize "123.0" -> "123"
  if(/^\d+(\.0+)?$/.test(s)) return String(parseInt(s,10));
  return s;
}

/* If exact api_id doesn't match, try varying the LAST digit: 1234 -> 1230..1239 */
function idWithLastDigit(id, d){
  const s = String(id ?? '').trim();
  if(!/^\d+$/.test(s) || s.length < 1) return '';
  return s.slice(0, -1) + String(d);
}
function resolveKindById(id){
  const k = normId(id);
  if(!k) return '';
  const direct = CHAR_SKILLID_TO_KIND.get(k);
  if(direct) return direct;

  // last digit variations
  if(/^\d+$/.test(k) && k.length >= 2){
    const last = Number(k[k.length-1]);
    for(let d=0; d<=9; d++){
      if(d === last) continue;
      const alt = idWithLastDigit(k, d);
      const got = CHAR_SKILLID_TO_KIND.get(alt);
      if(got) return got;
    }
  }
  return '';
}

async function loadCharacterJson(){
  CHAR_READY = false;
  CHAR_SKILLID_TO_KIND.clear();

  try{
    const res = await fetch(`${CHARACTER_JSON_URL}?v=${Date.now()}`, { cache:'no-store' });
    if(!res.ok) throw new Error(`character.json fetch failed: ${res.status} ${res.statusText}`);
    const data = await res.json();

    const arr = Array.isArray(data) ? data :
      Array.isArray(data?.characters) ? data.characters :
      Array.isArray(data?.data) ? data.data :
      [];

    if(!arr.length) throw new Error('character.json parsed but no array found');

    let added = 0;
    for(const ch of arr){
      const kind = normKind(ch?.skill_type);
      if(!kind) continue;

      // ✅ per your request: use api_id
      const apiId = normId(ch?.api_id);
      if(!apiId) continue;

      if(!CHAR_SKILLID_TO_KIND.has(apiId)){
        CHAR_SKILLID_TO_KIND.set(apiId, kind);
        added++;
      }
    }

    CHAR_READY = added > 0;
    el('diagChar').textContent = `character.json mapping: api_id skills=${added}`;
  }catch(e){
    CHAR_READY = false;
    el('diagChar').textContent = 'character.json mapping: unavailable';
    console.warn('[FF_STATS] character.json load failed:', e?.message || e);
  }
}

/* ============ Fetching ============ */
async function headCount(){
  try{
    const res = await client.from(TABLE).select('*', { count: 'exact', head: true });
    if(res.error) throw res.error;
    el('diagCount').textContent = `ff_stats_raw rows: ${res.count ?? '—'}`;
  }catch(e){
    el('diagCount').textContent = `ff_stats_raw rows: (count blocked by RLS)`;
    console.warn('Count failed (RLS likely):', e?.message || e);
  }
}

async function fetchAllRows(){
  const orderCandidates = ['id', 'created_at', 'updated_at'];
  const CHUNK = 1000;

  for(const orderCol of orderCandidates){
    let out = [];
    let from = 0;
    let ok = true;

    for(;;){
      const q = client.from(TABLE).select('*').order(orderCol, { ascending: true }).range(from, from + CHUNK - 1);
      const { data, error } = await q;

      if(error){
        ok = false;
        console.warn(`Fetch failed ordering by ${orderCol}:`, error.message || error);
        break;
      }

      const rows = data || [];
      if(!rows.length) break;
      out.push(...rows);
      from += rows.length;
      if(rows.length < CHUNK) break;
      if(from > 200000) break;
    }

    if(ok) return out;
  }

  const { data, error } = await client.from(TABLE).select('*').limit(5000);
  if(error) throw error;
  return data || [];
}

/* ============ Filters ============ */
function getVal(r, key){ return key ? r?.[key] : ''; }

function toBool(v){
  const s = String(v ?? '').trim().toLowerCase();
  if(v === true) return true;
  if(v === false) return false;
  if(s === '1' || s === 'true' || s === 'yes' || s === 'y') return true;
  return false;
}

function getRank(r){
  if(!KEYS.rank) return null;
  const v = r?.[KEYS.rank];
  const num = Number(v);
  if(isFinite(num) && num > 0) return num;
  const m = String(v ?? '').match(/(\d+)/);
  if(m){
    const k = Number(m[1]);
    if(isFinite(k) && k > 0) return k;
  }
  return null;
}

function getBooyah(r, rankValue=null){
  if(KEYS.booyah){
    if(toBool(r?.[KEYS.booyah])) return true;
  }
  if(rankValue == null) rankValue = getRank(r);
  return rankValue === 1;
}

function matchKeyForRow(r){
  const t = norm(getVal(r, KEYS.tournament));
  const y = norm(getVal(r, KEYS.year));
  const w = norm(getVal(r, KEYS.week));
  const d = norm(getVal(r, KEYS.day));
  const m = norm(getVal(r, KEYS.matchNo));
  const mid = norm(getVal(r, KEYS.matchId));
  if(mid) return `${t}|${mid}`;
  return `${t}|Y${y}|W${w}|D${d}|M${m}`;
}

function currentFilter(){
  return {
    t: el('fTournament').value,
    y: el('fYear').value,
    w: el('fWeek').value,
    d: el('fDay').value,
    m: el('fMatchNo').value
  };
}

function countMatchesIn(rows){
  const s = new Set(rows.map(matchKeyForRow));
  return s.size;
}

/* ---- dropdown helpers (cascading) ---- */
function uniqSorted(values){
  const arr = [...new Set(values.map(v=>norm(v)).filter(Boolean))];
  arr.sort((a,b)=>{
    const na = Number(String(a).replace(/[^\d.-]/g,''));
    const nb = Number(String(b).replace(/[^\d.-]/g,''));
    const ia = Number.isFinite(na) ? na : null;
    const ib = Number.isFinite(nb) ? nb : null;
    if(ia!=null && ib!=null) return ib - ia;
    return String(b).localeCompare(String(a));
  });
  return arr;
}

function setSelectOptions(selectEl, values, keepCurrent=true){
  const cur = keepCurrent ? selectEl.value : '__all__';
  const html = [`<option value="__all__">All</option>`]
    .concat(values.map(v=>{
      const safe = String(v).replaceAll('"','&quot;');
      return `<option value="${safe}">${v}</option>`;
    })).join('');
  selectEl.innerHTML = html;

  if(cur && [...selectEl.options].some(o=>o.value===cur)) selectEl.value = cur;
  else selectEl.value = '__all__';
}

function rowsForCascades(){
  const t = el('fTournament').value;
  const y = el('fYear').value;
  const w = el('fWeek').value;
  const d = el('fDay').value;

  const r0 = RAW;
  const rT = (t==='__all__' || !KEYS.tournament) ? r0 : r0.filter(r=>norm(getVal(r,KEYS.tournament))===t);
  const rY = (y==='__all__' || !KEYS.year) ? rT : rT.filter(r=>norm(getVal(r,KEYS.year))===y);
  const rW = (w==='__all__' || !KEYS.week) ? rY : rY.filter(r=>norm(getVal(r,KEYS.week))===w);
  const rD = (d==='__all__' || !KEYS.day) ? rY : rW.filter(r=>norm(getVal(r,KEYS.day))===d);

  return { r0, rT, rY, rW, rD };
}

function refreshCascadeOptions(changed){
  const { rT, rY, rW, rD } = rowsForCascades();

  if(changed === 'tournament'){
    if(KEYS.year) setSelectOptions(el('fYear'), uniqSorted(rT.map(r=>getVal(r,KEYS.year))), false);
    if(KEYS.week) setSelectOptions(el('fWeek'), uniqSorted(rY.map(r=>getVal(r,KEYS.week))), false);
    if(KEYS.day)  setSelectOptions(el('fDay'),  uniqSorted(rW.map(r=>getVal(r,KEYS.day))), false);
    if(KEYS.matchNo) setSelectOptions(el('fMatchNo'), uniqSorted(rD.map(r=>getVal(r,KEYS.matchNo))), false);
    return;
  }
  if(changed === 'year'){
    if(KEYS.week) setSelectOptions(el('fWeek'), uniqSorted(rY.map(r=>getVal(r,KEYS.week))), false);
    if(KEYS.day)  setSelectOptions(el('fDay'),  uniqSorted(rW.map(r=>getVal(r,KEYS.day))), false);
    if(KEYS.matchNo) setSelectOptions(el('fMatchNo'), uniqSorted(rD.map(r=>getVal(r,KEYS.matchNo))), false);
    return;
  }
  if(changed === 'week'){
    if(KEYS.day)  setSelectOptions(el('fDay'),  uniqSorted(rW.map(r=>getVal(r,KEYS.day))), false);
    if(KEYS.matchNo) setSelectOptions(el('fMatchNo'), uniqSorted(rD.map(r=>getVal(r,KEYS.matchNo))), false);
    return;
  }
  if(changed === 'day'){
    if(KEYS.matchNo) setSelectOptions(el('fMatchNo'), uniqSorted(rD.map(r=>getVal(r,KEYS.matchNo))), false);
    return;
  }
}

/* Latest scope chooser (for Reset) */
function latestKeyFrom(rows){
  let best = null;
  for(const r of rows){
    const y = n(getVal(r, KEYS.year));
    const w = n(getVal(r, KEYS.week));
    const d = n(getVal(r, KEYS.day));
    const m = n(getVal(r, KEYS.matchNo));
    const key = (y*1e8) + (w*1e6) + (d*1e4) + (m||0);
    if(!best || key > best.key){
      best = {
        key,
        y: norm(getVal(r, KEYS.year)),
        w: norm(getVal(r, KEYS.week)),
        d: norm(getVal(r, KEYS.day)),
        m: norm(getVal(r, KEYS.matchNo))
      };
    }
  }
  return best;
}

function applyFilters(){
  const f = currentFilter();

  FILTERED = RAW.filter(r=>{
    const t = norm(getVal(r, KEYS.tournament));
    const y = norm(getVal(r, KEYS.year));
    const w = norm(getVal(r, KEYS.week));
    const d = norm(getVal(r, KEYS.day));
    const m = norm(getVal(r, KEYS.matchNo));

    if(f.t !== '__all__' && t !== f.t) return false;
    if(f.y !== '__all__' && y !== f.y) return false;
    if(f.w !== '__all__' && w !== f.w) return false;
    if(f.d !== '__all__' && d !== f.d) return false;
    if(f.m !== '__all__' && m !== f.m) return false;
    return true;
  });

  const scopeText = [
    el('fTournament').value !== '__all__' ? el('fTournament').value : 'All tournaments',
    el('fYear').value !== '__all__' ? `Y${el('fYear').value}` : 'All years',
    el('fWeek').value !== '__all__' ? `W${el('fWeek').value}` : 'All weeks',
    el('fDay').value !== '__all__' ? `D${el('fDay').value}` : 'All days',
    el('fMatchNo').value !== '__all__' ? `M${el('fMatchNo').value}` : 'All matches',
  ].join(' • ');

  el('scopeChip').textContent = 'Scope: ' + scopeText;
  el('filterHint').textContent = `Rows: ${FILTERED.length} • Matches: ${countMatchesIn(FILTERED)}`;

  renderOverall();
  renderTeamGrid(el('teamSearch').value || '');
  renderAllTeamsSkillSummary();

  if(CURRENT_TEAM){
    const teamsInScope = new Set(FILTERED.map(r => norm(getVal(r, KEYS.team)).toUpperCase()).filter(Boolean));
    if(!teamsInScope.has(CURRENT_TEAM)){
      CURRENT_TEAM = null;
      el('selectedTeamChip').textContent = '—';
      el('teamTitle').textContent = 'Team Overview';
      el('teamKpis').innerHTML = 'Select a team.';
      el('teamLoadoutSnap').innerHTML = '<span class="muted">—</span>';
      el('tblPlayers').innerHTML = '<div class="muted">Select a team…</div>';
      el('tblActive').innerHTML = '—';
      el('tblPassive').innerHTML = '—';
      el('tblPet').innerHTML = '—';
      highlightActiveTile();
      return;
    }
    selectTeam(CURRENT_TEAM, true);
  }else{
    const first = [...new Set(FILTERED.map(r => norm(getVal(r, KEYS.team)).toUpperCase()).filter(Boolean))][0];
    if(first) selectTeam(first, true);
  }
}

function populateTournamentDropdown(){
  const tset = new Map();
  for(const r of RAW){
    const t = norm(getVal(r, KEYS.tournament));
    if(!t) continue;

    const y = n(getVal(r, KEYS.year));
    const w = n(getVal(r, KEYS.week));
    const d = n(getVal(r, KEYS.day));
    const m = n(getVal(r, KEYS.matchNo));
    const key = (y*1e8) + (w*1e6) + (d*1e4) + (m||0);

    const k = t.toLowerCase();
    if(!tset.has(k)) tset.set(k, { name: t, maxKey: key });
    else tset.get(k).maxKey = Math.max(tset.get(k).maxKey, key);
  }
  const tourn = [...tset.values()].sort((a,b)=> b.maxKey - a.maxKey || a.name.localeCompare(b.name));

  el('fTournament').innerHTML =
    `<option value="__all__">All</option>` +
    tourn.map(o=>{
      const safe = String(o.name).replaceAll('"','&quot;');
      return `<option value="${safe}">${o.name}</option>`;
    }).join('');

  if(tourn.length) el('fTournament').value = tourn[0].name;
}

function resetToLatest(){
  const t = el('fTournament').value;
  const rT = (t==='__all__' || !KEYS.tournament) ? RAW : RAW.filter(r=>norm(getVal(r,KEYS.tournament))===t);

  if(KEYS.year) setSelectOptions(el('fYear'), uniqSorted(rT.map(r=>getVal(r,KEYS.year))), false);
  const latest = latestKeyFrom(rT);

  if(latest?.y && [...el('fYear').options].some(o=>o.value===latest.y)) el('fYear').value = latest.y;
  else el('fYear').value = '__all__';

  refreshCascadeOptions('year');

  if(latest?.w && [...el('fWeek').options].some(o=>o.value===latest.w)) el('fWeek').value = latest.w;
  refreshCascadeOptions('week');

  if(latest?.d && [...el('fDay').options].some(o=>o.value===latest.d)) el('fDay').value = latest.d;
  refreshCascadeOptions('day');

  el('fMatchNo').value = '__all__';
  applyFilters();
}

/* ============ Aggregations ============ */
function teamMatchAgg(rows){
  const m = new Map();

  for(const r of rows){
    const team = norm(getVal(r, KEYS.team)).toUpperCase();
    if(!team) continue;

    const mk = matchKeyForRow(r);
    const key = team + '||' + mk;

    if(!m.has(key)){
      m.set(key, { team, mk, placement: null, booyah: 0, elims: 0, damage: 0 });
    }
    const o = m.get(key);

    const rk = getRank(r);
    if(rk != null){
      o.placement = (o.placement==null) ? rk : Math.min(o.placement, rk);
    }

    const b = getBooyah(r, rk);
    if(b) o.booyah = 1;

    if(KEYS.kills) o.elims += n(getVal(r, KEYS.kills));
    if(KEYS.damage) o.damage += n(getVal(r, KEYS.damage));
  }

  for(const o of m.values()){
    if(!o.booyah && o.placement === 1) o.booyah = 1;
  }

  return [...m.values()];
}

function listTopCounts(map, topN){
  return [...map.entries()]
    .sort((a,b)=> b[1]-a[1] || String(a[0]).localeCompare(String(b[0])))
    .slice(0, topN)
    .map(([name, cnt]) => ({ name, picks: cnt }));
}

/* ===== Preferred loadout parsing (player_stats_loadout) ===== */
function parseLoadoutRaw(v){
  if(v == null) return null;
  if(typeof v === 'object') return v;
  const s = String(v).trim();
  if(!s) return null;
  try{ return JSON.parse(s); }catch{ return null; }
}

function pickFirst(obj, keys){
  for(const k of keys){
    if(obj && obj[k] != null && String(obj[k]).trim() !== '') return obj[k];
  }
  return null;
}

function normalizeIdList(x){
  if(x == null) return [];
  if(Array.isArray(x)) return x.map(normId).filter(Boolean);
  if(typeof x === 'object'){
    // sometimes passives are in {1:123,2:456}
    return Object.values(x).map(normId).filter(Boolean);
  }
  const s = String(x).trim();
  if(!s) return [];
  // could be "123,456,789"
  if(s.includes(',')) return s.split(',').map(t=>normId(t)).filter(Boolean);
  return [normId(s)].filter(Boolean);
}

/* Extract: active skill id, passive skill ids, pet (id/name) */
function getLoadoutFromRow(r){
  if(!KEYS.loadout) return null;
  const raw = parseLoadoutRaw(r?.[KEYS.loadout]);
  if(!raw) return null;

  // active id candidates
  const active = normId(pickFirst(raw, [
    'active_skill_id','activeSkillId','active_skill','activeSkill','skill_active_id','skillActiveId','active'
  ]));

  // passive candidates
  let passives = [];
  const pBlock = pickFirst(raw, [
    'passive_skill_ids','passiveSkillIds','passive_skills','passives','passive'
  ]);
  passives = passives.concat(normalizeIdList(pBlock));

  // also check passive1..passive6 etc
  for(const k of Object.keys(raw)){
    if(/^passive\d+$/i.test(k) || /^passive_skill_id_\d+$/i.test(k) || /^skill_passive_\d+$/i.test(k)){
      passives.push(normId(raw[k]));
    }
  }

  // pet
  const petId = normId(pickFirst(raw, [
    'pet_skill_id','petSkillId','pet_id','petId','pet'
  ]));

  const petName = String(pickFirst(raw, [
    'pet_skill_name','petName','pet_name'
  ]) ?? '').trim();

  // de-dupe passives
  const seen = new Set();
  const uniqPass = [];
  for(const id of passives){
    if(!id || seen.has(id)) continue;
    seen.add(id);
    uniqPass.push(id);
  }

  return {
    active: active || '',
    passives: uniqPass,
    petId: petId || '',
    petName: petName || ''
  };
}

/* Fallback from skill_ids_* if loadout missing */
function skillIdFromRow(r, idx){
  const k = KEYS.skillIds[idx];
  if(!k) return '';
  const v = r?.[k];
  if(v == null || String(v).trim()==='') return '';
  const s = String(v).trim();
  const m = s.match(/^\d+(\.0+)?$/);
  if(m) return String(parseInt(s,10));
  return s;
}

/* ===== Active/Passive classification: character.json api_id ===== */
function kindOfSkillId(id){
  if(!CHAR_READY) return '';
  return resolveKindById(id) || '';
}

/* Determine active + passives for a row.
   - Prefer player_stats_loadout (already separated)
   - Else use ids list and classify via CHAR mapping
*/
function classifySkillsFromRow(r){
  const lo = getLoadoutFromRow(r);
  if(lo){
    // trust loadout's active/passives; but if active empty, pick first non-passive
    let active = lo.active || '';
    const passives = lo.passives || [];

    if(!active){
      // choose from passives? no; choose from fallback ids if available
      const ids = (KEYS.skillIds||[]).map((_,i)=>skillIdFromRow(r,i)).filter(Boolean);
      const pick = ids.find(x => kindOfSkillId(x) !== 'passive') || ids[0] || '';
      active = pick;
    }

    return { active, passives };
  }

  // fallback: use skill_ids_*
  const ids = (KEYS.skillIds || []).map((_, idx)=>skillIdFromRow(r, idx)).filter(Boolean);

  // de-dupe preserve order
  const seen = new Set();
  const uniq = [];
  for(const id of ids){
    if(seen.has(id)) continue;
    seen.add(id);
    uniq.push(id);
  }

  if(!CHAR_READY){
    const active = uniq[0] || '';
    return { active, passives: uniq.filter(x=>x!==active) };
  }

  const actives = [];
  const passives = [];
  const unknown = [];

  for(const id of uniq){
    const k = kindOfSkillId(id);
    if(k === 'active') actives.push(id);
    else if(k === 'passive') passives.push(id);
    else unknown.push(id);
  }

  let active = actives[0] || '';
  if(!active){
    const safeUnknown = unknown.find(x => kindOfSkillId(x) !== 'passive');
    active = safeUnknown || '';
  }
  if(active && kindOfSkillId(active) === 'passive') active = '';

  const passOut = uniq.filter(x => x !== active);
  return { active, passives: passOut };
}

function getActiveSkillId(r){ return classifySkillsFromRow(r).active; }
function getPassiveSkillIds(r){ return classifySkillsFromRow(r).passives; }

function getPetLabel(r){
  const lo = getLoadoutFromRow(r);
  if(lo){
    if(lo.petName) return lo.petName;
    if(lo.petId) return mapNameFromId(lo.petId, `ID ${lo.petId}`);
    return '';
  }

  if(KEYS.petName){
    const nm = norm(getVal(r, KEYS.petName));
    if(nm) return nm;
  }
  if(KEYS.petId){
    const pid = norm(getVal(r, KEYS.petId));
    if(pid) return mapNameFromId(pid, `ID ${pid}`);
  }
  return '';
}

/* Build a consistent “loadout label” for display */
function loadoutLabelFromRow(r){
  const a = getActiveSkillId(r);
  const ps = getPassiveSkillIds(r);
  const pet = getPetLabel(r);

  const aName = a ? mapSkillFromId(a, `ID ${a}`) : '—';
  const pNames = (ps||[]).filter(Boolean).map(x => mapSkillFromId(x, `ID ${x}`));
  const petName = pet || '—';

  return {
    activeId: a || '',
    passiveIds: (ps||[]).filter(Boolean),
    petName,
    text:
      `<span class="pill">A: ${escapeHtml(aName)}</span>` +
      (pNames.length ? pNames.map(p=>`<span class="pill">P: ${escapeHtml(p)}</span>`).join('') : `<span class="pill">P: —</span>`) +
      `<span class="pill">Pet: ${escapeHtml(petName)}</span>`
  };
}

function loadoutSignature(r){
  const a = getActiveSkillId(r) || '';
  const ps = (getPassiveSkillIds(r) || []).filter(Boolean).slice().sort((x,y)=>String(x).localeCompare(String(y)));
  const pet = getPetLabel(r) || '';
  return `${a}|${ps.join(',')}|${pet}`;
}

/* ============ Rendering ============ */
function sortRows(rows, key, dir, isText=false){
  const d = dir==='asc' ? 1 : -1;
  if(isText) rows.sort((a,b)=> d * String(a[key]||'').localeCompare(String(b[key]||'')));
  else rows.sort((a,b)=> d * ((a[key]??0) - (b[key]??0)));
  return rows;
}

function renderOverall(){
  const tm = teamMatchAgg(FILTERED);
  const g = groupBy(tm, r=>r.team);

  const rows = [];
  for(const [team, list] of g.entries()){
    const matches = list.length;
    const booyahs = list.reduce((a,b)=>a + (b.booyah||0), 0);
    const elims = list.reduce((a,b)=>a + (b.elims||0), 0);
    const damage = list.reduce((a,b)=>a + (b.damage||0), 0);

    const placementVals = list.map(x=>x.placement).filter(v=>v!=null && isFinite(v));
    const avg_place = placementVals.length ? (placementVals.reduce((a,b)=>a+b,0) / placementVals.length) : null;

    rows.push({
      team,
      matches,
      booyahs,
      elims,
      damage,
      elims_pm: matches ? elims/matches : 0,
      dmg_pm: matches ? damage/matches : 0,
      avg_place
    });
  }

  const sortKey = el('overallSortKey').value;
  const dir = el('overallSortDir').dataset.dir;

  if(sortKey === 'team') sortRows(rows, 'team', dir, true);
  else sortRows(rows, sortKey, dir, false);

  el('tblOverall').innerHTML = renderSimpleTable(rows, [
    {label:'Team', key:'team'},
    {label:'Matches', key:'matches', right:true},
    {label:'Booyahs', key:'booyahs', right:true},
    {label:'Elims', key:'elims', right:true},
    {label:'Elims/m', key:'elims_pm', format:'1d', right:true},
    {label:'Damage', key:'damage', right:true},
    {label:'Dmg/m', key:'dmg_pm', format:'0d', right:true},
    {label:'Avg Place', key:'avg_place', right:true, html:r=> (r.avg_place==null ? '—' : r.avg_place.toFixed(1))}
  ]);

  applyColumnHeatmap('tblOverall', ['dmg_pm','elims_pm','booyahs','matches','damage','elims']);
}

function renderTeamGrid(filter=''){
  const q = (filter||'').trim().toLowerCase();
  const teams = [...new Set(FILTERED.map(r => norm(getVal(r, KEYS.team)).toUpperCase()).filter(Boolean))]
    .filter(t => t.toLowerCase().includes(q))
    .sort((a,b)=> a.localeCompare(b));

  const grid = el('teamGrid');
  if(!teams.length){
    grid.innerHTML = '<div class="muted">No teams found in this scope.</div>';
    return;
  }

  grid.innerHTML = teams.map(t=>`
    <div class="team-tile" data-team="${t}">
      <img class="team-logo" src="" alt="" style="visibility:hidden">
      <div class="team-code">${t}</div>
    </div>
  `).join('');

  grid.querySelectorAll('.team-tile').forEach(tile=>{
    tile.onclick = ()=>{
      const t = tile.getAttribute('data-team');
      selectTeam(t);
    };
  });

  highlightActiveTile();
}

function highlightActiveTile(){
  const grid=el('teamGrid'); if(!grid) return;
  [...grid.querySelectorAll('.team-tile')].forEach(div=>{
    const t=div.getAttribute('data-team');
    div.classList.toggle('active', !!CURRENT_TEAM && CURRENT_TEAM===t);
  });
}

function summarizeTeamLoadout(rows){
  const act = new Map();
  const pas = new Map();
  const pet = new Map();

  for(const r of rows){
    const a = getActiveSkillId(r);
    if(a) act.set(a, (act.get(a)||0)+1);

    const ps = getPassiveSkillIds(r);
    for(const pid of ps){
      pas.set(pid, (pas.get(pid)||0)+1);
    }

    const pl = getPetLabel(r);
    if(pl) pet.set(pl, (pet.get(pl)||0)+1);
  }

  const topAct = listTopCounts(act, 3).map(o=>`${mapSkillFromId(o.name, `ID ${o.name}`)} (${o.picks})`).join(' • ') || '—';
  const topPas = listTopCounts(pas, 6).map(o=>`${mapSkillFromId(o.name, `ID ${o.name}`)} (${o.picks})`).join(' • ') || '—';
  const topPet = listTopCounts(pet, 3).map(o=>`${o.name} (${o.picks})`).join(' • ') || '—';

  return { topAct, topPas, topPet };
}

function renderTeamKpis(teamRows){
  const tm = teamMatchAgg(teamRows);

  const matches = tm.length;
  const booyahs = tm.reduce((a,b)=>a+(b.booyah||0), 0);
  const elims = tm.reduce((a,b)=>a+(b.elims||0), 0);
  const damage = tm.reduce((a,b)=>a+(b.damage||0), 0);

  const placementVals = tm.map(x=>x.placement).filter(v=>v!=null && isFinite(v));
  const avg_place = placementVals.length ? (placementVals.reduce((a,b)=>a+b,0)/placementVals.length) : null;

  el('teamKpis').innerHTML = matches ? `
    <div class="kpis">
      <div class="kpi">Matches <strong>${matches}</strong></div>
      <div class="kpi">Booyahs <strong>${booyahs}</strong> <span class="muted">(${fmtPct(matches?booyahs/matches:0)})</span></div>
      <div class="kpi">Elims <strong>${elims}</strong> <span class="muted">(${(elims/matches).toFixed(1)}/m)</span></div>
      <div class="kpi">Damage <strong>${damage}</strong> <span class="muted">(${(damage/matches).toFixed(0)}/m)</span></div>
      <div class="kpi">Avg Placement <strong>${avg_place==null?'—':avg_place.toFixed(1)}</strong></div>
    </div>
  ` : `<div class="muted">No team rows in this scope.</div>`;

  const snap = summarizeTeamLoadout(teamRows);
  el('teamLoadoutSnap').innerHTML = `
    <div class="kpis">
      <div class="kpi">Top 3 Active <strong>${snap.topAct}</strong></div>
      <div class="kpi">Top 6 Passive <strong>${snap.topPas}</strong></div>
      <div class="kpi">Top Pet <strong>${snap.topPet}</strong></div>
    </div>
    <div class="muted" style="margin-top:6px">
      Active/Passive is derived from character.json <strong>api_id</strong> (with last-digit variations if needed). Loadout is from <strong>player_stats_loadout</strong> when available.
    </div>
  `;
}

function renderPlayersTable(teamRows){
  const tm = teamMatchAgg(teamRows);
  const booyahByMatch = new Map();
  for(const r of tm) booyahByMatch.set(r.mk, !!r.booyah);

  const playerKey = KEYS.player;
  const g = groupBy(teamRows, r => norm(getVal(r, playerKey)) || '—');

  const out = [];
  for(const [player, list] of g.entries()){
    const matchSet = new Set(list.map(matchKeyForRow));
    const matches = matchSet.size;

    const kills = KEYS.kills ? list.reduce((a,b)=>a + n(getVal(b, KEYS.kills)), 0) : 0;
    const damage = KEYS.damage ? list.reduce((a,b)=>a + n(getVal(b, KEYS.damage)), 0) : 0;

    let booyahs = 0;
    for(const mk of matchSet){ if(booyahByMatch.get(mk)) booyahs++; }

    const activeCount = new Map();
    const passiveCount = new Map();
    const petCount = new Map();
    const loadoutCount = new Map();

    for(const r of list){
      const a = getActiveSkillId(r);
      if(a) activeCount.set(a, (activeCount.get(a)||0)+1);

      for(const pid of getPassiveSkillIds(r)){
        passiveCount.set(pid, (passiveCount.get(pid)||0)+1);
      }

      const pl = getPetLabel(r);
      if(pl) petCount.set(pl, (petCount.get(pl)||0)+1);

      const sig = loadoutSignature(r);
      if(sig) loadoutCount.set(sig, (loadoutCount.get(sig)||0)+1);
    }

    const topActive = listTopCounts(activeCount, 1)[0];
    const topPet = listTopCounts(petCount, 1)[0];
    const topPassives = listTopCounts(passiveCount, 6);

    const topLo = [...loadoutCount.entries()].sort((a,b)=>b[1]-a[1])[0];
    let topLoadoutHtml = '—';
    if(topLo){
      // find any row with same signature to render pretty
      const row = list.find(r => loadoutSignature(r) === topLo[0]);
      if(row){
        const lo = loadoutLabelFromRow(row);
        topLoadoutHtml = `<div class="mini">${lo.text} <span class="muted">(${topLo[1]})</span></div>`;
      }
    }

    out.push({
      player,
      matches,
      booyahs,
      kills,
      elims_pm: matches ? kills/matches : 0,
      damage,
      dmg_pm: matches ? damage/matches : 0,
      active: topActive ? `${mapSkillFromId(topActive.name, `ID ${topActive.name}`)} (${topActive.picks})` : '—',
      passive: topPassives.length ? topPassives.map(p=>`${mapSkillFromId(p.name, `ID ${p.name}`)} (${p.picks})`).join(' • ') : '—',
      pet: topPet ? `${topPet.name} (${topPet.picks})` : '—',
      loadout_html: topLoadoutHtml
    });
  }

  out.sort((a,b)=> (b.dmg_pm - a.dmg_pm) || (b.kills - a.kills) || a.player.localeCompare(b.player));

  el('tblPlayers').innerHTML = renderSimpleTable(out.map((r,i)=>({...r,rank:i+1})), [
    {label:'#', key:'rank', right:true, html:(_,i)=>i+1},
    {label:'Player', key:'player'},
    {label:'Matches', key:'matches', right:true},
    {label:'Booyahs', key:'booyahs', right:true},
    {label:'Elims', key:'kills', right:true},
    {label:'Elims/m', key:'elims_pm', right:true, format:'1d'},
    {label:'Damage', key:'damage', right:true},
    {label:'Dmg/m', key:'dmg_pm', right:true, format:'0d'},
    {label:'Top Active', key:'active'},
    {label:'Top Passives (6)', key:'passive'},
    {label:'Top Pet', key:'pet'},
    {label:'Top Loadout (player_stats_loadout)', key:'loadout_html', html:r=>r.loadout_html}
  ]);

  applyColumnHeatmap('tblPlayers', ['dmg_pm','elims_pm','damage','kills','matches','booyahs']);
}

function renderTeamUsageTables(teamRows){
  const topA = Number(el('topActive').value) || 10;
  const topP = Number(el('topPassive').value) || 10;
  const topPet = Number(el('topPet').value) || 10;

  const act = new Map();
  const pas = new Map();
  const pet = new Map();

  for(const r of teamRows){
    const a = getActiveSkillId(r);
    if(a) act.set(a, (act.get(a)||0)+1);

    for(const pid of getPassiveSkillIds(r)){
      pas.set(pid, (pas.get(pid)||0)+1);
    }

    const pl = getPetLabel(r);
    if(pl) pet.set(pl, (pet.get(pl)||0)+1);
  }

  const actList = listTopCounts(act, topA).map((o,i)=>({rank:i+1, skill: mapSkillFromId(o.name, `ID ${o.name}`), picks:o.picks}));
  const pasList = listTopCounts(pas, topP).map((o,i)=>({rank:i+1, skill: mapSkillFromId(o.name, `ID ${o.name}`), picks:o.picks}));
  const petList = listTopCounts(pet, topPet).map((o,i)=>({rank:i+1, pet:o.name, picks:o.picks}));

  el('tblActive').innerHTML = renderSimpleTable(actList, [
    {label:'#', key:'rank', right:true},
    {label:'Active Skill', key:'skill'},
    {label:'Picks', key:'picks', right:true}
  ]);
  applyColumnHeatmap('tblActive', ['picks']);

  el('tblPassive').innerHTML = renderSimpleTable(pasList, [
    {label:'#', key:'rank', right:true},
    {label:'Passive Skill', key:'skill'},
    {label:'Picks', key:'picks', right:true}
  ]);
  applyColumnHeatmap('tblPassive', ['picks']);

  el('tblPet').innerHTML = renderSimpleTable(petList, [
    {label:'#', key:'rank', right:true},
    {label:'Pet', key:'pet'},
    {label:'Picks', key:'picks', right:true}
  ]);
  applyColumnHeatmap('tblPet', ['picks']);
}

/* ✅ All teams skill summary:
   - Top 3 active
   - Top 6 passive
   - Players list + their “top loadout”
*/
function playersMiniList(teamRows){
  const playerKey = KEYS.player;
  const g = groupBy(teamRows, r => norm(getVal(r, playerKey)) || '—');

  // build per-player most common loadout signature
  const lines = [];
  for(const [player, list] of g.entries()){
    const sigCount = new Map();
    for(const r of list){
      const sig = loadoutSignature(r);
      if(sig) sigCount.set(sig, (sigCount.get(sig)||0)+1);
    }
    const top = [...sigCount.entries()].sort((a,b)=>b[1]-a[1])[0];
    let html = `<span class="pill">${escapeHtml(player)}</span> <span class="muted">—</span>`;
    if(top){
      const row = list.find(r => loadoutSignature(r) === top[0]);
      if(row){
        const lo = loadoutLabelFromRow(row);
        html = `<span class="pill">${escapeHtml(player)}</span> ${lo.text} <span class="muted">(${top[1]})</span>`;
      }
    }
    lines.push(`<div class="mini">${html}</div>`);
  }

  if(!lines.length) return '<div class="muted">—</div>';

  return `
    <details class="mini-details">
      <summary>Players (${lines.length}) — show</summary>
      <div class="mini">${lines.join('')}</div>
    </details>
  `;
}

function renderAllTeamsSkillSummary(){
  const teams = [...new Set(FILTERED.map(r => norm(getVal(r, KEYS.team)).toUpperCase()).filter(Boolean))]
    .sort((a,b)=>a.localeCompare(b));

  if(!teams.length){
    el('tblAllTeamsSkills').innerHTML = '<div class="muted">No teams in this scope.</div>';
    return;
  }

  const tmAll = teamMatchAgg(FILTERED);
  const matchesByTeam = new Map();
  for(const r of tmAll){
    matchesByTeam.set(r.team, (matchesByTeam.get(r.team)||0) + 1);
  }

  const rows = teams.map(team=>{
    const teamRows = FILTERED.filter(r => norm(getVal(r, KEYS.team)).toUpperCase() === team);

    const act = new Map();
    const pas = new Map();
    const pet = new Map();

    for(const r of teamRows){
      const a = getActiveSkillId(r);
      if(a) act.set(a, (act.get(a)||0)+1);

      for(const pid of getPassiveSkillIds(r)){
        pas.set(pid, (pas.get(pid)||0)+1);
      }

      const pl = getPetLabel(r);
      if(pl) pet.set(pl, (pet.get(pl)||0)+1);
    }

    const topA = listTopCounts(act, 3);
    const topP = listTopCounts(pas, 6);
    const topPet = listTopCounts(pet, 1)[0];

    const topA_txt = topA.length
      ? topA.map(o=>`${mapSkillFromId(o.name, `ID ${o.name}`)} (${o.picks})`).join(' • ')
      : '—';

    const topP_txt = topP.length
      ? topP.map(o=>`${mapSkillFromId(o.name, `ID ${o.name}`)} (${o.picks})`).join(' • ')
      : '—';

    const playersHtml = playersMiniList(teamRows);

    return {
      team,
      matches: matchesByTeam.get(team) || 0,
      top_active: topA_txt,
      top_passive: topP_txt,
      top_pet: topPet ? `${topPet.name} (${topPet.picks})` : '—',
      players_html: playersHtml
    };
  });

  rows.sort((a,b)=> (b.matches - a.matches) || a.team.localeCompare(b.team));

  el('tblAllTeamsSkills').innerHTML = renderSimpleTable(rows, [
    {label:'Team', key:'team'},
    {label:'Matches', key:'matches', right:true},
    {label:'Top 3 Active', key:'top_active'},
    {label:'Top 6 Passive', key:'top_passive'},
    {label:'Top Pet', key:'top_pet'},
    {label:'Players + Loadout (player_stats_loadout)', key:'players_html', html:r=>r.players_html}
  ]);

  applyColumnHeatmap('tblAllTeamsSkills', ['matches']);
}

function selectTeam(teamCode, silent=false){
  CURRENT_TEAM = teamCode;
  el('selectedTeamChip').textContent = teamCode;
  el('teamTitle').textContent = `Team Overview — ${teamCode}`;

  const teamRows = FILTERED.filter(r => norm(getVal(r, KEYS.team)).toUpperCase() === teamCode);

  renderTeamKpis(teamRows);
  renderPlayersTable(teamRows);
  renderTeamUsageTables(teamRows);

  highlightActiveTile();

  if(!silent){
    const url = new URL(window.location.href);
    url.searchParams.set('team', teamCode);
    history.replaceState(null,'',url.toString());
  }
}

/* ============ Wiring ============ */
function wire(){
  el('reloadBtn').addEventListener('click', ()=> location.reload());

  el('overallSortDir').addEventListener('click', ()=>{
    const b=el('overallSortDir');
    const cur=b.dataset.dir==='desc'?'asc':'desc';
    b.dataset.dir=cur;
    b.textContent=cur==='desc'?'Desc':'Asc';
    renderOverall();
  });
  el('overallSortKey').addEventListener('change', renderOverall);

  el('teamSearch').addEventListener('input', e=> renderTeamGrid(e.target.value||''));

  el('topActive').addEventListener('change', ()=>{ if(CURRENT_TEAM) selectTeam(CURRENT_TEAM, true); });
  el('topPassive').addEventListener('change', ()=>{ if(CURRENT_TEAM) selectTeam(CURRENT_TEAM, true); });
  el('topPet').addEventListener('change', ()=>{ if(CURRENT_TEAM) selectTeam(CURRENT_TEAM, true); });

  el('fTournament').addEventListener('change', ()=>{
    refreshCascadeOptions('tournament');
    applyFilters();
  });
  el('fYear').addEventListener('change', ()=>{
    refreshCascadeOptions('year');
    applyFilters();
  });
  el('fWeek').addEventListener('change', ()=>{
    refreshCascadeOptions('week');
    applyFilters();
  });
  el('fDay').addEventListener('change', ()=>{
    refreshCascadeOptions('day');
    applyFilters();
  });
  el('fMatchNo').addEventListener('change', applyFilters);

  el('resetFilters').addEventListener('click', ()=>{
    populateTournamentDropdown();
    resetToLatest();
  });
}

/* ============ Init ============ */
async function init(){
  try{
    clearErr();
    el('veil').classList.remove('hide');

    document.querySelectorAll('details.accordion').forEach(d=> d.open = false);

    await headCount();

    RAW = await fetchAllRows();

    if(!RAW.length){
      el('tblOverall').innerHTML = '<div class="muted">No rows loaded.</div>';
      el('teamGrid').innerHTML = '<div class="muted">No teams.</div>';
      el('tblAllTeamsSkills').innerHTML = '<div class="muted">No teams.</div>';
      el('veil').classList.add('hide');
      gerr(
        `No rows returned from ${TABLE}.\n\n` +
        `Possible causes:\n` +
        `• Table is empty (no inserts)\n` +
        `• RLS blocks SELECT for anon/authenticated\n` +
        `• Different table name/schema\n\n` +
        `Quick check: In Supabase SQL editor run:\n` +
        `select count(*) from public.${TABLE};`
      );
      return;
    }

    detectSchema(RAW[0]);

    // load match_api + character.json (api_id -> kind)
    await loadMatchApi();
    await loadCharacterJson();

    populateTournamentDropdown();
    resetToLatest();

    const url = new URL(window.location.href);
    const qt = (url.searchParams.get('team')||'').trim().toUpperCase();
    if(qt){
      const teamsInScope = new Set(FILTERED.map(r => norm(getVal(r, KEYS.team)).toUpperCase()).filter(Boolean));
      if(teamsInScope.has(qt)) selectTeam(qt, true);
    }

    wire();

    el('veil').classList.add('hide');
  }catch(e){
    el('veil').classList.add('hide');
    gerr('Fatal init error:\n\n' + (e?.message || e));
  }
}

init();
</script>
</body>
</html>
