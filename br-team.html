<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FFBR — Teams</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root{
      --bg:#0e0e0e; --panel:#1b1b1b; --panel2:#141414; --ink:#f5f5f5; --muted:#b9b9b9;
      --brand:#ffbd59; --brand2:#ff7733; --line:#313131;
      --tile-w:96px; --tile-h:104px; --logo:44px; --code-fs:.74rem;
      --heat-rgb:255,189,89; --heat-min:.06; --heat-max:.22; --heat-top-outline:.42; --heat-radius:8px;
      --heat-cool:95,205,255;
      --heat-warm:255,153,0;
      --good:#62e887; --bad:#ff6b6b; --step-h:48px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Arial,sans-serif
    }

    header{
      position:sticky;
      top:0;
      z-index:20;
      background:#1f1f1f;
      border-bottom:3px solid var(--brand);
    }
    .header-inner{
      max-width:1180px;
      margin:0 auto;
      padding:10px 12px;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px 12px;
    }
    header h1{
      margin:0;
      font-size:1.1rem;
      letter-spacing:.3px;
      color:var(--brand);
      flex:1 1 auto;
    }
    .user-controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      justify-content:flex-end;
      flex:1 1 100%;
    }
    @media (min-width:640px){
      .user-controls{ flex:0 0 auto; }
    }

    .chip{
      font-size:.8rem;
      color:#ddd;
      background:#272727;
      border:1px solid #3a3a3a;
      border-radius:999px;
      padding:4px 10px;
      white-space:nowrap;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    .btn{
      background:var(--brand);
      color:var(--panel);
      border:0;
      border-radius:8px;
      padding:8px 12px;
      font-weight:700;
      cursor:pointer;
      text-decoration:none;
      display:inline-block;
      font-size:.85rem;
    }
    .btn.secondary{ background:#2a2a2a; color:#ddd; border:1px solid #3a3a3a }
    .btn.ghost{ background:transparent; color:#ddd; border:1px solid #3a3a3a }

    .shell{ max-width:1180px; margin:22px auto; padding:0 12px; }

    .gerr{
      display:none;
      margin:0 0 12px;
      background:#2a1111;
      border:1px solid #553;
      color:#ffb4b4;
      border-radius:10px;
      padding:10px 12px;
      white-space:pre-wrap
    }
    .gerr.show{display:block}

    .section{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:12px;
      padding:12px;
      margin-bottom:14px
    }
    .section h2{ margin:0 0 10px; color:var(--brand) }

    .grid2{ display:grid; grid-template-columns:repeat(2,minmax(260px,1fr)); gap:12px }
    .grid3{ display:grid; grid-template-columns:repeat(3,minmax(220px,1fr)); gap:12px }

    .card{
      background:var(--panel2);
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px
    }
    .card h3{ margin:0 0 6px; color:var(--brand2); font-size:1.0rem }

    .kpis{ display:flex; gap:6px; flex-wrap:wrap; margin:6px 0 }
    .kpi{
      background:#111;
      border:1px solid #2a2a2a;
      border-radius:8px;
      padding:6px 10px;
      font-size:.9rem
    }
    .kpi strong{font-weight:800}

    .bar{ display:flex; gap:8px; align-items:center; margin-bottom:8px; flex-wrap:wrap }
    .bar label{
      color:var(--muted);
      font-size:.9rem;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .input{
      background:#121212;
      color:#eaeaea;
      border:1px solid #2a2a2a;
      border-radius:8px;
      padding:7px 10px;
      font-size:.9rem;
    }
    .muted{color:var(--muted)}

    .team-grid{
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(var(--tile-w),1fr));
      gap:8px
    }
    .team-tile{
      height:var(--tile-h);
      background:#131313;
      border:1px solid #2a2a2a;
      border-radius:10px;
      padding:6px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:6px;
      cursor:pointer;
      transition:transform .1s ease,border-color .1s ease;
      overflow:hidden
    }
    .team-tile:hover{ transform:translateY(-2px); border-color:#444 }
    .team-tile.active{ outline:2px solid var(--brand2) }
    .team-tile.activeA{ outline:2px solid var(--brand2) }
    .team-tile.activeB{ outline:2px solid rgba(var(--heat-cool),1) }

    .team-logo{
      width:var(--logo);
      height:var(--logo);
      object-fit:contain;
      filter:drop-shadow(0 0 8px rgba(0,0,0,.4))
    }
    .team-code{
      font-weight:800;
      font-size:var(--code-fs);
      line-height:1.1;
      letter-spacing:.2px
    }

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0 6px;
      font-size:.92rem;
    }
    thead th{
      background:#191919;
      position:sticky;
      top:0;
      text-align:left;
      border-radius:8px;
      padding:8px 6px;
      z-index:1
    }
    th,td{ padding:6px 6px; vertical-align:top }
    .right{text-align:right}

    td[data-key]{
      transition:background-color .18s ease, box-shadow .18s ease;
      border-radius:var(--heat-radius);
      background-clip:padding-box
    }
    td.heat-top{ box-shadow:inset 0 0 0 1px rgba(var(--heat-rgb), var(--heat-top-outline)) }

    .table-scroll{
      width:100%;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
    }
    .table-scroll table{ min-width:820px; }
    .table-scroll th,.table-scroll td{ white-space:nowrap; }

    .table-scroll thead th.col-rank{
      position:sticky;
      left:0;
      z-index:10;
      text-align:center;
      min-width:46px;
      border-right:1px solid #242424;
      color:rgba(245,245,245,.65);
      font-weight:700;
    }
    .table-scroll tbody td.col-rank{
      position:sticky;
      left:0;
      z-index:4;
      text-align:center;
      font-weight:700;
      font-size:.85rem;
      color:rgba(245,245,245,.55);
      background:#131313;
      border-right:1px solid #242424;
    }
    .table-scroll tbody tr:hover td.col-rank{ color:rgba(245,245,245,.78); }

    @media (max-width:520px){
      .table-scroll th.col-ew,.table-scroll td.col-ew,
      .table-scroll th.col-region,.table-scroll td.col-region{ display:none; }
    }
    
        /* === FIX: Character & Pet Usage tables should NOT need horizontal scroll === */
    #tblTeamCharUsage .table-scroll table,
    #tblTeamPetUsage .table-scroll table{
      min-width: 0 !important;   /* overrides global min-width:820px */
      width: 100%;
    }
    
    #tblTeamCharUsage .table-scroll th,
    #tblTeamCharUsage .table-scroll td,
    #tblTeamPetUsage .table-scroll th,
    #tblTeamPetUsage .table-scroll td{
      white-space: normal !important;     /* allow wrapping for long names */
      overflow-wrap: anywhere;
    }
    
    /* keep numeric columns readable (don’t wrap numbers) */
    #tblTeamCharUsage .table-scroll td.right,
    #tblTeamCharUsage .table-scroll th.right,
    #tblTeamPetUsage .table-scroll td.right,
    #tblTeamPetUsage .table-scroll th.right{
      white-space: nowrap !important;
    }


    details.accordion{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:12px;
      margin-bottom:14px
    }
    details.accordion > summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      color:var(--brand);
      font-weight:700;
      border-bottom:1px solid var(--line)
    }
    details.accordion > .accordion-body{ padding:12px }

    #veil{
      position:fixed;
      inset:0;
      display:grid;
      place-items:center;
      background:rgba(10,10,10,.95);
      z-index:9999
    }
    #veil .box{
      background:#121212;
      border:1px solid #2a2a2a;
      border-radius:12px;
      padding:14px 16px;
      color:#ddd
    }
    #veil.hide{display:none}

    /* Split View */
    .split-grid{
      display:grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr); /* true half/half */
      gap:12px;
      align-items:start;
    }
    
    /* CRITICAL: allow grid children to shrink instead of expanding the column */
    .split-grid > div{
      min-width:0;
    }
    
    /* Keep cards/tables inside their half */
    .split-grid .card{
      min-width:0;
      width:100%;
      overflow:hidden;
    }
    
    /* Ensure scroll containers never exceed column width */
    .split-grid .table-scroll{
      max-width:100%;
    }
    
    /* (Optional but safe) prevent long identity text from stretching layout */
    .split-grid .muted,
    .split-grid h3,
    .split-grid #splitIdentityA,
    .split-grid #splitIdentityB{
      overflow-wrap:anywhere;
    }
    
    @media (max-width:980px){
      .grid3{grid-template-columns:1fr}
      .split-grid{grid-template-columns:1fr}
    }
    @media (max-width:860px){.grid2{grid-template-columns:1fr}}

    .pillbtn.onA{ outline:2px solid var(--brand2); }
    .pillbtn.onB{ outline:2px solid rgba(var(--heat-cool),1); }
  </style>
</head>
<body>
<header>
  <div class="header-inner">
    <h1>FFBR — Teams</h1>
    <div class="user-controls">
      <a class="btn secondary" id="homeBtn" href="dashboard.html">← Back to Dashboard</a>

      <button class="btn ghost" id="splitToggleBtn" type="button">Split View</button>
      <button class="btn secondary" id="splitResetBtn" type="button" style="display:none">Reset Split</button>

      <span class="chip" id="scopeChip">Scope: —</span>
      <span class="chip" id="user-info">Checking login…</span>
      <button class="btn" id="logoutBtn">Logout</button>
    </div>
  </div>
</header>

<div id="veil"><div class="box">Loading data…</div></div>

<div class="shell">
  <div id="globalErr" class="gerr"></div>

  <div class="section">
    <h2>Team Selection</h2>
    <div class="bar">
      <input type="search" id="teamSearch" placeholder="Search team / region…" class="input" style="flex:1;max-width:420px">

      <span class="chip">
        Scope: <span id="scopeChipTeam">—</span> •
        <a href="#" id="editFilters1" class="btn ghost" style="padding:4px 10px">Edit filters</a>
      </span>

      <span class="chip" id="splitPickChip" style="display:none">
        Pick side:
        <button class="pillbtn onA" id="pickSideA" type="button">Left</button>
        <button class="pillbtn" id="pickSideB" type="button">Right</button>
        <span class="muted" id="splitPickHint">Click a team tile to assign.</span>
      </span>
    </div>

    <div id="teamGrid" class="team-grid">Loading teams…</div>
    <div id="teamGridErr"></div>
  </div>

  <!-- SPLIT VIEW -->
  <div class="section" id="splitSection" style="display:none">
    <h2>Split View — Team Comparison</h2>
    <div class="bar" style="margin-bottom:10px">
      <label>Left Team
        <select id="splitSelA" class="input" style="min-width:220px"></select>
      </label>
      <label>Right Team
        <select id="splitSelB" class="input" style="min-width:220px"></select>
      </label>
      <span class="chip" id="splitActiveChip">Active pick: Left</span>
    </div>

    <div class="split-grid">
      <div>
        <div class="card" style="margin-bottom:12px">
          <h3>Left — Identity</h3>
          <div id="splitIdentityA" class="muted">—</div>
        </div>
        <div class="card" style="margin-bottom:12px">
          <h3>Left — Key KPIs</h3>
          <div id="splitKpisA" class="muted">—</div>
        </div>
        <div class="card" style="margin-bottom:12px">
          <h3>Left — By Map</h3>
          <div id="splitMapA" class="muted">—</div>
        </div>
        <div class="card">
          <h3>Left — By Day (Pivot by Map)</h3>
          <div id="splitDayA" class="muted">—</div>
        </div>
      </div>

      <div>
        <div class="card" style="margin-bottom:12px">
          <h3>Right — Identity</h3>
          <div id="splitIdentityB" class="muted">—</div>
        </div>
        <div class="card" style="margin-bottom:12px">
          <h3>Right — Key KPIs</h3>
          <div id="splitKpisB" class="muted">—</div>
        </div>
        <div class="card" style="margin-bottom:12px">
          <h3>Right — By Map</h3>
          <div id="splitMapB" class="muted">—</div>
        </div>
        <div class="card">
          <h3>Right — By Day (Pivot by Map)</h3>
          <div id="splitDayB" class="muted">—</div>
        </div>
      </div>
    </div>
  </div>

  <!-- SINGLE TEAM HEADER -->
  <div class="section" id="teamHeader">
    <h2 id="teamTitle">Overview</h2>
    <div class="grid2">
      <div class="card" id="teamIdentity">
        <h3>Identity</h3>
        <div id="identityBody">Select a team.</div>
      </div>
      <div class="card" id="teamKPIs">
        <h3>Key KPIs</h3>
        <div id="kpiBody">—</div>
      </div>
    </div>
  </div>

  <!-- FILTERS -->
  <div class="section" id="filtersSection">
    <h2>Filters</h2>
    <div class="bar">
      <label>Year
        <select id="gYear" class="input" style="min-width:140px">
          <option value="__all__">All years</option>
        </select>
      </label>
      <label>Season
        <select id="gSeason" class="input" style="min-width:220px">
          <option value="__all__">All seasons</option>
        </select>
      </label>
      <label>Tournament
        <select id="gTournament" class="input" style="min-width:220px">
          <option value="__all__">All tournaments</option>
        </select>
      </label>
      <label>Stage
        <select id="gStage" class="input" style="min-width:180px">
          <option value="__all__">All stages</option>
        </select>
      </label>
      <button class="btn secondary" id="gTournReset">Reset</button>
    </div>
    <div class="muted" id="filterHint">—</div>
  </div>

  <details class="accordion" id="teamInfoSection">
    <summary>Team Info</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <div id="teamInfoBody" class="muted">—</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="mapsDaysSection">
    <summary>By Map & By Day Stats</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0 0 12px 0">
        <h3>By Map</h3>
        <div id="tblMapTeam">—</div>
      </div>
      <div class="card" style="margin:0">
        <h3>By Day (Pivot by Map)</h3>
        <div id="tblByDay">—</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="teamRosterSection">
    <summary>Roster & Accolades</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <div id="teamRosterBody" class="muted">—</div>
      </div>
    </div>
  </details>

    <!-- NEW: PLAYER / LOADOUT / ELIMS ANALYTICS -->
  <details class="accordion" id="playerStatsSection">
    <summary>Player Stats</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <div id="tblPlayerStats">—</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="charPetUsageSection">
    <summary>Character and Pet Usage</summary>
    <div class="accordion-body">
      <div class="grid2">
        <div class="card" style="margin:0">
          <h3>Team — Character Usage (Active + Passive)</h3>
          <div id="tblTeamCharUsage">—</div>
        </div>
        <div class="card" style="margin:0">
          <h3>Team — Pet Usage</h3>
          <div id="tblTeamPetUsage">—</div>
        </div>
      </div>
    </div>
  </details>

  <details class="accordion" id="perPlayerActiveSection">
    <summary>Per-Player Character Usage — Active</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <div id="tblPerPlayerActive">—</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="perPlayerPassiveSection">
    <summary>Per-Player Character Usage — Passive</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <div id="tblPerPlayerPassive">—</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="elimsFocusSection">
    <summary>Eliminations — Team Focus &amp; Breakdowns</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <div id="tblElimsFocus">—</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="overallSection">
    <summary>Overall Performance (All Teams)</summary>
    <div class="accordion-body">
      <div class="bar">
        <label for="overallSortKey">Sort by</label>
        <select id="overallSortKey" class="input">
          <option value="total_pm">Total / m</option>
          <option value="total" selected>Total</option>
          <option value="elims_pm">Elims / m</option>
          <option value="elims">Elims</option>
          <option value="placement_pm">Placement / m</option>
          <option value="placement">Placement</option>
          <option value="booyah_rate">Booyah %</option>
          <option value="booyahs">Booyahs</option>
          <option value="matches">Matches</option>
          <option value="top3_rate">Top-3 %</option>
          <option value="team">Team (A→Z)</option>
        </select>
        <button class="btn secondary" id="overallSortDir" data-dir="desc">Desc</button>
        <button class="btn secondary" id="overallReset">Reset</button>
      </div>
      <div class="card" style="margin:0">
        <div id="tblOverall">Loading…</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="perMapAllSection">
    <summary>All Teams — Per-Map Breakdown</summary>
    <div class="accordion-body">
      <div class="bar">
        <label for="mapFilter">Map</label>
        <select id="mapFilter" class="input" style="min-width:220px">
          <option value="__all__" selected>All maps</option>
        </select>
        <label for="perMapSortKey">Sort by</label>
        <select id="perMapSortKey" class="input">
          <option value="total_pm">Total / m</option>
          <option value="total" selected>Total</option>
          <option value="elims_pm">Elims / m</option>
          <option value="elims">Elims</option>
          <option value="placement_pm">Placement / m</option>
          <option value="placement">Placement</option>
          <option value="booyah_rate">Booyah %</option>
          <option value="booyahs">Booyahs</option>
          <option value="matches">Matches</option>
          <option value="top3_rate">Top-3 %</option>
          <option value="team">Team (A→Z)</option>
        </select>
        <button class="btn secondary" id="perMapSortDir" data-dir="desc">Desc</button>
        <button class="btn secondary" id="perMapReset">Reset</button>
      </div>
      <div class="card" style="margin:0">
        <div id="tblPerMapAllTeams">Loading…</div>
      </div>
    </div>
  </details>

  <details class="accordion" id="aiAnalysisSection">
    <summary>AI Analysis Helper (Caster Prompt)</summary>
    <div class="accordion-body">
      <div class="card" style="margin:0">
        <p class="muted" style="margin-bottom:8px">
          This block generates a ready-to-paste prompt for an AI esports analyst / commentator based on the selected team and current filters.
        </p>
        <textarea
          id="aiPrompt"
          class="input"
          style="width:100%;min-height:240px;white-space:pre;overflow:auto;font-family:Menlo,Consolas,monospace;font-size:.8rem;"
          readonly
        >Select a team from the grid above to generate an AI analysis prompt.</textarea>
        <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap;justify-content:flex-end">
          <button class="btn secondary" type="button" id="refreshAiPromptBtn">Refresh prompt</button>
          <button class="btn" type="button" id="copyAiPromptBtn">Copy prompt</button>
        </div>
        <div id="aiCopyStatus" class="muted" style="margin-top:4px;font-size:.8rem;"></div>
      </div>
    </div>
  </details>
</div>

<script>
/* ============ Supabase init ============ */
const client = supabase.createClient(
  'https://ooutjrewmwsixghbouxi.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9vdXRqcmV3bXdzaXhnaGJvdXhpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwMjg3NTMsImV4cCI6MjA4MjYwNDc1M30.13WkdGiQH39lZH3iDgVDd_tZrHlI0twhGeiZNdwaMSg'
);

/* ============ Small utils ============ */
const el = id => document.getElementById(id);
const fmtPct = x => isFinite(x) ? (x*100).toFixed(1)+'%' : '—';
const n = x => Number(x ?? 0) || 0;
const norm = v => (v==null ? '' : String(v).trim());
function sum(arr,k){ let t=0; for(const r of arr) t+= Number(r?.[k] ?? 0) || 0; return t; }
function safeDiv(a,b){ a=Number(a??0)||0; b=Number(b??0)||0; return b? (a/b) : 0; }
function groupBy(arr,fn){ const m=new Map(); for(const r of arr){ const k=fn(r); if(!m.has(k)) m.set(k,[]); m.get(k).push(r);} return m; }
function looksLikeURL(v){ return /^https?:\/\//i.test(String(v||'')); }
const nameKey = s => String(s||'').toLowerCase().replace(/\s+/g,' ').trim();
function setVisible(id, on){ const node=el(id); if(node) node.style.display = on ? '' : 'none'; }

/* ============ Global error surface ============ */
function gerr(msg){
  const box=el('globalErr'); if(!box) return;
  box.textContent = msg; box.classList.add('show');
  console.error('[FFBR]', msg);
}

/* Jump to filters */
const editFiltersLink = el('editFilters1');
if(editFiltersLink){
  editFiltersLink.addEventListener('click', e=>{
    e.preventDefault();
    const target = el('filtersSection');
    if(target) target.scrollIntoView({behavior:'smooth', block:'start'});
  });
}

/* ============ Session chip ============ */
(async () => {
  const { data: { session } } = await client.auth.getSession();
  el('user-info').textContent = session?.user?.email ? `Logged in: ${session.user.email}` : 'Anon access';
})();
el('logoutBtn').onclick = async () => { await client.auth.signOut(); location.reload(); };

/* ============ State ============ */
let HELPER_TEAMS = [];
let HELPER_BY_CODE = {};

let TEAMS=[]; let TEAM_BY_CODE={}; let TEAM_BY_NAME={}; let ALLOWED_TAGS=new Set();
let ALL=[]; let TEAM_ROWS=[]; let CURRENT_TEAM=null;
let TEAM_INFO = null;
let TEAM_PLAYERS = [];

/* Split */
let SPLIT_MODE = false;
let SPLIT_ACTIVE_SIDE = 'A'; // A=Left, B=Right
let TEAM_A = null, TEAM_B = null;
let ROWS_A = [], ROWS_B = [];

/* ============ Helpers ============ */
function buildHelperIndex(){
  HELPER_BY_CODE = Object.fromEntries(HELPER_TEAMS.map(t => [String(t.name||'').toUpperCase(), t]));
}
function buildTeamIndexes(){
  TEAM_BY_CODE = Object.fromEntries(TEAMS.map(t=>[t.name.toLowerCase(), t]));
  TEAM_BY_NAME = Object.fromEntries(TEAMS.map(t=>[t.fullname.toLowerCase(), t]));
  ALLOWED_TAGS = new Set(TEAMS.map(t => t.name.toUpperCase()));
}
function deriveTeamsFromData(rows){
  const codes=[...new Set(rows.map(r=> norm(r.tag||r.TAG||r._tag).toUpperCase()).filter(Boolean))].sort();
  return codes.map(code=>{
    const meta = HELPER_BY_CODE[code] || {};
    return {
      name: code,
      fullname: meta.fullname || meta.name || code,
      logo: meta.logo || '',
      ew: meta.ew || '',
      region: meta.region || '',
      alt: meta.alt || ''
    };
  });
}
function normalizeRow(r){
  r._tag = norm(r.tag ?? r.TAG ?? '').toUpperCase();
  if (r.elimination == null) r.elimination = r.elims ?? r.kills ?? 0;
  if (r.placement   == null) r.placement   = r.place ?? 0;
  if (r.top3        == null) r.top3        = r.top_3 ?? 0;
  return r;
}
async function fetchAllRows(){
  const CHUNK=1000; let from=0; const out=[];
  for(;;){
    const { data, error } = await client.from('ffbr_data').select('*').order('id',{ascending:true}).range(from, from+CHUNK-1);
    if(error){ gerr('ffbr_data fetch failed. Check RLS / table name.\n\n'+(error.message||error)); break; }
    const rows=data||[]; if(!rows.length) break;
    out.push(...rows); from+=rows.length;
  }
  return out.map(normalizeRow);
}
async function fetchHelperTeams(){
  const { data, error } = await client.from('helper_team').select('*').order('TAG');
  if(error){ console.warn('helper_team error:', error.message||error); return []; }
  const rows=data||[];
  return rows.map(r=>{
    const code = norm(r.TAG).toUpperCase();
    return {
      name:code,
      fullname:norm(r.TEAM)||code,
      logo:norm(r.LOGO)||'',
      ew:norm(r['E/W'])||'',
      region:norm(r.REGION)||'',
      alt:norm(r['ALT NAME 1'])||''
    };
  });
}

/* ============ Year / Season / Tournament / Stage ============ */
function uniqueYears(rows){
  const set = new Set();
  for(const r of rows){
    const y = r.year;
    if(y==null) continue;
    const yn = Number(y);
    if(isFinite(yn) && yn>0) set.add(String(yn));
    else if(String(y).trim()!=='') set.add(String(y).trim());
  }
  const arr=[...set];
  arr.sort((a,b)=> (Number(b)||0) - (Number(a)||0) || a.localeCompare(b));
  return arr;
}
function uniqueSeasons(rows){
  const set = new Set();
  for(const r of rows){
    const s = norm(r.season);
    if(s) set.add(s);
  }
  return [...set].sort((a,b)=>a.localeCompare(b));
}
function tournamentsWithMaxId(rows){
  const m=new Map();
  for(const r of rows){
    const t=norm(r.tournament); if(!t) continue;
    const id=n(r.id);
    const key=t.toLowerCase();
    if(!m.has(key)) m.set(key, { name:t, maxId:id });
    else m.get(key).maxId = Math.max(m.get(key).maxId, id);
  }
  return [...m.values()].sort((a,b)=> b.maxId - a.maxId || a.name.localeCompare(b.name));
}
function stagesWithMaxId(rows){
  const m=new Map();
  for(const r of rows){
    const s=norm(r.stage); if(!s) continue;
    const id=n(r.id);
    const key=s.toLowerCase();
    if(!m.has(key)) m.set(key, { name:s, maxId:id });
    else m.get(key).maxId = Math.max(m.get(key).maxId, id);
  }
  return [...m.values()].sort((a,b)=> b.maxId - a.maxId || a.name.localeCompare(b.name));
}

function selectedYear(){ return (el('gYear')?.value || '__all__').trim(); }
function selectedSeason(){ return (el('gSeason')?.value || '__all__').trim(); }
function selectedTournament(){ return (el('gTournament')?.value || '__all__').trim(); }
function selectedStage(){ return (el('gStage')?.value || '__all__').trim(); }

function rowsFilteredByYearOnly(rows){
  const y = selectedYear();
  if(y==='__all__') return rows;
  const yNum = Number(y);
  if(isFinite(yNum)) return rows.filter(r => Number(r.year)===yNum);
  const yl = y.toLowerCase();
  return rows.filter(r => String(r.year??'').toLowerCase()===yl);
}
function rowsFilteredByYearSeason(rows){
  let out = rowsFilteredByYearOnly(rows);
  const s = selectedSeason();
  if(s!=='__all__'){
    const sl = s.toLowerCase();
    out = out.filter(r=> norm(r.season).toLowerCase()===sl);
  }
  return out;
}
function rowsFilteredByYearSeasonTournament(rows){
  let out = rowsFilteredByYearSeason(rows);
  const t = selectedTournament();
  if(t!=='__all__'){
    const tl=t.toLowerCase();
    out = out.filter(r=> norm(r.tournament).toLowerCase()===tl);
  }
  return out;
}

function populateYearFilter(){
  const sel=el('gYear'); if(!sel) return;
  const years = uniqueYears(ALL);
  sel.innerHTML = `<option value="__all__">All years</option>` + years.map(y=>`<option value="${y}">${y}</option>`).join('');
  if(years.includes('2025')) sel.value = '2025';
  else if(years.length) sel.value = years[0];
  else sel.value = '__all__';
}
function populateSeasonFilter(){
  const sel=el('gSeason'); if(!sel) return;
  const scoped = rowsFilteredByYearOnly(ALL);
  const seasons = uniqueSeasons(scoped);
  sel.innerHTML = `<option value="__all__">All seasons</option>` + seasons.map(s=>`<option value="${s.replaceAll('"','&quot;')}">${s}</option>`).join('');
  const gf = seasons.find(s => s.toLowerCase()==='global finals');
  if(gf) sel.value = gf;
  else sel.value = '__all__';
}
function populateTournamentFilter(){
  const sel=el('gTournament'); if(!sel) return;
  const scoped = rowsFilteredByYearSeason(ALL);
  const items = tournamentsWithMaxId(scoped);
  sel.innerHTML = `<option value="__all__">All tournaments</option>` +
    items.map(o=>`<option value="${o.name.replaceAll('"','&quot;')}">${o.name}</option>`).join('');
  sel.value = '__all__';
}
function populateStageFilter(defaultLatest=true){
  const sel = el('gStage'); if(!sel) return;
  const scoped = rowsFilteredByYearSeasonTournament(ALL);
  const items = stagesWithMaxId(scoped);
  sel.innerHTML = `<option value="__all__">All stages</option>` +
    items.map(v=>`<option value="${v.name.replaceAll('"','&quot;')}">${v.name}</option>`).join('');
  if(defaultLatest && items.length) sel.value = items[0].name;
  else sel.value = '__all__';
}

function baseRows(rows){
  let out = rows;

  const y = selectedYear();
  if(y!=='__all__'){
    const yNum = Number(y);
    out = isFinite(yNum)
      ? out.filter(r => Number(r.year)===yNum)
      : out.filter(r => String(r.year??'').toLowerCase()===y.toLowerCase());
  }

  const seas = selectedSeason();
  if(seas!=='__all__'){
    const sl = seas.toLowerCase();
    out = out.filter(r=> norm(r.season).toLowerCase()===sl);
  }

  const t = selectedTournament();
  if(t!=='__all__'){
    const tl=t.toLowerCase();
    out = out.filter(r=> norm(r.tournament).toLowerCase()===tl);
  }

  const s = selectedStage();
  if(s!=='__all__'){
    const sf=s.toLowerCase();
    out = out.filter(r=> norm(r.stage).toLowerCase()===sf);
  }
  return out;
}

function updateFilterHint(){
  const yRaw = selectedYear();
  const seasRaw = selectedSeason();
  const tRaw = selectedTournament();
  const sRaw = selectedStage();

  const yText = yRaw==='__all__' ? 'All years' : yRaw;
  const seasText = seasRaw==='__all__' ? 'All seasons' : seasRaw;
  const tText = tRaw==='__all__' ? 'All tournaments' : tRaw;
  const sText = sRaw==='__all__' ? 'All stages' : sRaw;

  const total = baseRows(ALL).length;
  el('filterHint').textContent = `Scope: ${yText} • ${seasText} • ${tText} • Stage: ${sText} • Rows: ${total}`;
  el('scopeChip').textContent = `Scope: ${yText} • ${seasText} • ${tText} • ${sText}`;
  el('scopeChipTeam').textContent = `${yText} • ${seasText} • ${tText} • ${sText}`;
}

/* Rebuild TEAMS for current scope */
function updateTeamsForCurrentScope(){
  const scopedRows = baseRows(ALL);
  TEAMS = deriveTeamsFromData(scopedRows);
  buildTeamIndexes();
  const searchVal = el('teamSearch') ? el('teamSearch').value : '';
  renderTeamGrid(searchVal);
  populateSplitSelects();
}

/* ============ Tables + heat ============ */
function renderSimpleTable(list, cols, opts = {}){
  if (!list.length) return '<div class="muted">No rows.</div>';

  const showRank = opts.rank !== false;
  const finalCols = showRank
    ? [{ label:'#', key:'__rank', className:'col-rank', html:(_r,i)=> (i+1) }, ...cols]
    : cols;

  const head = `<thead><tr>` + finalCols.map(c=>{
    const classes=[];
    if (c.right) classes.push('right');
    if (c.className) classes.push(c.className);
    const clsStr = classes.length ? ` class="${classes.join(' ')}"` : '';
    return `<th data-key="${c.key}"${clsStr}>${c.label}</th>`;
  }).join('') + `</tr></thead>`;

  const body = `<tbody>` + list.map((r,i)=>`<tr>` + finalCols.map(c=>{
    let v;
    if (typeof c.html==='function'){
      v=c.html(r,i);
    } else {
      v=r[c.key];
      if (c.format==='pct') v=isFinite(v)?(v*100).toFixed(1)+'%':'—';
      else if (c.format==='1d') v=isFinite(v)?Number(v).toFixed(1):'—';
      else if (c.format==='0d') v=isFinite(v)?Number(v).toFixed(0):'—';
      if (c.link && v && looksLikeURL(v)) v=`<a href="${v}" target="_blank" rel="noopener">${v}</a>`;
    }
    if (v==null || v==='') v='—';

    const classes=[];
    if (c.right) classes.push('right');
    if (c.className) classes.push(c.className);
    const clsStr = classes.length ? ` class="${classes.join(' ')}"` : '';
    return `<td data-key="${c.key}"${clsStr}>${v}</td>`;
  }).join('') + `</tr>`).join('') + `</tbody>`;

  return `<div class="table-scroll"><table>${head}${body}</table></div>`;
}

function applyColumnHeatmap(containerId, keys){
  const wrap=el(containerId); const table=wrap?.querySelector('table'); if(!table) return;

  table.querySelectorAll('td[data-key]').forEach(td=>{
    td.style.backgroundColor='';
    td.classList.remove('heat-top');
  });

  const styles=getComputedStyle(document.documentElement);
  const coolStr = styles.getPropertyValue('--heat-cool') || '95,205,255';
  const warmStr = styles.getPropertyValue('--heat-warm') || '255,153,0';
  const minA=parseFloat(styles.getPropertyValue('--heat-min'))||.06;
  const maxA=parseFloat(styles.getPropertyValue('--heat-max'))||.22;

  const parseRGB = str=>{
    const parts=String(str).split(',').map(s=>parseFloat(s.trim())).filter(x=>!Number.isNaN(x));
    return {r:parts[0]||0,g:parts[1]||0,b:parts[2]||0};
  };
  const cool=parseRGB(coolStr);
  const warm=parseRGB(warmStr);
  const BANDS=5;

  for(const key of keys){
    const cells=[...table.querySelectorAll(`td[data-key="${key}"]`)];
    if(!cells.length) continue;

    const entries=cells.map((td,i)=>{
      const raw=(td.textContent||'').trim().replace('%','').replace(/,/g,'');
      const v=parseFloat(raw);
      return {td,i,v:isFinite(v)?v:null};
    }).filter(e=>e.v!=null);
    if(!entries.length) continue;

    const asc=entries.slice().sort((a,b)=>a.v-b.v);
    const n2=asc.length;
    const bandByIndex=new Map();
    asc.forEach((e,rank)=>{
      const p=(n2<=1)?1:(rank/(n2-1));
      const band=Math.min(BANDS-1,Math.floor(p*BANDS));
      bandByIndex.set(e.i,band);
    });

    const topVal=asc[n2-1].v;

    cells.forEach((td,i)=>{
      const band=bandByIndex.get(i);
      if(band==null) return;
      const t = (BANDS===1)?1:(band/(BANDS-1));
      const r = Math.round(cool.r + t*(warm.r-cool.r));
      const g = Math.round(cool.g + t*(warm.g-cool.g));
      const b = Math.round(cool.b + t*(warm.b-cool.b));
      const alpha=minA + (band/(BANDS-1))*(maxA-minA);
      td.style.backgroundColor=`rgba(${r},${g},${b},${alpha.toFixed(3)})`;

      const v=parseFloat((td.textContent||'').trim().replace('%','').replace(/,/g,''));
      if(isFinite(v) && v===topVal){
        td.classList.add('heat-top');
      }
    });
  }
}

/* Aggregations */
function codeFromRow(r){ const code=norm(r._tag).toUpperCase(); return ALLOWED_TAGS.has(code) ? code : null; }
function metaFromCode(code){ return code ? TEAM_BY_CODE[code.toLowerCase()] : null; }

function aggregateOverall(rows){
  const grouped=new Map();
  for(const r of rows){
    const code=codeFromRow(r); if(!code) continue;
    if(!grouped.has(code)) grouped.set(code,[]);
    grouped.get(code).push(r);
  }
  const out=[];
  for(const [code,list] of grouped.entries()){
    const meta=metaFromCode(code); const m=list.length; if(!m||!meta) continue;
    const booyahs=sum(list,'booyah'), elims=sum(list,'elimination'), place=sum(list,'placement'), total=sum(list,'total');
    out.push({ team:meta.fullname, code:meta.name, region:(meta.region||'—'), ew: meta.ew||'',
      matches:m, booyahs, elims, placement:place, total,
      booyah_rate:booyahs/m, elims_pm:elims/m, placement_pm:place/m, total_pm:total/m, top3_rate: sum(list,'top3')/m });
  }
  return out;
}
function aggregateTeamsForMap(rows,mapValue){
  const perTeam=new Map();
  for(const r of rows){
    if(mapValue && mapValue!=='__all__'){
      if((norm(r.map)||'').toLowerCase()!==mapValue.toLowerCase()) continue;
    }
    const code=codeFromRow(r); if(!code) continue;
    if(!perTeam.has(code)) perTeam.set(code,[]);
    perTeam.get(code).push(r);
  }
  const out=[];
  for(const [code,list] of perTeam.entries()){
    const meta=metaFromCode(code); const m=list.length; if(!m||!meta) continue;
    const booyahs=sum(list,'booyah'), elims=sum(list,'elimination'), place=sum(list,'placement'), total=sum(list,'total');
    out.push({ team:meta.fullname, code:meta.name, region:(meta.region||'—'), ew: meta.ew||'',
      matches:m, booyahs, elims, placement:place, total,
      booyah_rate:booyahs/m, elims_pm:elims/m, placement_pm:place/m, total_pm:total/m, top3_rate: sum(list,'top3')/m });
  }
  return out;
}
function uniqueMaps(rows){ const s=new Set(); for(const r of rows){ const m=norm(r.map); if(m) s.add(m); } return [...s].sort((a,b)=>a.localeCompare(b)); }

/* Team info/roster fetch (single view only) */
function splitToLines(val){
  if (val == null) return [];
  if (Array.isArray(val) ) return val.flat().map(x=>String(x).trim()).filter(Boolean);
  let s=String(val).trim();
  try{
    if(/^\s*\[/.test(s)){
      const arr=JSON.parse(s);
      if(Array.isArray(arr)) return arr.flat().map(x=>String(x).trim()).filter(Boolean);
    }
  }catch{}
  s=s.replace(/[•\u2022\u00b7]/g,'\n');
  let parts=s.split(/\r?\n|;|\|/);
  if(parts.length===1 && s.includes(',')) parts=s.split(',');
  return parts.map(x=>x.trim()).filter(Boolean);
}
function asListHTML(val){
  const items = splitToLines(val); if(!items.length) return '—';
  return `<ul style="margin:0;padding-left:16px">${items.map(it=>`<li>${it}</li>`).join('')}</ul>`;
}
async function fetchTeamInfoBy(codeRaw){
  const codeUp=norm(codeRaw).toUpperCase();
  try{
    let res=await client.from('br_team_info').select('*').eq('Team Initials', codeUp).limit(1);
    if(res.error) throw res.error;
    if(res.data?.length) return res.data[0];
  }catch(e){ console.warn('br_team_info fetch error:', e.message||e); }
  return null;
}
async function fetchPlayersBy(codeRaw){
  const codeUp=norm(codeRaw).toUpperCase();
  try{
    const res=await client.from('br_player_info').select('*').eq('TAG', codeUp);
    if(res.error) throw res.error;
    return res.data||[];
  }catch(e){ console.warn('br_player_info fetch error:', e.message||e); return []; }
}
function parseAgeValue(record, ageKey, dobKey){
  if(ageKey){
    const raw = record[ageKey];
    if(raw!=null && String(raw).trim()!==''){
      const m = String(raw).match(/(\d{1,3})/);
      if(m){
        const v = Number(m[1]);
        if(isFinite(v) && v>=0 && v<130) return v;
      }
    }
  }
  if(dobKey){
    const raw = String(record[dobKey] ?? '').trim();
    if(raw){
      const d = new Date(raw);
      if(!isNaN(d.getTime())){
        const today = new Date();
        let age = today.getFullYear() - d.getFullYear();
        const mo = today.getMonth() - d.getMonth();
        if(mo < 0 || (mo === 0 && today.getDate() < d.getDate())) age--;
        if(isFinite(age) && age>=0 && age<130) return age;
      }
    }
  }
  return null;
}
function renderRoster(players){
  const box=el('teamRosterBody');
  if(!box) return;
  if(!players?.length){
    box.innerHTML='<div class="muted">No players found.</div>';
    return;
  }
  const keys=Object.keys(players[0]||{});
  const pickKey=(keys, patterns)=>{
    for(const rx of patterns){
      const k = keys.find(k => rx.test(k));
      if(k) return k;
    }
    return null;
  };
  const avatarKey = pickKey(keys, [/photo|avatar|image|picture/i]);
  const ignKey = pickKey(keys, [/^ign$/i,/\bplayer\s*ign\b/i,/\bin-?\s*game\s*name\b/i,/\bnick\s*name\b/i,/\bnickname\b/i,/\bhandle\b/i,/\balias\b/i,/\bplayer\s*name\b/i,/^name$/i]) || null;
  const roleKey    = pickKey(keys, [/^role$/i, /\bposition\b/i]) || null;
  const countryKey = pickKey(keys, [/^country$/i, /\bnation\b/i]) || null;
  const ageKey = pickKey(keys, [/^age\b/i, /\bage\s*\(?(yrs|years)?\)?/i, /\byears?\s*old\b/i]) || null;
  const dobKey = pickKey(keys, [/\b(dob|birth(date)?|date\s*of\s*birth)\b/i]) || null;
  const accolKey = keys.includes('Accolades') ? 'Accolades' : pickKey(keys, [/accolade|achievement|title|award/i]) || null;
  const formerKey = pickKey(keys, [/\b(former|previous|past|ex)[\s_]*teams?\b/i,/\bteam\s*history\b/i,/^Former Team(s)?$/i]) || 'Former Team';

  const rows = players.slice().map(p=>{
    const avatar = avatarKey && p[avatarKey]
      ? `<img src="${p[avatarKey]}" alt="" style="width:38px;height:38px;object-fit:cover;border-radius:8px;border:1px solid #2a2a2a">`
      : '';
    const ign = (() => {
      const tryKeys = ignKey ? [ignKey] : [];
      tryKeys.push('IGN','In-game Name','Player IGN','Player Name','Nickname','Name','name');
      for(const k of tryKeys){
        if(k in p && String(p[k]).trim()!=='') return String(p[k]).trim();
      }
      return '—';
    })();
    const role    = roleKey    ? (p[roleKey]    ?? '—') : '—';
    const country = countryKey ? (p[countryKey] ?? '—') : '—';
    const ageNum = parseAgeValue(p, ageKey, dobKey);
    const age    = (ageNum==null) ? (ageKey? String(p[ageKey]??'—'): '—') : ageNum;
    const accHTML    = accolKey  ? asListHTML(p[accolKey])   : '—';
    const formerHTML = formerKey ? asListHTML(p[formerKey])  : '—';
    return { avatar, ign, role, country, age, formerHTML, accHTML };
  });
  rows.sort((a,b)=> String(a.role||'').localeCompare(String(b.role||'')) || String(a.ign||'').localeCompare(String(b.ign||'')));
  box.innerHTML = renderSimpleTable(rows, [
    {label:'', key:'avatar'},
    {label:'IGN', key:'ign'},
    {label:'Role', key:'role'},
    {label:'Country', key:'country'},
    {label:'Age', key:'age', right:true},
    {label:'Former Team', key:'formerHTML'},
    {label:'Accolades', key:'accHTML'},
  ]);
}
function renderTeamInfo(info){
  const box = el('teamInfoBody');
  if (!box) return;

  if (!info || !Object.keys(info).length){
    box.innerHTML = '<div class="muted">No team info found.</div>';
    return;
  }

  const pref = [
    'Team Initials','Team','Full Name','Region','Country','Coach','Manager','Org','Organization',
    'Owner','Founded','Sponsors','Twitter','Instagram','Facebook','YouTube','Twitch','Website'
  ];
  const keys = [...new Set([...pref, ...Object.keys(info)])]
    .filter(k => info[k] != null && String(info[k]).trim() !== '');

  const rows = keys.map(k => {
    const val = String(info[k]);
    const vHtml = /^https?:\/\//i.test(val)
      ? `<a href="${val}" target="_blank" rel="noopener">${val}</a>`
      : val;
    return `<tr>
      <th style="text-align:left;padding:4px 6px;color:#b9b9b9">${k}</th>
      <td style="padding:4px 6px">${vHtml}</td>
    </tr>`;
  }).join('');

  box.innerHTML = `<table style="width:100%;border-collapse:collapse">${rows}</table>`;
}

/* KPI / maps */
function kpiDataset(rows){
  const matches=rows.length, booyahs=sum(rows,'booyah'), total=sum(rows,'total'), elims=sum(rows,'elimination'),
        place=sum(rows,'placement'), damage=sum(rows,'damage'), top3=sum(rows,'top3');
  return {
    matches, booyahs, elims, placement:place, total,
    booyah_rate: matches? booyahs/matches : 0,
    total_per_match: matches? total/matches : 0,
    elims_per_match: matches? elims/matches : 0,
    place_per_match: matches? place/matches : 0,
    dmg_per_match: matches? damage/matches : 0,
    top3_rate: matches? top3/matches : 0
  };
}
function latestYwdm(rows){
  let best=null;
  for(const r of rows){
    const y=n(r.year), w=n(r.week), d=n(r.day), m=n(r.match);
    const key = (y*1e8) + (w*1e6) + (d*1e4) + (m||0);
    if(!best || key>best.key) best={y,w,d,m,key};
  }
  return best;
}
function fmtYwdm(obj){
  if(!obj) return '—';
  const parts=[`Y${obj.y||'—'}`];
  if(n(obj.w)) parts.push(`W${obj.w}`);
  if(n(obj.d)) parts.push(`D${obj.d}`);
  if(n(obj.m)) parts.push(`M${obj.m}`);
  return parts.join(' ');
}
function teamMapPerf(rows){
  const g = groupBy(rows, r=>r.map||'—');
  const out=[];
  for(const [map,list] of g.entries()){
    const m=list.length, booyahs=sum(list,'booyah'), elims=sum(list,'elimination'), place=sum(list,'placement'), total=sum(list,'total');
    out.push({ map, matches:m, booyahs, elims, placement:place, total,
      booyah_rate:m?booyahs/m:0, elims_pm:m?elims/m:0, placement_pm:m?place/m:0, total_pm:m?total/m:0 });
  }
  return out.sort((a,b)=> b.total_pm - a.total_pm || b.matches - a.matches || a.map.localeCompare(b.map));
}

/* By Day pivot (generic) */
function renderByDayInto(containerId, rows){
  const box = el(containerId);
  if(!box) return;
  if(!rows.length){
    box.innerHTML = '<div class="muted">No rows.</div>';
    return;
  }
  const dayLabel = r => `Y${n(r.year)||'—'} W${n(r.week)||'—'} D${n(r.day)||'—'}`;

  const daySet = new Set(), mapSet = new Set();
  for(const r of rows){
    mapSet.add(norm(r.map) || '—');
    daySet.add(dayLabel(r));
  }
  const days = [...daySet].sort((a,b)=> a.localeCompare(b));
  const maps = [...mapSet].sort((a,b)=> a.localeCompare(b));

  const totals = new Map();
  for(const r of rows){
    const m = norm(r.map) || '—';
    const d = dayLabel(r);
    if(!totals.has(m)) totals.set(m, new Map());
    const row = totals.get(m);
    row.set(d, (row.get(d) || 0) + n(r.total));
  }

  let thead = `<thead><tr>
    <th class="col-rank">#</th>
    <th data-key="map">Map</th>
    ${days.map(d=>`<th data-key="${d}" class="right">${d}</th>`).join('')}
  </tr></thead>`;

  let tbody = '<tbody>';
  maps.forEach((m, idx) => {
    const row = totals.get(m) || new Map();
    tbody += `<tr>
      <td class="col-rank">${idx+1}</td>
      <td data-key="map">${m}</td>` +
      days.map(d=>{
        const v = row.get(d);
        return `<td data-key="${d}" class="right">${(v!=null && isFinite(v)) ? Number(v).toFixed(0) : '—'}</td>`;
      }).join('') +
      `</tr>`;
  });
  tbody += '</tbody>';

  box.innerHTML = `<div class="table-scroll"><table>${thead}${tbody}</table></div>`;
  applyColumnHeatmap(containerId, days);
}

/* AI prompt (single view) */
function buildRosterTextForAi(players){
  if(!players || !players.length) return 'No roster data available.';
  const example = players[0];
  const keys = Object.keys(example || {});
  const pickKey = (patterns)=>{
    for(const rx of patterns){
      const key = keys.find(k => rx.test(k));
      if(key) return key;
    }
    return null;
  };
  const ignKey = pickKey([/^ign$/i,/\bplayer\s*ign\b/i,/\bin-?\s*game\s*name\b/i,/\bnick\s*name\b/i,/\bnickname\b/i,/\bhandle\b/i,/\balias\b/i,/\bplayer\s*name\b/i,/^name$/i]);
  const roleKey    = pickKey([/^role$/i, /\bposition\b/i]);
  const countryKey = pickKey([/^country$/i, /\bnation\b/i]);
  const ageKey     = pickKey([/^age\b/i, /\bage\s*\(?(yrs|years)?\)?/i, /\byears?\s*old\b/i]);
  const dobKey     = pickKey([/\b(dob|birth(date)?|date\s*of\s*birth)\b/i]);
  const formerKey  = pickKey([/\b(former|previous|past|ex)[\s_]*teams?\b/i,/\bteam\s*history\b/i,/^Former Team(s)?$/i]) || 'Former Team';
  const accolKey   = keys.includes('Accolades') ? 'Accolades' : pickKey([/accolade|achievement|title|award/i]);

  const lines = players.slice(0, 10).map(p=>{
    const ign = (() => {
      const tryKeys = ignKey ? [ignKey] : [];
      tryKeys.push('IGN','In-game Name','Player IGN','Player Name','Nickname','Name','name');
      for(const k of tryKeys){
        if(k in p && String(p[k]).trim()!=='') return String(p[k]).trim();
      }
      return 'Unknown';
    })();
    const role    = roleKey    && p[roleKey]    ? String(p[roleKey]).trim()    : '';
    const country = countryKey && p[countryKey] ? String(p[countryKey]).trim() : '';
    const ageNum  = parseAgeValue(p, ageKey, dobKey);
    const age     = ageNum!=null ? ageNum : (ageKey && p[ageKey] ? String(p[ageKey]).trim() : '');
    const former  = formerKey && p[formerKey] ? String(p[formerKey]).trim() : '';
    const acc     = accolKey && p[accolKey]   ? String(p[accolKey]).trim()   : '';

    const parts = [`IGN=${ign}`];
    if(role)   parts.push(`Role=${role}`);
    if(country)parts.push(`Country=${country}`);
    if(age!=='') parts.push(`Age=${age}`);
    if(former) parts.push(`FormerTeams=${former}`);
    if(acc)    parts.push(`Accolades=${acc}`);
    return '- ' + parts.join(' | ');
  });

  return lines.join('\n');
}
function buildTeamInfoTextForAi(info){
  if(!info || !Object.keys(info).length) return 'No additional team info available.';
  const lines = [];
  for(const [k,v] of Object.entries(info)){
    if(v == null) continue;
    const vs = String(v).trim();
    if(!vs) continue;
    const keyLower = k.toLowerCase();
    if(keyLower.includes('logo') || keyLower.includes('image') || keyLower.includes('photo')) continue;
    if(/^https?:\/\//i.test(vs)) continue;
    lines.push(`${k}=${vs}`);
  }
  return lines.length ? lines.join('\n') : 'No additional team info available.';
}
function buildAiPrompt(){
  if(!CURRENT_TEAM){
    return 'Select a team from the grid above to generate an AI analysis prompt.';
  }

  const scopeYear = selectedYear()==='__all__' ? 'All years' : selectedYear();
  const scopeSeason = selectedSeason()==='__all__' ? 'All seasons' : selectedSeason();
  const scopeTournament = selectedTournament()==='__all__' ? 'All tournaments' : selectedTournament();
  const scopeStage = selectedStage()==='__all__' ? 'All stages' : selectedStage();

  if(!TEAM_ROWS || !TEAM_ROWS.length){
    return `You are an esports analyst and Free Fire Battle Royale commentator.

Task:
- Give a clear and concise summary (max ~150 words).
- Use bullet points.
- Focus on what we can say given that NO match data exists yet in this scope.

Scope:
- Year filter: ${scopeYear}
- Season filter: ${scopeSeason}
- Tournament filter: ${scopeTournament}
- Stage filter: ${scopeStage}

Team identity:
- Team code: ${CURRENT_TEAM.name}
- Team name: ${CURRENT_TEAM.fullname}
- Region: ${CURRENT_TEAM.region || '—'}
- East/West group: ${CURRENT_TEAM.ew || '—'}

Respond ONLY with short bullet points, no long paragraphs.`;
  }

  const k   = kpiDataset(TEAM_ROWS);
  const last = latestYwdm(TEAM_ROWS);
  const maps = teamMapPerf(TEAM_ROWS);

  const kpiLines = [
    `Rows=${k.matches}`,
    `Booyahs=${k.booyahs} (BooyahRate=${fmtPct(k.booyah_rate)})`,
    `Elims=${k.elims} (ElimsPerMatch=${k.elims_per_match.toFixed(1)})`,
    `PlacementPoints=${k.placement} (PlacementPerMatch=${k.place_per_match.toFixed(1)})`,
    `TotalPoints=${k.total} (TotalPerMatch=${k.total_per_match.toFixed(1)})`,
    `Top3Rate=${fmtPct(k.top3_rate)}`,
    `LastPlayedYWD=${fmtYwdm(last)}`
  ].join('\n');

  const mapLines = maps.length
    ? maps.map(mp =>
        `- Map=${mp.map} | Matches=${mp.matches} | Booyahs=${mp.booyahs} | BooyahRate=${fmtPct(mp.booyah_rate)} | ElimsPerMatch=${mp.elims_pm.toFixed(1)} | PlacementPerMatch=${mp.placement_pm.toFixed(1)} | TotalPerMatch=${mp.total_pm.toFixed(1)}`
      ).join('\n')
    : 'No per-map stats in this scope.';

  const matchLines = TEAM_ROWS.map(r=>{
    return `- Y${r.year??''} W${r.week??''} D${r.day??''} M${r.match??''} | Tournament=${norm(r.tournament)||'n/a'} | Season=${norm(r.season)||'n/a'} | Stage=${norm(r.stage)||'n/a'} | Map=${norm(r.map)||'n/a'} | Drop=${norm(r.drop)||'n/a'} | Booyah=${n(r.booyah)} | PlacementPts=${n(r.placement)} | Elims=${n(r.elimination)} | TotalPts=${n(r.total)} | Top3Flag=${n(r.top3)}`;
  }).join('\n');

  const rosterText   = buildRosterTextForAi(TEAM_PLAYERS);
  const teamInfoText = buildTeamInfoTextForAi(TEAM_INFO);

  return `You are an esports analyst and Free Fire Battle Royale commentator.

Task:
- Give a clear, concise summary of this team.
- Use short bullet points only (no long paragraphs).
- Keep the answer around 150–200 words max.
- Focus on what a caster needs quickly before going live.

Data scope:
- Year filter: ${scopeYear}
- Season filter: ${scopeSeason}
- Tournament filter: ${scopeTournament}
- Stage filter: ${scopeStage}

Team identity:
- Team code: ${CURRENT_TEAM.name}
- Team name: ${CURRENT_TEAM.fullname}
- Region: ${CURRENT_TEAM.region || '—'}
- East/West group: ${CURRENT_TEAM.ew || '—'}

Overall KPIs within this scope:
${kpiLines}

Per-map performance:
${mapLines}

Roster (from br_player_info):
${rosterText}

Additional team info (from br_team_info):
${teamInfoText}

Match log (each row is one game in this scope):
${matchLines}

In your answer, provide ONLY:
- 3–5 bullet points on overall identity and playstyle.
- 2–3 bullet points on map strengths/weaknesses and trends.
- 1–2 bullet points on key storylines or talking points.

Do NOT restate the raw numbers in full sentences. Interpret them briefly.`;
}
function updateAiPrompt(){
  const ta = el('aiPrompt');
  if(!ta) return;
  ta.value = buildAiPrompt();
}

/* ===================== NEW: Advanced Team Analytics ===================== */

/** Candidate tables (edit these to match your real schema if needed) */
const ADV_TABLES = {
  playerStats: [
    'br_player_match_stats',
    'br_player_stats',
    'ffbr_player_match_stats',
    'ffbr_player_stats'
  ],
  loadouts: [
    'ffbr_lopsdata',
    'br_loadouts',
    'br_player_loadouts',
    'ffbr_loadouts'
  ],
  elimLog: [
    'br_elimination_log',
    'ffbr_elimination_log',
    'br_killfeed',
    'ffbr_killfeed',
    'br_elims',
    'ffbr_elims'
  ]
};

function pickKeyFrom(keys, patterns){
  for(const rx of patterns){
    const k = keys.find(x => rx.test(x));
    if(k) return k;
  }
  return null;
}
function normLower(x){ return String(x ?? '').trim().toLowerCase(); }
function isTrivialBoolSet(vals){
  const s = new Set(vals.map(v => normLower(v)).filter(Boolean));
  if(!s.size) return true;
  const allowed = new Set(['0','1','true','false','yes','no','y','n']);
  for(const v of s) if(!allowed.has(v)) return false;
  return true;
}
function sampleVals(rows, key, limit=25){
  return rows.slice(0, limit).map(r => String(r?.[key] ?? '').trim()).filter(Boolean);
}
function looksLikeNames(rows, key){
  const vals = sampleVals(rows, key);
  if(!vals.length) return false;
  if(isTrivialBoolSet(vals)) return false;
  // Heuristic: must have letters on average
  const letters = vals.filter(v => /[a-z]/i.test(v)).length;
  return letters >= Math.max(2, Math.floor(vals.length * 0.5));
}

/** Probe a table safely */
async function probeTable(table){
  try{
    const res = await client.from(table).select('*').limit(1);
    if(res.error) return { ok:false, error:res.error };
    const sample = res.data?.[0] || null;
    const keys = sample ? Object.keys(sample) : [];
    return { ok:true, keys, sample };
  }catch(e){
    return { ok:false, error:e };
  }
}

/** Fetch rows with pagination; applies filters only if matching columns exist */
async function fetchPaged(table, filters = {}){
  const CHUNK = 1000;
  let from = 0;
  const out = [];

  for(;;){
    let q = client.from(table).select('*');

    // Apply filters if column exists
    for(const [col, val] of Object.entries(filters)){
      if(val == null) continue;
      q = q.eq(col, val);
    }

    const { data, error } = await q.range(from, from + CHUNK - 1);
    if(error) throw error;
    const rows = data || [];
    if(!rows.length) break;
    out.push(...rows);
    from += rows.length;
    if(rows.length < CHUNK) break;
  }
  return out;
}

/** Try candidate tables and return { table, keys, rows } or null */
async function fetchFromFirstWorkingTable(candidates, buildFilterFn){
  for(const table of candidates){
    const probe = await probeTable(table);
    if(!probe.ok) continue;

    const keys = probe.keys || [];
    const filters = buildFilterFn ? buildFilterFn(keys) : {};
    try{
      const rows = await fetchPaged(table, filters);
      return { table, keys, rows };
    }catch(e){
      // If RLS denies or filter col invalid, just continue to next candidate
      continue;
    }
  }
  return null;
}

function buildScopeFilter(keys){
  const y = selectedYear(), s = selectedSeason(), t = selectedTournament(), st = selectedStage();

  const yearCol = pickKeyFrom(keys, [/^year$/i]);
  const seasonCol = pickKeyFrom(keys, [/^season$/i]);
  const tournCol = pickKeyFrom(keys, [/tournament/i]);
  const stageCol = pickKeyFrom(keys, [/^stage$/i]);

  const f = {};
  if(yearCol && y !== '__all__'){
    const yNum = Number(y);
    f[yearCol] = isFinite(yNum) ? yNum : y;
  }
  if(seasonCol && s !== '__all__') f[seasonCol] = s;
  if(tournCol && t !== '__all__') f[tournCol] = t;
  if(stageCol && st !== '__all__') f[stageCol] = st;
  return f;
}

function detectTeamCol(keys){
  return pickKeyFrom(keys, [/^tag$/i, /^team_tag$/i, /\bteam.*tag\b/i, /team\s*initials/i]);
}
function detectPlayerCol(keys, rows){
  const candidates = [
    /^ign$/i, /\bplayer\s*ign\b/i, /\bin-?\s*game\s*name\b/i,
    /\bplayer\b/i, /\bnickname\b/i, /^name$/i
  ];
  for(const rx of candidates){
    const k = keys.find(x => rx.test(x));
    if(k && looksLikeNames(rows, k)) return k;
  }
  // fallback any column that looks like names
  for(const k of keys){
    if(looksLikeNames(rows, k) && /ign|player|name|nick/i.test(k)) return k;
  }
  return null;
}

function detectKillCol(keys){
  return pickKeyFrom(keys, [/elims?/i, /kills?/i, /elimination/i]);
}
function detectDmgCol(keys){
  return pickKeyFrom(keys, [/damage/i, /\bdmg\b/i]);
}

/** Loadout column detection */
function detectLoadoutCols(keys, rows){
  // Active
  const activeCandidates = keys.filter(k => /active/i.test(k) && /(skill|character|char|ability)/i.test(k));
  let activeCol = activeCandidates.find(k => looksLikeNames(rows, k)) || null;
  if(!activeCol){
    // sometimes just "Active"
    const k = keys.find(k => /^active$/i.test(k));
    if(k && looksLikeNames(rows, k)) activeCol = k;
  }

  // Passive(s) - allow multiple
  const passiveCols = keys
    .filter(k => /passive/i.test(k) || /passive\s*\d/i.test(k))
    .filter(k => looksLikeNames(rows, k));

  // Pet
  const petCandidates = keys.filter(k => /pet/i.test(k));
  const petCol = petCandidates.find(k => looksLikeNames(rows, k)) || null;

  // Player + Team
  const teamCol = detectTeamCol(keys);

  return { teamCol, activeCol, passiveCols, petCol };
}

/** Render helpers */
function countBy(list, getKey){
  const m = new Map();
  for(const r of list){
    const k = norm(String(getKey(r) ?? '')).trim();
    if(!k) continue;
    const key = k;
    m.set(key, (m.get(key) || 0) + 1);
  }
  return m;
}
function topNFromMap(m, n=12){
  return [...m.entries()].sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0])).slice(0,n);
}
function renderCountsTable(containerId, entries, totalLabel='Uses'){
  const box = el(containerId);
  if(!box) return;
  if(!entries.length){
    box.innerHTML = '<div class="muted">No data.</div>';
    return;
  }
  const total = entries.reduce((acc, e)=>acc + (e.count||0), 0) || 0;
  const rows = entries.map(([name, count]) => ({
    name,
    count,
    share: total ? (count/total) : 0
  }));
  box.innerHTML = renderSimpleTable(rows, [
    { label:'Name', key:'name' },
    { label: totalLabel, key:'count', right:true },
    { label:'Share', key:'share', format:'pct', right:true }
  ]);
  applyColumnHeatmap(containerId, ['count','share']);
}

function renderPivot(containerId, players, topItems, matrix){
  const box = el(containerId);
  if(!box) return;
  if(!players.length || !topItems.length){
    box.innerHTML = '<div class="muted">No data.</div>';
    return;
  }

  const cols = [
    { label:'Player', key:'player' },
    { label:'Total Uses', key:'total', right:true },
    ...topItems.map(name => ({ label:name, key:name, right:true }))
  ];

  const rows = players.map(p=>{
    const obj = { player:p, total:0 };
    for(const it of topItems){
      const v = matrix.get(p)?.get(it) || 0;
      obj[it] = v;
      obj.total += v;
    }
    return obj;
  }).sort((a,b)=> (b.total - a.total) || String(a.player).localeCompare(String(b.player)));

  box.innerHTML = renderSimpleTable(rows, cols);
  applyColumnHeatmap(containerId, ['total', ...topItems]);
}

/** Main loader */
let ADV_CACHE = new Map();

async function loadAdvancedForCurrentTeam(){
  if(!CURRENT_TEAM || SPLIT_MODE) return;

  const cacheKey = [
    CURRENT_TEAM.name,
    selectedYear(), selectedSeason(), selectedTournament(), selectedStage()
  ].join('|');

  // placeholders
  const ph = '<div class="muted">Loading…</div>';
  if(el('tblPlayerStats')) el('tblPlayerStats').innerHTML = ph;
  if(el('tblTeamCharUsage')) el('tblTeamCharUsage').innerHTML = ph;
  if(el('tblTeamPetUsage')) el('tblTeamPetUsage').innerHTML = ph;
  if(el('tblPerPlayerActive')) el('tblPerPlayerActive').innerHTML = ph;
  if(el('tblPerPlayerPassive')) el('tblPerPlayerPassive').innerHTML = ph;
  if(el('tblElimsFocus')) el('tblElimsFocus').innerHTML = ph;

  if(ADV_CACHE.has(cacheKey)){
    const cached = ADV_CACHE.get(cacheKey);
    renderAdvancedBlocks(cached);
    return;
  }

  const teamCode = CURRENT_TEAM.name.toUpperCase();

  // --- Player stats source ---
  const playerStatsPack = await fetchFromFirstWorkingTable(
    ADV_TABLES.playerStats,
    (keys)=>{
      const f = buildScopeFilter(keys);
      const teamCol = detectTeamCol(keys);
      if(teamCol) f[teamCol] = teamCode;
      return f;
    }
  );

  // --- Loadouts source (characters / pets) ---
  const loadoutsPack = await fetchFromFirstWorkingTable(
    ADV_TABLES.loadouts,
    (keys)=>{
      const f = buildScopeFilter(keys);
      const teamCol = detectTeamCol(keys);
      if(teamCol) f[teamCol] = teamCode;
      return f;
    }
  );

  // --- Elim log (kills/deaths) ---
  // For elim, we might need two filters (killer OR victim). Do it as two pulls if possible.
  let elimRows = [];
  let elimKeys = [];
  let elimTable = null;

  for(const table of ADV_TABLES.elimLog){
    const probe = await probeTable(table);
    if(!probe.ok) continue;

    elimKeys = probe.keys || [];
    elimTable = table;

    const killerTeamCol = pickKeyFrom(elimKeys, [/killer.*tag/i, /killer.*team/i, /^killer_tag$/i, /^killer_team$/i, /^attacker_tag$/i, /^attacker_team$/i]);
    const victimTeamCol = pickKeyFrom(elimKeys, [/victim.*tag/i, /victim.*team/i, /^victim_tag$/i, /^victim_team$/i, /^downed_tag$/i, /^downed_team$/i]);

    const scopeF = buildScopeFilter(elimKeys);

    try{
      if(killerTeamCol){
        const f1 = { ...scopeF, [killerTeamCol]: teamCode };
        const a = await fetchPaged(table, f1);
        elimRows.push(...a);
      }
      if(victimTeamCol){
        const f2 = { ...scopeF, [victimTeamCol]: teamCode };
        const b = await fetchPaged(table, f2);
        elimRows.push(...b);
      }

      // If we got something or at least table works, keep it
      break;
    }catch(e){
      elimRows = [];
      elimKeys = [];
      elimTable = null;
      continue;
    }
  }

  const payload = {
    playerStatsPack,
    loadoutsPack,
    elimPack: elimTable ? { table: elimTable, keys: elimKeys, rows: elimRows } : null
  };

  ADV_CACHE.set(cacheKey, payload);
  renderAdvancedBlocks(payload);
}

function renderAdvancedBlocks(payload){
  const teamCode = CURRENT_TEAM?.name?.toUpperCase?.() || '';

  /* ---------- Player Stats ---------- */
  {
    const box = el('tblPlayerStats');
    if(!box) {} else if(!payload.playerStatsPack || !payload.playerStatsPack.rows?.length){
      box.innerHTML = '<div class="muted">No player stats rows found (check your player stats table / RLS).</div>';
    }else{
      const { rows, keys } = payload.playerStatsPack;

      const teamCol = detectTeamCol(keys);
      const scoped = teamCol ? rows.filter(r => norm(r[teamCol]).toUpperCase() === teamCode) : rows.slice();

      const playerCol = detectPlayerCol(keys, scoped) || detectPlayerCol(keys, rows);
      const killCol = detectKillCol(keys);
      const dmgCol = detectDmgCol(keys);

      if(!playerCol){
        box.innerHTML = '<div class="muted">Player column not detected in stats table. (Need something like IGN / Player Name.)</div>';
      }else{
        const g = groupBy(scoped, r => norm(r[playerCol]) || 'Unknown');
        const out = [];
        for(const [player, list] of g.entries()){
          const m = list.length;
          const elims = killCol ? sum(list, killCol) : 0;
          const dmg = dmgCol ? sum(list, dmgCol) : 0;
          out.push({
            player,
            matches: m,
            elims,
            elims_pm: m ? elims/m : 0,
            damage: dmg,
            dmg_pm: m ? dmg/m : 0
          });
        }
        out.sort((a,b)=> (b.elims - a.elims) || (b.damage - a.damage) || a.player.localeCompare(b.player));

        box.innerHTML = renderSimpleTable(out, [
          { label:'Player', key:'player' },
          { label:'Matches', key:'matches', right:true },
          { label:'Elims', key:'elims', right:true },
          { label:'Elims / m', key:'elims_pm', format:'1d', right:true },
          { label:'Damage', key:'damage', right:true },
          { label:'Dmg / m', key:'dmg_pm', format:'1d', right:true },
        ]);
        applyColumnHeatmap('tblPlayerStats', ['elims','elims_pm','damage','dmg_pm','matches']);
      }
    }
  }

  /* ---------- Character + Pet Usage + Per-Player Usage ---------- */
  let loadRows = [];
  let loadCols = null;

  if(payload.loadoutsPack?.rows?.length){
    loadRows = payload.loadoutsPack.rows.slice();
    const keys = payload.loadoutsPack.keys || Object.keys(loadRows[0]||{});
    loadCols = detectLoadoutCols(keys, loadRows);

    // If team col exists, enforce again client-side
    if(loadCols.teamCol){
      const tc = loadCols.teamCol;
      loadRows = loadRows.filter(r => norm(r[tc]).toUpperCase() === teamCode);
    }
  }

  // Character & Pet usage
  {
    const charBox = el('tblTeamCharUsage');
    const petBox  = el('tblTeamPetUsage');

    if(!charBox || !petBox) {} else if(!loadRows.length || !loadCols){
      charBox.innerHTML = '<div class="muted">No loadout rows found (check your loadout/LOPS table / RLS).</div>';
      petBox.innerHTML  = '<div class="muted">No loadout rows found (check your loadout/LOPS table / RLS).</div>';
    }else{
      const { activeCol, passiveCols, petCol } = loadCols;

      // Characters = active + passives
      const charCount = new Map();
      const addChar = (name)=>{
        const k = norm(name);
        if(!k) return;
        charCount.set(k, (charCount.get(k)||0) + 1);
      };

      for(const r of loadRows){
        if(activeCol) addChar(r[activeCol]);
        for(const pk of (passiveCols||[])) addChar(r[pk]);
      }

      const topChars = topNFromMap(charCount, 20).map(([name,count]) => ({ name, count }));
      if(!topChars.length) charBox.innerHTML = '<div class="muted">No character columns detected (active/passives).</div>';
      else{
        const total = topChars.reduce((a,b)=>a+(b.count||0),0) || 0;
        const rows = topChars.map(o=>({ ...o, share: total ? o.count/total : 0 }));
        charBox.innerHTML = renderSimpleTable(rows, [
          { label:'Character', key:'name' },
          { label:'Uses', key:'count', right:true },
          { label:'Share', key:'share', format:'pct', right:true }
        ]);
        applyColumnHeatmap('tblTeamCharUsage', ['count','share']);
      }

      // Pets
      if(!petCol){
        petBox.innerHTML = '<div class="muted">No pet column detected.</div>';
      }else{
        const petCount = countBy(loadRows, r => r[petCol]);
        const petTop = topNFromMap(petCount, 20).map(([name,count]) => ({ name, count }));
        const total = petTop.reduce((a,b)=>a+(b.count||0),0) || 0;
        const rows = petTop.map(o=>({ ...o, share: total ? o.count/total : 0 }));
        petBox.innerHTML = renderSimpleTable(rows, [
          { label:'Pet', key:'name' },
          { label:'Uses', key:'count', right:true },
          { label:'Share', key:'share', format:'pct', right:true }
        ]);
        applyColumnHeatmap('tblTeamPetUsage', ['count','share']);
      }
    }
  }

  // Per-player Active / Passive pivots
  {
    const activeBox = el('tblPerPlayerActive');
    const passiveBox = el('tblPerPlayerPassive');

    if(!activeBox || !passiveBox) {} else if(!loadRows.length || !loadCols){
      activeBox.innerHTML = '<div class="muted">No loadout rows found.</div>';
      passiveBox.innerHTML = '<div class="muted">No loadout rows found.</div>';
    }else{
      const keys = payload.loadoutsPack.keys || Object.keys(loadRows[0]||{});
      const playerCol = detectPlayerCol(keys, loadRows);

      if(!playerCol){
        activeBox.innerHTML = '<div class="muted">Player column not detected in loadout table (need IGN / Player Name).</div>';
        passiveBox.innerHTML = '<div class="muted">Player column not detected in loadout table (need IGN / Player Name).</div>';
      }else{
        const { activeCol, passiveCols } = loadCols;

        // Active matrix
        if(!activeCol){
          activeBox.innerHTML = '<div class="muted">No Active character column detected.</div>';
        }else{
          const mActive = new Map(); // player -> Map(char->count)
          const allActive = new Map(); // char->count
          for(const r of loadRows){
            const p = norm(r[playerCol]) || 'Unknown';
            const c = norm(r[activeCol]);
            if(!c) continue;
            if(!mActive.has(p)) mActive.set(p, new Map());
            const mm = mActive.get(p);
            mm.set(c, (mm.get(c)||0)+1);
            allActive.set(c, (allActive.get(c)||0)+1);
          }
          const players = [...mActive.keys()].sort((a,b)=>a.localeCompare(b));
          const topActive = topNFromMap(allActive, 10).map(([c])=>c);
          renderPivot('tblPerPlayerActive', players, topActive, mActive);
        }

        // Passive matrix (combine all passive columns)
        if(!passiveCols || !passiveCols.length){
          passiveBox.innerHTML = '<div class="muted">No Passive character columns detected.</div>';
        }else{
          const mPass = new Map();
          const allPass = new Map();
          for(const r of loadRows){
            const p = norm(r[playerCol]) || 'Unknown';
            if(!mPass.has(p)) mPass.set(p, new Map());
            const mm = mPass.get(p);

            for(const pk of passiveCols){
              const c = norm(r[pk]);
              if(!c) continue;
              mm.set(c, (mm.get(c)||0)+1);
              allPass.set(c, (allPass.get(c)||0)+1);
            }
          }
          const players = [...mPass.keys()].sort((a,b)=>a.localeCompare(b));
          const topPass = topNFromMap(allPass, 10).map(([c])=>c);
          renderPivot('tblPerPlayerPassive', players, topPass, mPass);
        }
      }
    }
  }

  /* ---------- Elims Focus ---------- */
  {
    const box = el('tblElimsFocus');
    if(!box) {} else if(!payload.elimPack?.rows?.length){
      box.innerHTML = '<div class="muted">No elimination log rows found (check your elim log table / RLS).</div>';
    }else{
      const { rows, keys } = payload.elimPack;

      const killerTeamCol = pickKeyFrom(keys, [/killer.*tag/i, /killer.*team/i, /^killer_tag$/i, /^killer_team$/i, /^attacker_tag$/i, /^attacker_team$/i]);
      const victimTeamCol = pickKeyFrom(keys, [/victim.*tag/i, /victim.*team/i, /^victim_tag$/i, /^victim_team$/i, /^downed_tag$/i, /^downed_team$/i]);
      const killerPlayerCol = pickKeyFrom(keys, [/killer.*ign/i, /killer.*player/i, /^killer$/i, /^attacker$/i]);
      const victimPlayerCol = pickKeyFrom(keys, [/victim.*ign/i, /victim.*player/i, /^victim$/i, /^downed$/i]);

      const kills = rows.filter(r => killerTeamCol && norm(r[killerTeamCol]).toUpperCase() === teamCode);
      const deaths = rows.filter(r => victimTeamCol && norm(r[victimTeamCol]).toUpperCase() === teamCode);

      const killsVs = victimTeamCol
        ? topNFromMap(countBy(kills, r => r[victimTeamCol]), 12).map(([team,count]) => ({ team, count }))
        : [];
      const deathsVs = killerTeamCol
        ? topNFromMap(countBy(deaths, r => r[killerTeamCol]), 12).map(([team,count]) => ({ team, count }))
        : [];

      const topFraggers = killerPlayerCol
        ? topNFromMap(countBy(kills, r => r[killerPlayerCol]), 12).map(([player,count]) => ({ player, count }))
        : [];
      const mostDowned = victimPlayerCol
        ? topNFromMap(countBy(deaths, r => r[victimPlayerCol]), 12).map(([player,count]) => ({ player, count }))
        : [];

      const tbl1 = killsVs.length
        ? renderSimpleTable(killsVs, [{label:'Enemy Team', key:'team'}, {label:'Elims', key:'count', right:true}])
        : '<div class="muted">No “kills vs teams” breakdown (missing victim team column).</div>';

      const tbl2 = deathsVs.length
        ? renderSimpleTable(deathsVs, [{label:'Enemy Team', key:'team'}, {label:'Deaths', key:'count', right:true}])
        : '<div class="muted">No “deaths to teams” breakdown (missing killer team column).</div>';

      const tbl3 = topFraggers.length
        ? renderSimpleTable(topFraggers, [{label:'Player', key:'player'}, {label:'Elims', key:'count', right:true}])
        : '<div class="muted">No “top fraggers” breakdown (missing killer player column).</div>';

      const tbl4 = mostDowned.length
        ? renderSimpleTable(mostDowned, [{label:'Player', key:'player'}, {label:'Deaths', key:'count', right:true}])
        : '<div class="muted">No “most eliminated” breakdown (missing victim player column).</div>';

      box.innerHTML = `
        <div class="grid2">
          <div class="card" style="margin:0">
            <h3>Kills vs Teams</h3>
            <div id="elimsKillsVs">${tbl1}</div>
          </div>
          <div class="card" style="margin:0">
            <h3>Deaths to Teams</h3>
            <div id="elimsDeathsVs">${tbl2}</div>
          </div>
        </div>
        <div style="height:12px"></div>
        <div class="grid2">
          <div class="card" style="margin:0">
            <h3>Top Fraggers</h3>
            <div id="elimsFraggers">${tbl3}</div>
          </div>
          <div class="card" style="margin:0">
            <h3>Most Eliminated Players</h3>
            <div id="elimsDowned">${tbl4}</div>
          </div>
        </div>
      `;

      // Heatmaps (if present)
      try{
        applyColumnHeatmap('elimsKillsVs', ['count']);
        applyColumnHeatmap('elimsDeathsVs', ['count']);
        applyColumnHeatmap('elimsFraggers', ['count']);
        applyColumnHeatmap('elimsDowned', ['count']);
      }catch{}
    }
  }
}

/* ---------- Single team render ---------- */
function kpiAndByMap(){
  if(!CURRENT_TEAM){
    const tTitle = el('teamTitle'); if(tTitle) tTitle.textContent='Selected Team — Overview';
    const idBody = el('identityBody'); if(idBody) idBody.innerHTML='Select a team.';
    const kpiBody = el('kpiBody'); if(kpiBody) kpiBody.innerHTML='—';
    updateAiPrompt();
    return;
  }
  el('teamTitle').textContent = `Selected Team — Overview`;
  el('identityBody').innerHTML = `
    <div style="display:flex;gap:12px;align-items:center">
      <img src="${CURRENT_TEAM.logo}" alt="${CURRENT_TEAM.fullname} logo" style="width:72px;height:72px;object-fit:contain" onerror="this.style.visibility='hidden'">
      <div>
        <div style="font-size:1.1rem;font-weight:800">${CURRENT_TEAM.name}</div>
        <div class="muted">${CURRENT_TEAM.fullname} • ${CURRENT_TEAM.region||'—'} ${CURRENT_TEAM.ew?('• '+CURRENT_TEAM.ew):''}</div>
      </div>
    </div>`;

  const k=kpiDataset(TEAM_ROWS);
  el('kpiBody').innerHTML = k.matches ? `
    <div class="kpis">
      <div class="kpi">Rows <strong>${k.matches}</strong></div>
      <div class="kpi">Booyahs <strong>${k.booyahs}</strong> (<strong>${fmtPct(k.booyah_rate)}</strong>)</div>
      <div class="kpi">Elims <strong>${k.elims}</strong> • <strong>${k.elims_per_match.toFixed(1)}</strong>/m</div>
      <div class="kpi">Placement <strong>${k.placement}</strong> • <strong>${k.place_per_match.toFixed(1)}</strong>/m</div>
      <div class="kpi">Total <strong>${k.total}</strong> • <strong>${k.total_per_match.toFixed(1)}</strong>/m</div>
      <div class="kpi">Top3 <strong>${fmtPct(k.top3_rate)}</strong></div>
      <div class="kpi">Last Played <strong>${fmtYwdm(latestYwdm(TEAM_ROWS))}</strong></div>
    </div>` : '<div class="muted">No rows.</div>';

  const rows=teamMapPerf(TEAM_ROWS);
  const mapWrap = document.getElementById('tblMapTeam');
  if(mapWrap){
    mapWrap.innerHTML = renderSimpleTable(rows, [
      {label:'Map',key:'map'},
      {label:'Matches',key:'matches',right:true},
      {label:'Booyahs',key:'booyahs',right:true},
      {label:'Elims',key:'elims',right:true},
      {label:'Placement',key:'placement',right:true},
      {label:'Total',key:'total',right:true},
      {label:'Booyah %',key:'booyah_rate',format:'pct',right:true},
      {label:'Elims / m',key:'elims_pm',format:'1d',right:true},
      {label:'Placement / m',key:'placement_pm',format:'1d',right:true},
      {label:'Total / m',key:'total_pm',format:'1d',right:true}
    ]);
    applyColumnHeatmap('tblMapTeam', ['total_pm','placement_pm','elims_pm','booyah_rate','matches','booyahs','elims','placement','total']);
  }
  renderByDayInto('tblByDay', TEAM_ROWS);
  updateAiPrompt();
}

/* Sorting helper */
function sortRows(rows, key, dir, isText=false){
  if(isText){
    return rows.sort((a,b)=> dir==='desc'
      ? (String(b[key]||'').localeCompare(String(a[key]||'')))
      : (String(a[key]||'').localeCompare(String(b[key]||''))));
  }
  return rows.sort((a,b)=> dir==='desc'
    ? ((b[key]??0) - (a[key]??0))
    : ((a[key]??0) - (b[key]??0)));
}

/* Overall / Per-map (global) */
function renderOverall(){
  const rows = aggregateOverall(baseRows(ALL));
  const sortKey = el('overallSortKey').value;
  const dir = el('overallSortDir').dataset.dir;
  if (sortKey==='team') sortRows(rows, 'team', dir, true);
  else sortRows(rows, sortKey, dir, false);

  el('tblOverall').innerHTML = renderSimpleTable(rows, [
    {label:'Team',key:'team'},
    {label:'Code',key:'code'},
    {label:'E/W',key:'ew', className:'col-ew'},
    {label:'Region',key:'region', className:'col-region'},
    {label:'Matches',key:'matches',right:true},
    {label:'Booyahs',key:'booyahs',right:true},
    {label:'Elims',key:'elims',right:true},
    {label:'Placement',key:'placement',right:true},
    {label:'Total',key:'total',right:true},
    {label:'Booyah %',key:'booyah_rate',format:'pct',right:true},
    {label:'Elims/m',key:'elims_pm',format:'1d',right:true},
    {label:'Place/m',key:'placement_pm',format:'1d',right:true},
    {label:'Total/m',key:'total_pm',format:'1d',right:true},
    {label:'Top3%',key:'top3_rate',format:'pct',right:true},
  ]);
  applyColumnHeatmap('tblOverall', ['total_pm','elims_pm','placement_pm','booyah_rate','matches','booyahs','elims','placement','total']);
}
function renderPerMapAllTeams(){
  const base = baseRows(ALL);
  const mapSel=el('mapFilter').value;
  const rows = aggregateTeamsForMap(base, mapSel);
  const sortKey = el('perMapSortKey').value;
  const dir = el('perMapSortDir').dataset.dir;
  if (sortKey==='team') sortRows(rows, 'team', dir, true);
  else sortRows(rows, sortKey, dir, false);
  el('tblPerMapAllTeams').innerHTML = renderSimpleTable(rows, [
    {label:'Team',key:'team'},
    {label:'Code',key:'code'},
    {label:'E/W',key:'ew', className:'col-ew'},
    {label:'Region',key:'region', className:'col-region'},
    {label:'Matches',key:'matches',right:true},
    {label:'Booyahs',key:'booyahs',right:true},
    {label:'Elims',key:'elims',right:true},
    {label:'Placement',key:'placement',right:true},
    {label:'Total',key:'total',right:true},
    {label:'Booyah %',key:'booyah_rate',format:'pct',right:true},
    {label:'Elims/m',key:'elims_pm',format:'1d',right:true},
    {label:'Place/m',key:'placement_pm',format:'1d',right:true},
    {label:'Total/m',key:'total_pm',format:'1d',right:true},
    {label:'Top3%',key:'top3_rate',format:'pct',right:true},
  ]);
  applyColumnHeatmap('tblPerMapAllTeams', ['total_pm','placement_pm','elims_pm','booyah_rate','matches','booyahs','elims','placement','total']);
}

/* Team grid */
function renderTeamGrid(filter=''){
  const grid=el('teamGrid');
  const q=(filter||'').trim().toLowerCase();
  const items=TEAMS.filter(t=>[t.name,t.fullname,t.region,t.ew,t.alt].join(' ').toLowerCase().includes(q));
  if(!items.length){
    grid.innerHTML='<div class="muted">No matches.</div>';
    return;
  }
  grid.innerHTML = items.map(t=>`
    <div class="team-tile" data-code="${t.name}" title="${t.fullname}">
      <img class="team-logo" src="${t.logo}" alt="${t.fullname} logo" loading="lazy" onerror="this.style.visibility='hidden'">
      <div class="team-code">${t.name}</div>
    </div>`).join('');
  grid.querySelectorAll('.team-tile').forEach(tile=>{
    tile.onclick=async ()=>{
      const code=tile.getAttribute('data-code').toLowerCase();
      const info=TEAM_BY_CODE[code];
      if(!info) return;

      if(SPLIT_MODE){
        await selectTeamForSide(SPLIT_ACTIVE_SIDE, info);
      }else{
        await selectTeam(info);
        tile.scrollIntoView({behavior:'smooth',inline:'center',block:'nearest'});
      }
    };
  });
  highlightActiveTiles();
}
function highlightActiveTiles(){
  const grid=el('teamGrid'); if(!grid) return;
  const a = TEAM_A?.name || null;
  const b = TEAM_B?.name || null;

  [...grid.querySelectorAll('.team-tile')].forEach(div=>{
    const code=div.getAttribute('data-code');
    div.classList.remove('active','activeA','activeB');
    if(SPLIT_MODE){
      if(a && code===a) div.classList.add('activeA');
      if(b && code===b) div.classList.add('activeB');
    }else{
      div.classList.toggle('active', !!CURRENT_TEAM && CURRENT_TEAM.name===code);
    }
  });
}

/* Single team select */
async function selectTeam(teamObj){
  CURRENT_TEAM = teamObj;
  const url=new URL(window.location.href);
  url.searchParams.set('team', CURRENT_TEAM.name);
  history.replaceState(null,'',url.toString());

  TEAM_ROWS = baseRows(ALL).filter(
    r => (norm(r._tag).toUpperCase()||'') === teamObj.name.toUpperCase()
  );

  kpiAndByMap();
  highlightActiveTiles();

  const [info, roster] = await Promise.all([
    fetchTeamInfoBy(teamObj.name),
    fetchPlayersBy(teamObj.name)
  ]);

  TEAM_INFO = info || null;
  TEAM_PLAYERS = roster || [];

  renderTeamInfo(info);
  renderRoster(roster);
  updateAiPrompt();
  
  await loadAdvancedForCurrentTeam();

}

/* Split view */
function populateSplitSelects(){
  const selA = el('splitSelA');
  const selB = el('splitSelB');
  if(!selA || !selB) return;

  const opts = TEAMS.map(t => `<option value="${t.name}">${t.name} — ${t.fullname}</option>`).join('');
  selA.innerHTML = `<option value="">—</option>` + opts;
  selB.innerHTML = `<option value="">—</option>` + opts;

  if(TEAM_A?.name) selA.value = TEAM_A.name;
  if(TEAM_B?.name) selB.value = TEAM_B.name;
}
async function selectTeamForSide(side, teamObj){
  if(!teamObj) return;
  if(side==='A') TEAM_A = teamObj;
  else TEAM_B = teamObj;

  const rows = baseRows(ALL).filter(r => (norm(r._tag).toUpperCase()||'') === teamObj.name.toUpperCase());
  if(side==='A') ROWS_A = rows;
  else ROWS_B = rows;

  renderSplitSide(side);
  populateSplitSelects();
  highlightActiveTiles();
}
function renderSplitSide(side){
  const team = side==='A' ? TEAM_A : TEAM_B;
  const rows = side==='A' ? ROWS_A : ROWS_B;

  const idIdentity = side==='A' ? 'splitIdentityA' : 'splitIdentityB';
  const idKpis     = side==='A' ? 'splitKpisA'     : 'splitKpisB';
  const idMap      = side==='A' ? 'splitMapA'      : 'splitMapB';
  const idDay      = side==='A' ? 'splitDayA'      : 'splitDayB';

  if(!team){
    el(idIdentity).innerHTML = '<div class="muted">Select a team.</div>';
    el(idKpis).innerHTML = '—';
    el(idMap).innerHTML = '—';
    el(idDay).innerHTML = '—';
    return;
  }

  el(idIdentity).innerHTML = `
    <div style="display:flex;gap:12px;align-items:center">
      <img src="${team.logo}" alt="${team.fullname} logo" style="width:64px;height:64px;object-fit:contain" onerror="this.style.visibility='hidden'">
      <div>
        <div style="font-size:1.05rem;font-weight:900">${team.name}</div>
        <div class="muted">${team.fullname} • ${team.region||'—'} ${team.ew?('• '+team.ew):''}</div>
      </div>
    </div>`;

  const k = kpiDataset(rows);
  el(idKpis).innerHTML = k.matches ? `
    <div class="kpis">
      <div class="kpi">Rows <strong>${k.matches}</strong></div>
      <div class="kpi">Booyahs <strong>${k.booyahs}</strong> (<strong>${fmtPct(k.booyah_rate)}</strong>)</div>
      <div class="kpi">Elims <strong>${k.elims}</strong> • <strong>${k.elims_per_match.toFixed(1)}</strong>/m</div>
      <div class="kpi">Placement <strong>${k.placement}</strong> • <strong>${k.place_per_match.toFixed(1)}</strong>/m</div>
      <div class="kpi">Total <strong>${k.total}</strong> • <strong>${k.total_per_match.toFixed(1)}</strong>/m</div>
      <div class="kpi">Top3 <strong>${fmtPct(k.top3_rate)}</strong></div>
      <div class="kpi">Last Played <strong>${fmtYwdm(latestYwdm(rows))}</strong></div>
    </div>` : '<div class="muted">No rows.</div>';

  const mapRows = teamMapPerf(rows);
  el(idMap).innerHTML = renderSimpleTable(mapRows, [
    {label:'Map',key:'map'},
    {label:'Matches',key:'matches',right:true},
    {label:'Booyahs',key:'booyahs',right:true},
    {label:'Elims',key:'elims',right:true},
    {label:'Placement',key:'placement',right:true},
    {label:'Total',key:'total',right:true},
    {label:'Booyah %',key:'booyah_rate',format:'pct',right:true},
    {label:'Elims / m',key:'elims_pm',format:'1d',right:true},
    {label:'Placement / m',key:'placement_pm',format:'1d',right:true},
    {label:'Total / m',key:'total_pm',format:'1d',right:true}
  ]);
  applyColumnHeatmap(idMap, ['total_pm','placement_pm','elims_pm','booyah_rate','matches','booyahs','elims','placement','total']);

  renderByDayInto(idDay, rows);
}
function updateSplitPickUI(){
  const aBtn = el('pickSideA'), bBtn = el('pickSideB');
  const chip = el('splitActiveChip');
  if(!aBtn || !bBtn) return;
  aBtn.classList.toggle('onA', SPLIT_ACTIVE_SIDE==='A');
  bBtn.classList.toggle('onB', SPLIT_ACTIVE_SIDE==='B');
  if(chip) chip.textContent = `Active pick: ${SPLIT_ACTIVE_SIDE==='A' ? 'Left' : 'Right'}`;
}
function setSplitMode(on){
  SPLIT_MODE = !!on;

  setVisible('splitSection', SPLIT_MODE);
  setVisible('splitPickChip', SPLIT_MODE);
  el('splitResetBtn').style.display = SPLIT_MODE ? '' : 'none';
  el('splitToggleBtn').textContent = SPLIT_MODE ? 'Single View' : 'Split View';

  // hide single-team-only blocks while split is on
  setVisible('teamHeader', !SPLIT_MODE);
  setVisible('teamInfoSection', !SPLIT_MODE);
  setVisible('mapsDaysSection', !SPLIT_MODE);
  setVisible('teamRosterSection', !SPLIT_MODE);
  setVisible('aiAnalysisSection', !SPLIT_MODE);

  updateSplitPickUI();
  highlightActiveTiles();
}

/* Controls */
function populateMapFilter(){
  el('mapFilter').innerHTML =
    `<option value="__all__">All maps</option>` +
    uniqueMaps(baseRows(ALL)).map(m=>`<option>${m}</option>`).join('');
}

async function refreshScopeAfterFilterChange(){
  updateFilterHint();
  updateTeamsForCurrentScope();
  populateMapFilter();
  renderOverall();
  renderPerMapAllTeams();

  if(SPLIT_MODE){
    // keep same teams if still present; else pick first two
    const aOk = TEAM_A && ALLOWED_TAGS.has(TEAM_A.name.toUpperCase());
    const bOk = TEAM_B && ALLOWED_TAGS.has(TEAM_B.name.toUpperCase());

    let nextA = aOk ? TEAM_A : (TEAMS[0] || null);
    let nextB = bOk ? TEAM_B : (TEAMS[1] || TEAMS[0] || null);

    if(nextA && nextB && nextA.name===nextB.name){
      nextB = TEAMS.find(t => t.name!==nextA.name) || nextB;
    }

    await selectTeamForSide('A', nextA);
    await selectTeamForSide('B', nextB);
    return;
  }

  // single view behavior
  let nextTeam = null;
  if (CURRENT_TEAM && ALLOWED_TAGS.has(CURRENT_TEAM.name.toUpperCase())){
    nextTeam = CURRENT_TEAM;
  }else if (TEAMS.length){
    nextTeam = TEAMS[0];
  }else{
    CURRENT_TEAM = null;
  }

  if(nextTeam){
    await selectTeam(nextTeam);
  }else{
    TEAM_ROWS = [];
    TEAM_INFO = null;
    TEAM_PLAYERS = [];
    const ident = el('identityBody'); if(ident) ident.innerHTML='Select a team.';
    const kpiBody = el('kpiBody'); if(kpiBody) kpiBody.innerHTML='—';
    const tblMapTeam = el('tblMapTeam'); if(tblMapTeam) tblMapTeam.innerHTML='—';
    const tblByDay = el('tblByDay'); if(tblByDay) tblByDay.innerHTML='—';
    const teamInfoBody = el('teamInfoBody'); if(teamInfoBody) teamInfoBody.innerHTML='<div class="muted">No team info found.</div>';
    const teamRosterBody = el('teamRosterBody'); if(teamRosterBody) teamRosterBody.innerHTML='<div class="muted">No players found.</div>';
    updateAiPrompt();
  }
}

async function copyAiPrompt(){
  const ta = el('aiPrompt');
  const status = el('aiCopyStatus');
  if(!ta) return;
  const text = ta.value || '';
  if(!text.trim()){
    if(status) status.textContent = 'Nothing to copy yet.';
    return;
  }
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(text);
    }else{
      ta.focus();
      ta.select();
      document.execCommand('copy');
    }
    if(status) status.textContent = 'Copied prompt to clipboard.';
  }catch(err){
    console.error('Clipboard error', err);
    if(status) status.textContent = 'Copy failed — please select and copy manually.';
  }
  setTimeout(()=>{ if(status) status.textContent=''; }, 4000);
}

function wireControls(){
  el('gYear').addEventListener('change', async ()=>{
    populateSeasonFilter();
    populateTournamentFilter();
    populateStageFilter(true);
    await refreshScopeAfterFilterChange();
  });

  el('gSeason').addEventListener('change', async ()=>{
    populateTournamentFilter();
    populateStageFilter(true);
    await refreshScopeAfterFilterChange();
  });

  el('gTournament').addEventListener('change', async ()=>{
    populateStageFilter(true);
    await refreshScopeAfterFilterChange();
  });

  el('gStage').addEventListener('change', async ()=>{
    await refreshScopeAfterFilterChange();
  });

  el('gTournReset').addEventListener('click', async ()=>{
    populateYearFilter();
    populateSeasonFilter();
    populateTournamentFilter();
    populateStageFilter(true);
    await refreshScopeAfterFilterChange();
  });

  el('overallSortKey').addEventListener('change', renderOverall);
  el('overallSortDir').addEventListener('click', ()=>{
    const b=el('overallSortDir');
    const cur=b.dataset.dir==='desc'?'asc':'desc';
    b.dataset.dir=cur;
    b.textContent=cur==='desc'?'Desc':'Asc';
    renderOverall();
  });
  el('overallReset').addEventListener('click', ()=>{
    el('overallSortKey').value='total';
    el('overallSortDir').dataset.dir='desc';
    el('overallSortDir').textContent='Desc';
    renderOverall();
  });

  el('mapFilter').addEventListener('change', renderPerMapAllTeams);
  el('perMapSortKey').addEventListener('change', renderPerMapAllTeams);
  el('perMapSortDir').addEventListener('click', ()=>{
    const b=el('perMapSortDir');
    const cur=b.dataset.dir==='desc'?'asc':'desc';
    b.dataset.dir=cur;
    b.textContent=cur==='desc'?'Desc':'Asc';
    renderPerMapAllTeams();
  });
  el('perMapReset').addEventListener('click', ()=>{
    el('mapFilter').value='__all__';
    el('perMapSortKey').value='total';
    el('perMapSortDir').dataset.dir='desc';
    el('perMapSortDir').textContent='Desc';
    renderPerMapAllTeams();
  });

  el('teamSearch').addEventListener('input', e=> renderTeamGrid(e.target.value||''));

  const copyBtn = el('copyAiPromptBtn');
  if(copyBtn) copyBtn.addEventListener('click', copyAiPrompt);
  const refreshBtn = el('refreshAiPromptBtn');
  if(refreshBtn) refreshBtn.addEventListener('click', updateAiPrompt);

  /* Split controls */
  el('splitToggleBtn').addEventListener('click', async ()=>{
    setSplitMode(!SPLIT_MODE);

    if(SPLIT_MODE){
      // choose defaults
      const a = CURRENT_TEAM || TEAMS[0] || null;
      const b = TEAMS.find(t => !a || t.name!==a.name) || TEAMS[1] || a || null;

      await selectTeamForSide('A', a);
      await selectTeamForSide('B', b);

      // keep selects in sync
      populateSplitSelects();
    }else{
      // back to single view: keep left as current if possible
      const back = TEAM_A || CURRENT_TEAM || TEAMS[0] || null;
      if(back) await selectTeam(back);
      updateAiPrompt();
    }
  });

  el('splitResetBtn').addEventListener('click', async ()=>{
    const a = TEAMS[0] || null;
    const b = TEAMS[1] || TEAMS[0] || null;
    await selectTeamForSide('A', a);
    await selectTeamForSide('B', b);
  });

  el('pickSideA').addEventListener('click', ()=>{
    SPLIT_ACTIVE_SIDE='A';
    updateSplitPickUI();
  });
  el('pickSideB').addEventListener('click', ()=>{
    SPLIT_ACTIVE_SIDE='B';
    updateSplitPickUI();
  });

  el('splitSelA').addEventListener('change', async (e)=>{
    const code = (e.target.value||'').toLowerCase();
    const t = TEAM_BY_CODE[code];
    if(t) await selectTeamForSide('A', t);
  });
  el('splitSelB').addEventListener('change', async (e)=>{
    const code = (e.target.value||'').toLowerCase();
    const t = TEAM_BY_CODE[code];
    if(t) await selectTeamForSide('B', t);
  });
}

/* ---------- Init ---------- */
async function initial(){
  try{
    el('scopeChip').textContent='Scope: —';
    el('scopeChipTeam').textContent='—';

    ALL = await fetchAllRows();
    HELPER_TEAMS = await fetchHelperTeams();
    buildHelperIndex();

    // Default filters
    populateYearFilter();           // default 2025 if available
    populateSeasonFilter();         // default Global Finals if available
    populateTournamentFilter();     // default ALL tournaments
    populateStageFilter(true);      // default latest stage in scope

    updateFilterHint();
    updateTeamsForCurrentScope();
    populateMapFilter();

    el('overallSortDir').dataset.dir='desc';
    el('overallSortDir').textContent='Desc';
    el('perMapSortDir').dataset.dir='desc';
    el('perMapSortDir').textContent='Desc';
    renderOverall();
    renderPerMapAllTeams();

    const url=new URL(window.location.href);
    const qTeam=(url.searchParams.get('team')||'').trim().toLowerCase();
    let starter=null;
    if(qTeam && TEAM_BY_CODE[qTeam]) starter=TEAM_BY_CODE[qTeam];
    else if(TEAMS.length) starter=TEAMS[0];

    if(starter) await selectTeam(starter);
    else updateAiPrompt();

    wireControls();
    document.querySelectorAll('details.accordion').forEach(d=> d.open=false);
    setSplitMode(false);
    el('veil').classList.add('hide');
  }catch(e){
    gerr('Fatal error initializing page:\n\n'+(e.stack||e.message||e));
    el('veil').classList.add('hide');
  }
}
initial();
</script>
</body>
</html>
