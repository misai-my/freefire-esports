<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>JSON → Table → Supabase Uploader</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root{
      --bg:#07090f; --bg2:#0b1020;
      --panel: rgba(20, 26, 38, .72);
      --panel2: rgba(14, 18, 28, .70);
      --line: rgba(255,255,255,.10);
      --ink:#f4f6ff; --muted:#aab1c5;
      --brand:#ffbd59; --brand2:#ff7733; --accent:#4dd3ff;
      --radius:16px; --radius-lg:22px;
      --shadow: 0 22px 70px rgba(0,0,0,.55);
      --good:#71d083; --bad:#ff6b6b;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--ink);
      background:
        radial-gradient(1200px 700px at 15% -10%, rgba(77,211,255,.18), transparent 60%),
        radial-gradient(900px 600px at 90% 0%, rgba(255,189,89,.20), transparent 55%),
        radial-gradient(900px 600px at 80% 110%, rgba(255,119,51,.16), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      font-family:var(--sans);
      overflow-x:hidden;
    }
    header{
      position:sticky; top:0; z-index:50;
      backdrop-filter: blur(12px);
      background: linear-gradient(180deg, rgba(7,9,15,.80), rgba(7,9,15,.55));
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1280px;margin:0 auto;padding:14px 16px}
    .topbar{display:flex;gap:12px;align-items:center;justify-content:space-between}
    .brand{display:flex;align-items:center;gap:12px}
    .badge{
      width:40px;height:40px;border-radius:14px;
      background: radial-gradient(circle at 30% 30%, rgba(255,189,89,.9), rgba(255,119,51,.7));
      box-shadow: 0 14px 40px rgba(255,189,89,.18);
    }
    h1{font-size:16px;margin:0;letter-spacing:.3px}
    .sub{font-size:12px;color:var(--muted);margin-top:2px}
    .actions{display:flex;gap:10px;flex-wrap:wrap}
    .btn, input, select, textarea{font-family:inherit}
    .btn{
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color:var(--ink);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
      user-select:none;
    }
    .btn:hover{border-color: rgba(255,255,255,.16); background: rgba(255,255,255,.05)}
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      border-color: rgba(255,189,89,.35);
      background: linear-gradient(180deg, rgba(255,189,89,.16), rgba(255,119,51,.10));
    }
    .btn.good{
      border-color: rgba(113,208,131,.35);
      background: linear-gradient(180deg, rgba(113,208,131,.16), rgba(113,208,131,.08));
    }
    .btn.bad{
      border-color: rgba(255,107,107,.35);
      background: linear-gradient(180deg, rgba(255,107,107,.16), rgba(255,107,107,.08));
    }

    main{max-width:1280px;margin:0 auto;padding:16px}
    .grid{display:grid;grid-template-columns: 1.05fr .95fr;gap:14px}
    @media (max-width: 980px){ .grid{grid-template-columns:1fr} }

    .card{
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid var(--line);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex;align-items:center;justify-content:space-between;gap:10px;
    }
    .card .hd h2{font-size:14px;margin:0;letter-spacing:.25px}
    .card .bd{padding:14px}

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .row + .row{margin-top:10px}

    .field{display:flex;flex-direction:column;gap:6px;min-width:220px;flex:1}
    label{font-size:12px;color:var(--muted)}
    input[type="text"], input[type="password"], input[type="url"], select, textarea{
      width:100%;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: var(--ink);
      border-radius: 12px;
      padding:10px 10px;
      outline:none;
    }
    textarea{
      font-family: var(--mono);
      min-height: 260px;
      resize: vertical;
      line-height:1.35;
    }
    input:focus, textarea:focus, select:focus{
      border-color: rgba(77,211,255,.45);
      box-shadow: 0 0 0 3px rgba(77,211,255,.12);
    }
    .hint{font-size:12px;color:var(--muted);line-height:1.3}
    .pill{
      font-size:12px; padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color:var(--ink);
      display:inline-flex;gap:8px;align-items:center;
    }
    .dot{width:8px;height:8px;border-radius:50%}
    .dot.good{background:var(--good)}
    .dot.bad{background:var(--bad)}
    .dot.neutral{background:var(--accent)}

    .split{display:grid;grid-template-columns: 1fr 1fr;gap:10px}
    @media (max-width: 980px){ .split{grid-template-columns:1fr} }

    .tablewrap{
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(0,0,0,.22);
    }
    table{width:100%;border-collapse:collapse;font-size:12px}
    thead th{
      position: sticky; top: 0;
      background: rgba(7,9,15,.92);
      border-bottom:1px solid rgba(255,255,255,.10);
      padding:10px 10px;
      text-align:left;
      white-space:nowrap;
      z-index:2;
    }
    tbody td{
      border-top:1px solid rgba(255,255,255,.06);
      padding:8px 10px;
      vertical-align:top;
      max-width: 380px;
      word-break: break-word;
      color: rgba(244,246,255,.92);
    }
    tbody tr:hover td{background: rgba(255,255,255,.03)}

    .small{font-size:11px;color:var(--muted)}
    .kbd{
      font-family:var(--mono);
      font-size:11px;
      padding:3px 7px;border-radius:8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color: rgba(244,246,255,.88);
    }

    .colbox{
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      background: rgba(0,0,0,.18);
      overflow:hidden;
    }
    .colbox .colhd{
      display:flex;align-items:center;justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }
    .colbox .colbd{max-height: 260px;overflow:auto}
    .colrow{
      display:grid;
      grid-template-columns: 26px 1fr 1fr;
      gap:10px;
      padding:8px 12px;
      border-top:1px solid rgba(255,255,255,.06);
      align-items:center;
    }
    .colrow:first-child{border-top:0}
    .colrow input[type="text"]{padding:8px 9px;border-radius:10px}
    .colrow .k{font-family:var(--mono);font-size:11px;color:rgba(244,246,255,.90)}
    .status{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      font-size:12px;
      color: rgba(244,246,255,.92);
      line-height:1.35;
      white-space:pre-wrap;
    }
    .progress{
      height:10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      overflow:hidden;
      margin-top:10px;
    }
    .bar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(77,211,255,.75), rgba(255,189,89,.72), rgba(255,119,51,.72));
      transition: width .2s ease;
    }

    .checkrow{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      background: rgba(0,0,0,.18);
    }
    .checkrow input{width:auto}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="badge"></div>
        <div>
          <h1>JSON → Table → Supabase</h1>
          <div class="sub">Paste / upload JSON, auto-detect arrays-of-objects, preview datasets, then insert/upsert into Supabase.</div>
        </div>
      </div>
      <div class="actions">
        <button class="btn" id="btnSample">Load sample</button>
        <button class="btn bad" id="btnClear">Clear</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="grid">

    <!-- LEFT -->
    <section class="card">
      <div class="hd">
        <h2>1) JSON Input</h2>
        <div class="pill" id="pillState"><span class="dot neutral"></span><span id="pillText">Waiting for JSON</span></div>
      </div>
      <div class="bd">
        <div class="row">
          <div class="field" style="min-width:280px">
            <label>Paste JSON</label>
            <textarea id="jsonText" placeholder='Paste JSON here (array or object)…'></textarea>
            <div class="hint">
              If your JSON is a big object, set <span class="kbd">Records array path</span> to where the base records live (example: <span class="kbd">data.matches</span>).
            </div>
          </div>
        </div>

        <div class="row">
          <div class="field" style="min-width:260px;flex:1.2">
            <label>Records array path (optional)</label>
            <input id="pathText" type="text" placeholder="e.g. data.matches"/>
            <div class="hint">Leave blank to auto-detect the first array of objects.</div>
          </div>
          <div class="field" style="min-width:160px;flex:.6">
            <label>Max preview rows</label>
            <select id="maxRows">
              <option value="50">50</option>
              <option value="200">200</option>
              <option value="500">500</option>
              <option value="2000" selected>2000</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="field" style="min-width:220px;flex:.8">
            <label>Flatten arrays of objects</label>
            <select id="arrMode">
              <option value="keep" selected>Keep as JSON (default)</option>
              <option value="index">Explode to columns with [index] (teams[0].tag)</option>
            </select>
            <div class="hint">Index mode is good for small fixed arrays. For stats tables, use datasets (auto-detect) below.</div>
          </div>

          <div class="field" style="min-width:260px;flex:1.2">
            <label>Additional explode paths (optional, comma-separated)</label>
            <input id="explodePaths" type="text" value="" placeholder="e.g. player_stats, match.match_stats_extra.circle_info"/>
            <div class="hint">Optional overrides/additions. If Auto-detect is ON, you don’t need to type these.</div>
          </div>
        </div>

        <div class="row">
          <div class="field" style="min-width:220px">
            <label>Auto-detect explode datasets</label>
            <div class="checkrow">
              <input id="autoExplode" type="checkbox" checked />
              <div>
                <div style="font-size:12px">Auto-detect every <span class="kbd">array of objects</span> and create separate datasets</div>
                <div class="small">No more setting explode paths one by one. Switch datasets on the right.</div>
              </div>
            </div>
          </div>

          <div class="field" style="min-width:220px">
            <label>Carry match_id automatically</label>
            <div class="checkrow">
              <input id="autoMatchId" type="checkbox" checked />
              <div>
                <div style="font-size:12px">Try to infer <span class="kbd">match_id</span> from common paths</div>
                <div class="small">Works for <span class="kbd">match.match_id</span>, <span class="kbd">data.matches[0].match_id</span>, etc.</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Default columns -->
        <div class="row">
          <div class="field">
            <label>Default Mode column value</label>
            <input id="defMode" type="text" placeholder="e.g. BR / CS / scrim"/>
          </div>
          <div class="field">
            <label>Default Tournament column value</label>
            <input id="defTournament" type="text" placeholder="e.g. FFWS Global Finals 2025"/>
          </div>
        </div>
        <div class="row">
          <div class="field">
            <label>Default Stage column value</label>
            <input id="defStage" type="text" placeholder="e.g. Finals / Group Stage"/>
          </div>
          <div class="field">
            <label>Default Year column value</label>
            <input id="defYear" type="text" placeholder="e.g. 2026"/>
          </div>
        </div>

        <!-- Week/Day -->
        <div class="row">
          <div class="field">
            <label>Default Week column value</label>
            <input id="defWeek" type="text" placeholder="e.g. W1 / Week 1 / 1"/>
          </div>
          <div class="field">
            <label>Default Day column value</label>
            <input id="defDay" type="text" placeholder="e.g. D1 / Day 1 / 1"/>
          </div>
        </div>

        <!-- match_id -->
        <div class="row">
          <div class="field">
            <label>Default match_id column value</label>
            <input id="defMatchId" type="text" placeholder="e.g. 1725487677733611520"/>
          </div>
        </div>

        <div class="hint">
          Default columns (<span class="kbd">Mode</span>, <span class="kbd">Tournament</span>, <span class="kbd">Stage</span>, <span class="kbd">Year</span>, <span class="kbd">Week</span>, <span class="kbd">Day</span>, <span class="kbd">match_id</span>)
          are applied to every row in every dataset.
          <br/><br/>
          <b>Auto-rename for DB is ON:</b> keys like <span class="kbd">player_stats.account_id</span> become <span class="kbd">player_stats_account_id</span> automatically for preview & upload.
        </div>

        <div class="row">
          <div class="field" style="min-width:260px">
            <label>Load JSON file</label>
            <input id="fileInput" type="file" accept=".json,application/json"/>
          </div>
          <div class="field" style="min-width:260px">
            <label>Fetch JSON from URL</label>
            <div class="row" style="gap:8px;flex-wrap:nowrap">
              <input id="fetchUrl" type="url" placeholder="https://example.com/data.json"/>
              <button class="btn" id="btnFetch">Fetch</button>
            </div>
            <div class="hint">CORS must allow the browser to fetch. If it fails, fetch server-side (proxy/Edge Function).</div>
          </div>
        </div>

        <div class="row" style="justify-content:flex-end">
          <button class="btn primary" id="btnParse">Parse & Build Datasets</button>
        </div>

        <div class="status" id="parseStatus">No data parsed yet.</div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="card">
      <div class="hd">
        <h2>2) Preview & Upload</h2>
        <div class="pill"><span class="dot neutral"></span><span id="metaText">0 rows • 0 cols</span></div>
      </div>
      <div class="bd">

        <!-- Dataset selector -->
        <div class="row">
          <div class="field" style="min-width:260px">
            <label>Dataset</label>
            <select id="datasetSelect"></select>
            <div class="hint">Switch between base rows and each auto-detected exploded dataset (arrays of objects).</div>
          </div>
        </div>

        <div class="split">
          <div class="colbox">
            <div class="colhd">
              <div style="display:flex;flex-direction:column;gap:2px">
                <div style="font-size:12px">Columns</div>
                <div class="small">Include/rename before upload</div>
              </div>
              <div style="display:flex;gap:8px">
                <button class="btn" id="btnAll">All</button>
                <button class="btn" id="btnNone">None</button>
              </div>
            </div>
            <div class="colbd" id="colList">
              <div class="small" style="padding:10px 12px;color:var(--muted)">No columns yet.</div>
            </div>
          </div>

          <div>
            <div class="row">
              <div class="field">
                <label>Supabase URL</label>
                <input id="sbUrl" type="text" placeholder="https://xxxx.supabase.co"/>
              </div>
            </div>
            <div class="row">
              <div class="field">
                <label>Supabase anon key</label>
                <input id="sbKey" type="password" placeholder="anon public key"/>
                <div class="hint">Don’t put a Service Role key in frontend. Use an Edge Function if you need private writes.</div>
              </div>
            </div>

            <div class="row">
              <div class="field" style="flex:1">
                <label>Table name</label>
                <input id="sbTable" type="text" placeholder='e.g. ff_player_stats_raw'/>
              </div>
              <div class="field" style="flex:.8">
                <label>Mode</label>
                <select id="sbMode">
                  <option value="insert">Insert</option>
                  <option value="upsert" selected>Upsert</option>
                </select>
              </div>
            </div>

            <div class="row">
              <div class="field">
                <label>On conflict (Upsert only)</label>
                <input id="sbConflict" type="text" placeholder="e.g. match_id,player_stats.account_id"/>
                <div class="hint">You can type original keys; we auto-map to DB-safe names (dots → underscores).</div>
              </div>
            </div>

            <div class="row">
              <div class="field" style="flex:.7">
                <label>Chunk size</label>
                <select id="sbChunk">
                  <option value="100">100</option>
                  <option value="250">250</option>
                  <option value="500" selected>500</option>
                  <option value="1000">1000</option>
                </select>
              </div>
              <div class="field" style="flex:1.3">
                <label>Upload rows</label>
                <select id="sbRows">
                  <option value="all" selected>All rows (this dataset)</option>
                  <option value="preview">Preview rows only</option>
                </select>
              </div>
            </div>

            <div class="row">
              <div class="field" style="min-width:220px">
                <label>Auto timestamps</label>
                <div class="checkrow">
                  <input id="autoTimestamps" type="checkbox" checked />
                  <div>
                    <div style="font-size:12px">Add <span class="kbd">created_at</span> & <span class="kbd">updated_at</span> on upload</div>
                    <div class="small">If your table doesn’t have these columns, uncheck this.</div>
                  </div>
                </div>
              </div>
            </div>

            <div class="row" style="justify-content:flex-end">
              <button class="btn good" id="btnUpload">Upload Selected Dataset</button>
            </div>

            <div class="progress"><div class="bar" id="bar"></div></div>
            <div class="status" id="upStatus">Ready.</div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="tablewrap" style="max-height:360px; overflow:auto">
          <table id="table">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <div class="row" style="justify-content:flex-end;margin-top:10px">
          <button class="btn" id="btnCSV">Download CSV (selected cols)</button>
          <button class="btn" id="btnJSON">Download JSON rows</button>
        </div>

      </div>
    </section>

  </div>
</main>

<script>
  // -----------------------------
  // Helpers
  // -----------------------------
  const $ = (id) => document.getElementById(id);

  function setPill(state, text){
    const pill = $("pillState");
    const dot = pill.querySelector(".dot");
    dot.classList.remove("good","bad","neutral");
    dot.classList.add(state);
    $("pillText").textContent = text;
  }

  function safeString(v){
    if (v === null || v === undefined) return "";
    if (typeof v === "string") return v;
    if (typeof v === "number" || typeof v === "boolean") return String(v);
    return JSON.stringify(v);
  }

  function isPlainObject(x){
    return x && typeof x === "object" && !Array.isArray(x);
  }

  function parseYearMaybe(v){
    const s = (v ?? "").toString().trim();
    if(!s) return null;
    return /^[0-9]{4}$/.test(s) ? parseInt(s, 10) : s;
  }

  // Convert any JSON key into a safe Postgres identifier
  function toDbSafeKey(key){
    let s = String(key ?? "").trim();
    if(!s) return s;

    s = s.replace(/\[(\d+)\]/g, "_$1_");
    s = s.replace(/\./g, "_");
    s = s.replace(/[^a-zA-Z0-9_]/g, "_");
    s = s.replace(/_+/g, "_");
    s = s.replace(/^_+|_+$/g, "");
    if(/^\d/.test(s)) s = "c_" + s;
    if(!s) s = "col";
    return s;
  }

  // Dot path with optional [idx]
  function getByPath(root, path){
    if(!path) return root;
    const parts = path.replace(/\[(\d+)\]/g, ".$1").split(".").filter(Boolean);
    let cur = root;
    for(const p of parts){
      if(cur == null) return undefined;
      cur = cur[p];
    }
    return cur;
  }

  function setByPath(root, path, value){
    const parts = path.replace(/\[(\d+)\]/g, ".$1").split(".").filter(Boolean);
    if(!parts.length) return;
    let cur = root;
    for(let i=0;i<parts.length-1;i++){
      const p = parts[i];
      if(cur[p] == null || typeof cur[p] !== "object") cur[p] = {};
      cur = cur[p];
    }
    cur[parts[parts.length-1]] = value;
  }

  function deleteByPath(root, path){
    const parts = path.replace(/\[(\d+)\]/g, ".$1").split(".").filter(Boolean);
    if(!parts.length) return;
    let cur = root;
    for(let i=0;i<parts.length-1;i++){
      const p = parts[i];
      if(cur == null || typeof cur !== "object") return;
      cur = cur[p];
    }
    if(cur && typeof cur === "object"){
      delete cur[parts[parts.length-1]];
    }
  }

  function deepCloneJSON(x){
    return JSON.parse(JSON.stringify(x));
  }

  function findFirstArrayOfObjects(root){
    const q = [{v: root, path: ""}];
    const seen = new Set();
    while(q.length){
      const {v, path} = q.shift();
      if(!v || typeof v !== "object") continue;
      if(seen.has(v)) continue;
      seen.add(v);

      if(Array.isArray(v) && v.length && isPlainObject(v[0])){
        return {arr: v, path: path || "(root)"};
      }
      if(Array.isArray(v)){
        for(let i=0;i<Math.min(v.length, 6);i++){
          q.push({v: v[i], path: path ? `${path}[${i}]` : `[${i}]`});
        }
      }else{
        for(const k of Object.keys(v)){
          q.push({v: v[k], path: path ? `${path}.${k}` : k});
        }
      }
    }
    return {arr: null, path: ""};
  }

  // Flatten nested objects into dot keys.
  function flattenObject(obj, prefix="", out={}, arrMode="keep"){
    for(const [k, v] of Object.entries(obj || {})){
      const key = prefix ? `${prefix}.${k}` : k;

      if (v === null || v === undefined){
        out[key] = null;
      } else if (Array.isArray(v)){
        if (v.length === 0){
          out[key] = [];
        } else if (v.every(x => ["string","number","boolean"].includes(typeof x) || x==null)){
          out[key] = v.map(x => x==null ? "" : String(x)).join(" | ");
        } else if (v.every(isPlainObject) && arrMode === "index"){
          v.forEach((item, idx)=>{
            flattenObject(item, `${key}[${idx}]`, out, arrMode);
          });
        } else {
          out[key] = v; // keep complex arrays as JSON
        }
      } else if (isPlainObject(v)){
        flattenObject(v, key, out, arrMode);
      } else {
        out[key] = v;
      }
    }
    return out;
  }

  // Detect all paths that are arrays of objects
  function detectArrayObjectPaths(records, {maxDepth=7, maxPaths=60, sampleN=12} = {}){
    const out = new Set();
    const samples = (records || []).slice(0, sampleN).filter(isPlainObject);

    function walk(node, path, depth){
      if(depth > maxDepth) return;
      if(node == null) return;

      if(Array.isArray(node)){
        if(node.length && node.every(isPlainObject)){
          if(path) out.add(path);
          if(out.size >= maxPaths) return;
          // also peek into first item for nested arrays-of-objects inside the array elements
          walk(node[0], path ? path + "[0]" : "[0]", depth+1);
          return;
        }
        // non-object arrays: ignore
        return;
      }

      if(!isPlainObject(node)) return;

      for(const k of Object.keys(node)){
        const child = node[k];
        const p = path ? `${path}.${k}` : k;
        if(Array.isArray(child)){
          if(child.length && child.every(isPlainObject)){
            out.add(p);
            if(out.size >= maxPaths) return;
            // continue into first element (nested)
            walk(child[0], `${p}[0]`, depth+1);
          }else{
            // ignore primitive arrays
          }
        }else if(isPlainObject(child)){
          walk(child, p, depth+1);
          if(out.size >= maxPaths) return;
        }
      }
    }

    for(const rec of samples){
      walk(rec, "", 0);
      if(out.size >= maxPaths) break;
    }

    // normalize: remove [0] artifacts we only used for deeper scan
    const cleaned = new Set();
    for(const p of out){
      cleaned.add(p.replace(/\[0\]/g, ""));
    }

    // remove empty + dedupe
    return Array.from(cleaned).filter(Boolean);
  }

  function toCSV(rows, cols){
    const esc = (s) => {
      const str = s == null ? "" : String(s);
      if(/[",\n\r]/.test(str)) return `"${str.replace(/"/g,'""')}"`;
      return str;
    };
    const header = cols.map(esc).join(",");
    const lines = rows.map(r => cols.map(c => esc(r[c])).join(","));
    return [header, ...lines].join("\n");
  }

  function downloadText(filename, content, mime="text/plain"){
    const blob = new Blob([content], {type:mime});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 800);
  }

  // Try to infer match_id from common locations in the JSON (and record)
  function inferMatchIdAny(raw){
    if(!raw) return null;

    const candidates = [
      "match_id","matchId",
      "match.match_id","match.matchId",
      "data.match_id","data.matchId",
      "data.match.match_id","data.match.matchId",
      "data.matches[0].match_id","data.matches[0].matchId",
      "match.match_stats.match_id","match.match_stats.matchId"
    ];

    for(const p of candidates){
      const v = getByPath(raw, p);
      if(v !== undefined && v !== null && String(v).trim() !== "") return String(v);
    }
    return null;
  }

  // -----------------------------
  // App state (multi-dataset)
  // -----------------------------
  let RAW = null;

  // DATASETS: [{key,label,rows,cols,colcfg}]
  let DATASETS = [];
  let ACTIVE = null; // reference to selected dataset object

  // convenience pointers used by existing render code
  let ROWS = [];
  let COLS = [];
  let COLCFG = {}; // sourceKey -> { include, name(dbKey) }

  function updateMeta(){
    const label = ACTIVE?.label ? ` • ${ACTIVE.label}` : "";
    $("metaText").textContent = `${ROWS.length} rows • ${COLS.length} cols${label}`;
  }

  function getSelectedCols(){
    const keys = [];
    const names = [];
    for(const c of COLS){
      const cfg = COLCFG[c];
      if(cfg && cfg.include){
        keys.push(c);
        names.push(cfg.name || toDbSafeKey(c));
      }
    }
    return {keys, names};
  }

  function renderColList(){
    const box = $("colList");
    box.innerHTML = "";

    if(!COLS.length){
      box.innerHTML = `<div class="small" style="padding:10px 12px;color:var(--muted)">No columns yet.</div>`;
      return;
    }

    for(const c of COLS){
      const cfg = COLCFG[c] ?? (COLCFG[c] = { include:true, name: toDbSafeKey(c) });

      const row = document.createElement("div");
      row.className = "colrow";
      row.innerHTML = `
        <input type="checkbox" ${cfg.include ? "checked":""} aria-label="include"/>
        <div class="k" title="${c}">${c}</div>
        <input type="text" value="${cfg.name}" aria-label="rename"/>
      `;

      const cb = row.querySelector('input[type="checkbox"]');
      const inp = row.querySelector('input[type="text"]');

      cb.addEventListener("change", ()=>{
        COLCFG[c].include = cb.checked;
        if(ACTIVE) ACTIVE.colcfg = COLCFG;
        renderTable();
      });

      inp.addEventListener("input", ()=>{
        const val = (inp.value || "").trim();
        COLCFG[c].name = val ? val : toDbSafeKey(c);
        if(ACTIVE) ACTIVE.colcfg = COLCFG;
        renderTable();
      });

      box.appendChild(row);
    }
  }

  function renderTable(){
    const {keys, names} = getSelectedCols();
    const max = parseInt($("maxRows").value,10);
    const previewRows = ROWS.slice(0, max);

    const thRow = $("theadRow");
    const tb = $("tbody");

    if(!keys.length){
      thRow.innerHTML = `<th style="color:rgba(244,246,255,.65)">(No columns selected)</th>`;
      tb.innerHTML = "";
      return;
    }

    thRow.innerHTML = "";
    for(const n of names){
      const th = document.createElement("th");
      th.textContent = n;
      thRow.appendChild(th);
    }

    tb.innerHTML = "";
    for(const r of previewRows){
      const tr = document.createElement("tr");
      for(const k of keys){
        const td = document.createElement("td");
        td.textContent = safeString(r[k]);
        tr.appendChild(td);
      }
      tb.appendChild(tr);
    }
  }

  function setStatus(el, msg){
    $(el).textContent = msg;
  }

  function injectDefaultsIntoRecords(records){
    const modeVal = ($("defMode").value ?? "").trim();
    const tVal = ($("defTournament").value ?? "").trim();
    const sVal = ($("defStage").value ?? "").trim();
    const yVal = parseYearMaybe($("defYear").value);

    const wVal = ($("defWeek").value ?? "").trim();
    const dVal = ($("defDay").value ?? "").trim();

    const midVal = ($("defMatchId").value ?? "").trim();

    const autoMatch = $("autoMatchId").checked;

    return records.map(r=>{
      if(!isPlainObject(r)) return r;

      if(!("Mode" in r)) r.Mode = modeVal || null;
      if(!("Tournament" in r)) r.Tournament = tVal || null;
      if(!("Stage" in r)) r.Stage = sVal || null;
      if(!("Year" in r)) r.Year = yVal;

      if(!("Week" in r)) r.Week = wVal || null;
      if(!("Day" in r)) r.Day = dVal || null;

      if(!("match_id" in r) || r.match_id == null || r.match_id === ""){
        let inferred = null;
        if(midVal) inferred = midVal;
        else if(autoMatch) inferred = inferMatchIdAny(r);
        r.match_id = inferred || null;
      }

      return r;
    });
  }

  function makeDatasetLabel(path){
    if(!path) return "Base (no explode)";
    // keep it short but informative
    const parts = path.split(".");
    if(parts.length <= 2) return `Explode: ${path}`;
    return `Explode: ${parts.slice(-2).join(".")}`;
  }

  // Build a dataset from base records (optionally explode one path)
  function buildDatasetFromPath(baseRecords, path, arrMode){
    let shaped = baseRecords;

    if(path){
      const next = [];
      for(const rec of shaped){
        if(!isPlainObject(rec)) continue;
        const arr = getByPath(rec, path);
        if(!Array.isArray(arr) || !arr.length) continue;
        if(!arr.every(isPlainObject)) continue;

        for(const item of arr){
          const cloned = deepCloneJSON(rec);
          deleteByPath(cloned, path);
          setByPath(cloned, path, item);
          next.push(cloned);
        }
      }
      shaped = next;
    }

    const flat = [];
    for(const rec of shaped){
      if(isPlainObject(rec)){
        flat.push(flattenObject(rec, "", {}, arrMode));
      }else{
        flat.push({value: rec});
      }
    }

    const colSet = new Set();
    for(const r of flat) Object.keys(r).forEach(k => colSet.add(k));
    ["match_id","Mode","Tournament","Stage","Year","Week","Day"].forEach(k => colSet.add(k));

    const cols = Array.from(colSet);

    const common = [
      "match_id","Mode","Tournament","Stage","Year","Week","Day",
      "match.match_id","match.matchId","data.match_id",
      "id","matchId","game_id","timestamp","created_at","updated_at",
      "mode","map","team","team_id","player","player_id","name","tag"
    ];
    cols.sort((a,b)=>{
      const ia = common.indexOf(a), ib = common.indexOf(b);
      if(ia !== -1 || ib !== -1){
        return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
      }
      return a.localeCompare(b);
    });

    const colcfg = {};
    for(const c of cols){
      colcfg[c] = { include:true, name: toDbSafeKey(c) };
    }

    return { rows: flat, cols, colcfg };
  }

  function populateDatasetSelect(){
    const sel = $("datasetSelect");
    sel.innerHTML = "";
    if(!DATASETS.length){
      const opt = document.createElement("option");
      opt.value = "0";
      opt.textContent = "No datasets";
      sel.appendChild(opt);
      return;
    }

    DATASETS.forEach((ds, idx)=>{
      const opt = document.createElement("option");
      opt.value = String(idx);
      opt.textContent = `${ds.label}  —  ${ds.rows.length} rows`;
      sel.appendChild(opt);
    });

    sel.onchange = ()=>{
      const idx = parseInt(sel.value, 10);
      setActiveDataset(idx);
    };
  }

  function setActiveDataset(idx){
    const ds = DATASETS[idx];
    if(!ds) return;

    ACTIVE = ds;
    ROWS = ds.rows;
    COLS = ds.cols;
    COLCFG = ds.colcfg;

    updateMeta();
    renderColList();
    renderTable();
  }

  function buildFromJSON(){
    const txt = $("jsonText").value.trim();
    if(!txt){
      setPill("bad", "No JSON");
      setStatus("parseStatus", "Paste JSON first.");
      return;
    }

    try{
      RAW = JSON.parse(txt);
    }catch(e){
      setPill("bad", "Invalid JSON");
      setStatus("parseStatus", "JSON parse error:\n" + e.message);
      return;
    }

    // auto-fill match_id input if found (only if empty)
    const inferredGlobal = inferMatchIdAny(RAW);
    if(inferredGlobal && !$("defMatchId").value.trim()){
      $("defMatchId").value = inferredGlobal;
    }

    const arrMode = $("arrMode").value || "keep";
    const path = $("pathText").value.trim();

    let records = null;
    let usedPath = "";

    if(path){
      const v = getByPath(RAW, path);
      if(!Array.isArray(v)){
        setPill("bad", "Path not array");
        setStatus("parseStatus", `Path "${path}" did not resolve to an array.\nTip: use dot paths like data.matches`);
        return;
      }
      records = v;
      usedPath = path;
    }else{
      if(Array.isArray(RAW)) { records = RAW; usedPath = "(root array)"; }
      else{
        const found = findFirstArrayOfObjects(RAW);
        records = found.arr;
        usedPath = found.path || "(none)";
      }
    }

    if(!records || !records.length){
      setPill("bad", "No records");
      setStatus("parseStatus", `Could not find base rows to tabulate.\nTry setting Records array path.\nAuto-detected: ${usedPath}`);
      return;
    }

    // Apply defaults + match_id inference per record
    const baseRecords = injectDefaultsIntoRecords(records.filter(r => r != null));

    // Auto-detect explode datasets (arrays of objects) + allow manual additions
    const autoExplode = $("autoExplode").checked;
    const manualPaths = ($("explodePaths").value || "")
      .split(",")
      .map(s => s.trim())
      .filter(Boolean);

    let autoPaths = [];
    if(autoExplode){
      autoPaths = detectArrayObjectPaths(baseRecords, {maxDepth: 7, maxPaths: 60, sampleN: 12});
    }
    
    // Merge + de-dupe (auto + manual)
    const explodePaths = Array.from(new Set([...(autoPaths || []), ...(manualPaths || [])]))
      .filter(Boolean);
    
    // ✅ Auto-fill the input so you don’t set paths one by one
    if(autoExplode){
      $("explodePaths").value = explodePaths.join(", ");
    }

    // Build datasets:
    // - Base dataset (no explode)
    // - One dataset per explode path (independent; avoids cartesian product)
    const datasets = [];
    {
      const ds = buildDatasetFromPath(baseRecords, null, arrMode);
      datasets.push({
        key: "__base__",
        label: "Base (no explode)",
        rows: ds.rows,
        cols: ds.cols,
        colcfg: ds.colcfg
      });
    }

    for(const p of explodePaths){
      const ds = buildDatasetFromPath(baseRecords, p, arrMode);
      // skip empty datasets (no rows)
      if(!ds.rows.length) continue;

      datasets.push({
        key: p,
        label: makeDatasetLabel(p),
        rows: ds.rows,
        cols: ds.cols,
        colcfg: ds.colcfg
      });
    }

    DATASETS = datasets;

    // Choose default active dataset:
    // Prefer player_stats if present, else first explode dataset, else base.
    let activeIdx = 0;
    const idxPlayer = DATASETS.findIndex(d => (d.key || "").toLowerCase() === "player_stats" || (d.key || "").toLowerCase().endsWith(".player_stats"));
    if(idxPlayer >= 0) activeIdx = idxPlayer;
    else if(DATASETS.length > 1) activeIdx = 1;

    populateDatasetSelect();
    $("datasetSelect").value = String(activeIdx);
    setActiveDataset(activeIdx);

    setPill("good", "Parsed");
    setStatus("parseStatus",
`Parsed OK.
Base records: ${records.length}
Records path: ${usedPath}

Auto-detect explode: ${autoExplode ? "ON" : "OFF"}
Manual explode additions: ${manualPaths.length ? manualPaths.join(", ") : "(none)"}
Detected explode datasets: ${explodePaths.length ? explodePaths.join(", ") : "(none)"}

Datasets built: ${DATASETS.length}
Preview shows up to ${$("maxRows").value} rows for the selected dataset.

Auto-rename is ON:
Example: "player_stats.account_id" → "${toDbSafeKey("player_stats.account_id")}"`
    );
  }

  // -----------------------------
  // Supabase upload
  // -----------------------------
  function setProgress(pct){
    $("bar").style.width = `${Math.max(0, Math.min(100, pct))}%`;
  }

  function buildUploadRows(limitMode){
    const {keys, names} = getSelectedCols();
    const sourceRows = (limitMode === "preview")
      ? ROWS.slice(0, parseInt($("maxRows").value,10))
      : ROWS;

    const addTimestamps = $("autoTimestamps").checked;
    const nowIso = new Date().toISOString();

    return sourceRows.map(r=>{
      const o = {};
      for(let i=0;i<keys.length;i++){
        const srcKey = keys[i];
        const dbKey = names[i]; // renamed key
        o[dbKey] = r[srcKey];
      }

      if(addTimestamps){
        if(!("created_at" in o) || o.created_at == null || o.created_at === "") o.created_at = nowIso;
        o.updated_at = nowIso;
      }
      return o;
    });
  }

  // Map user "on conflict" input to DB-safe column names.
  function resolveOnConflict(raw){
    const typed = (raw || "")
      .split(",")
      .map(s => s.trim())
      .filter(Boolean);

    if(!typed.length) return "";

    const dbNames = new Set(Object.values(COLCFG).map(x => x?.name).filter(Boolean));

    return typed.map(col=>{
      if(COLCFG[col]?.name) return COLCFG[col].name;
      if(dbNames.has(col)) return col;
      return toDbSafeKey(col);
    }).join(",");
  }

  async function uploadToSupabase(){
    if(!ROWS.length){
      setStatus("upStatus", "No rows to upload. Parse JSON first.");
      setProgress(0);
      return;
    }

    const url = $("sbUrl").value.trim();
    const key = $("sbKey").value.trim();
    const table = $("sbTable").value.trim();
    const mode = $("sbMode").value;
    const onConflictInput = $("sbConflict").value.trim();
    const chunkSize = parseInt($("sbChunk").value,10);
    const rowMode = $("sbRows").value;

    if(!url || !key || !table){
      setStatus("upStatus", "Missing Supabase URL / anon key / table name.");
      setProgress(0);
      return;
    }

    const onConflict = resolveOnConflict(onConflictInput);

    if(mode === "upsert" && !onConflict){
      setStatus("upStatus", "Upsert requires an On conflict column(s).");
      setProgress(0);
      return;
    }

    setStatus("upStatus", "Preparing rows…");
    setProgress(0);

    const sb = supabase.createClient(url, key);

    const rows = buildUploadRows(rowMode);
    const total = rows.length;
    if(!total){
      setStatus("upStatus", "Nothing to upload after column selection.");
      setProgress(0);
      return;
    }

    const chunks = [];
    for(let i=0;i<rows.length;i+=chunkSize){
      chunks.push(rows.slice(i, i+chunkSize));
    }

    let ok = 0;
    let failed = 0;

    for(let i=0;i<chunks.length;i++){
      const batch = chunks[i];
      setStatus("upStatus", `Uploading ${i+1}/${chunks.length}…
Dataset: ${ACTIVE?.label || "(unknown)"}
Table: ${table}
Batch size: ${batch.length}
Uploaded: ${ok}/${total} • Failed: ${failed}

${mode === "upsert" ? `onConflict: ${onConflict}` : ""}`);
      setProgress(Math.round((i / chunks.length) * 100));

      try{
        let res;
        if(mode === "insert"){
          res = await sb.from(table).insert(batch);
        }else{
          res = await sb.from(table).upsert(batch, { onConflict: onConflict.replace(/\s+/g,"") });
        }

        if(res.error){
          failed += batch.length;
          setStatus("upStatus",
`Batch ${i+1} error:
${res.error.message}

Tips:
- Check RLS policy allows insert/upsert
- Ensure column types match (jsonb vs text)
- Ensure onConflict columns exist + have UNIQUE constraint/index
- If your table doesn’t have created_at/updated_at, uncheck Auto timestamps

Uploaded: ${ok}/${total} • Failed: ${failed}`
          );
          setProgress(Math.round(((i+1)/chunks.length)*100));
          return;
        }else{
          ok += batch.length;
        }
      }catch(e){
        failed += batch.length;
        setStatus("upStatus", `Network/runtime error on batch ${i+1}:\n${e.message}`);
        setProgress(Math.round(((i+1)/chunks.length)*100));
        return;
      }
    }

    setProgress(100);
    setStatus("upStatus", `Done ✅
Dataset: ${ACTIVE?.label || "(unknown)"}
Uploaded: ${ok}/${total}
Failed: ${failed}
Mode: ${mode}${mode==="upsert" ? ` (onConflict: ${onConflict})` : ""}`);
  }

  // -----------------------------
  // Events
  // -----------------------------
  $("btnParse").addEventListener("click", buildFromJSON);

  $("btnClear").addEventListener("click", ()=>{
    $("jsonText").value = "";
    $("pathText").value = "";
    $("explodePaths").value = "";
    $("fetchUrl").value = "";
    $("arrMode").value = "keep";
    $("maxRows").value = "2000";

    $("autoExplode").checked = true;
    $("autoMatchId").checked = true;

    $("defMode").value = "";
    $("defTournament").value = "";
    $("defStage").value = "";
    $("defYear").value = "";
    $("defWeek").value = "";
    $("defDay").value = "";
    $("defMatchId").value = "";

    $("autoTimestamps").checked = true;

    RAW = null;
    DATASETS = [];
    ACTIVE = null;
    ROWS = []; COLS = []; COLCFG = {};

    $("datasetSelect").innerHTML = "";
    $("colList").innerHTML = `<div class="small" style="padding:10px 12px;color:var(--muted)">No columns yet.</div>`;
    $("theadRow").innerHTML = "";
    $("tbody").innerHTML = "";
    updateMeta();
    setPill("neutral","Waiting for JSON");
    setStatus("parseStatus","No data parsed yet.");
    setStatus("upStatus","Ready.");
    setProgress(0);
  });

  $("btnSample").addEventListener("click", ()=>{
    const sample = {
      match: {
        match_id: "2009641319939340288",
        create_time: 1767970803,
        end_time: 1767972005,
        map_id: 4,
        group_mode: 3,
        game_mode: 1,
        match_mode: 3,
        match_stats_extra: {
          circle_info: [
            { circle_name:"Circle 0", circle_continue_time:"03:10", circle_remain_time:"04:00", x_coordinate:-28, y_coordinate:-42, radius:1000 },
            { circle_name:"Circle 1", circle_continue_time:"00:30", circle_remain_time:"02:30", x_coordinate:5, y_coordinate:-29, radius:550 }
          ],
          spector_info: [
            { spector_id:"5361762793", observer_id:"0", observer_name:"", observer_team_name:"" },
            { spector_id:"5361459022", observer_id:"322494863", observer_name:"AlokBananaㅤ", observer_team_name:"ACD" }
          ],
          round_stats: []
        },
        player_stats: [
          { account_id: 111, nickname: "A1", team: "ABC", kills: 3, damage: 812 },
          { account_id: 222, nickname: "A2", team: "ABC", kills: 2, damage: 540 }
        ]
      }
    };

    $("jsonText").value = JSON.stringify(sample, null, 2);
    $("pathText").value = ""; // root object -> base record auto-detect will find match? (base dataset still works)
    $("explodePaths").value = ""; // no manual needed
    $("autoExplode").checked = true;
    $("arrMode").value = "keep";
    $("maxRows").value = "2000";

    $("defMode").value = "BR";
    $("defTournament").value = "Sample Cup";
    $("defStage").value = "Finals";
    $("defYear").value = "2026";
    $("defWeek").value = "W1";
    $("defDay").value = "D1";
    $("defMatchId").value = ""; // will infer from match.match_id

    setPill("neutral","Sample loaded");
    setStatus("parseStatus","Sample loaded. Click Parse & Build Datasets.");
  });

  $("fileInput").addEventListener("change", async (e)=>{
    const f = e.target.files?.[0];
    if(!f) return;
    try{
      const txt = await f.text();
      $("jsonText").value = txt;
      setPill("neutral", "File loaded");
      setStatus("parseStatus", `Loaded file: ${f.name}\nClick Parse & Build Datasets.`);
    }catch(err){
      setPill("bad","File read failed");
      setStatus("parseStatus", "Could not read file:\n" + err.message);
    } finally {
      e.target.value = "";
    }
  });

  $("btnFetch").addEventListener("click", async ()=>{
    const url = $("fetchUrl").value.trim();
    if(!url){
      setStatus("parseStatus","Enter a URL first.");
      return;
    }
    setPill("neutral","Fetching…");
    setStatus("parseStatus","Fetching JSON from URL…");
    try{
      const res = await fetch(url, {cache:"no-store"});
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const txt = await res.text();
      $("jsonText").value = txt;
      setPill("neutral","Fetched");
      setStatus("parseStatus","Fetched OK. Click Parse & Build Datasets.");
    }catch(e){
      setPill("bad","Fetch failed");
      setStatus("parseStatus",
`Fetch failed:
${e.message}

This is often CORS.
If so, fetch server-side (proxy/Edge Function) then paste the JSON here.`
      );
    }
  });

  $("btnAll").addEventListener("click", ()=>{
    for(const c of COLS){ COLCFG[c].include = true; }
    if(ACTIVE) ACTIVE.colcfg = COLCFG;
    renderColList(); renderTable();
  });

  $("btnNone").addEventListener("click", ()=>{
    for(const c of COLS){ COLCFG[c].include = false; }
    if(ACTIVE) ACTIVE.colcfg = COLCFG;
    renderColList(); renderTable();
  });

  $("maxRows").addEventListener("change", ()=>{
    if(ROWS.length) renderTable();
  });

  $("btnUpload").addEventListener("click", uploadToSupabase);

  $("btnCSV").addEventListener("click", ()=>{
    if(!ROWS.length){ alert("Parse JSON first."); return; }
    const {keys, names} = getSelectedCols();
    if(!keys.length){ alert("No columns selected."); return; }
    const rowMode = $("sbRows").value;
    const rows = buildUploadRows(rowMode);

    const cols = names;
    const normalized = rows.map(r=>{
      const out = {};
      for(const c of cols){
        const v = r[c];
        out[c] = (Array.isArray(v) || isPlainObject(v)) ? safeString(v) : v;
      }
      return out;
    });

    const csv = toCSV(normalized, cols);
    const dsName = (ACTIVE?.key && ACTIVE.key !== "__base__") ? toDbSafeKey(ACTIVE.key) : "base";
    downloadText(`table_export_${dsName}.csv`, csv, "text/csv");
  });

  $("btnJSON").addEventListener("click", ()=>{
    if(!ROWS.length){ alert("Parse JSON first."); return; }
    const rowMode = $("sbRows").value;
    const rows = buildUploadRows(rowMode);
    const dsName = (ACTIVE?.key && ACTIVE.key !== "__base__") ? toDbSafeKey(ACTIVE.key) : "base";
    downloadText(`rows_export_${dsName}.json`, JSON.stringify(rows, null, 2), "application/json");
  });

  // init
  updateMeta();
  setPill("neutral","Waiting for JSON");
</script>
</body>
</html>
