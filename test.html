<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />

  <!-- ✅ ONLY ONE viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">

  <title>Team Path Planner</title>

  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    const client = supabase.createClient(
      'https://ooutjrewmwsixghbouxi.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9vdXRqcmV3bXdzaXhnaGJvdXhpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwMjg3NTMsImV4cCI6MjA4MjYwNDc1M30.13WkdGiQH39lZH3iDgVDd_tZrHlI0twhGeiZNdwaMSg'
    );

    client.auth.getSession().then(({ data: { session } }) => {
      if (!session) window.location.href = "index.html";
      else {
        const email = session.user?.email || "";
        const emailEl = document.getElementById("user-email");
        const tagEl = document.getElementById("user-tag");
        const userInfo = document.getElementById("user-info");
        if (emailEl) emailEl.textContent = email || "signed in";
        if (tagEl) tagEl.textContent = email ? email.split("@")[0] : "Player";
        if (userInfo) userInfo.textContent = email ? ("Logged in as: " + email) : "Signed in";
      }
    });

    function logout() {
      client.auth.signOut().then(() => window.location.href = "index.html");
    }
  </script>

  <style>
    :root{
      --bg:#07090f;
      --bg2:#0b1020;
      --panel: rgba(20, 26, 38, .72);
      --panel2: rgba(14, 18, 28, .72);
      --line: rgba(255,255,255,.10);
      --ink:#f4f6ff;
      --muted:#aab1c5;

      --brand:#ffbd59;
      --accent:#4dd3ff;

      --shadow: 0 22px 70px rgba(0,0,0,.55);
      --radius-lg: 18px;

      /* fixed design size */
      --main-w: 1112px;
      --main-h: 800px;

      --sidebar-w: 320px;
      --map-w: 792px;
    }

    *{ box-sizing:border-box; }
    html, body{
      margin:0; padding:0;
      width:100%;
      height:100%;
      font-family: Roboto, system-ui, -apple-system, Segoe UI, Arial;
      color: var(--ink);
      background:
        radial-gradient(900px 500px at 18% 12%, rgba(77,211,255,.15), transparent 60%),
        radial-gradient(700px 420px at 85% 18%, rgba(255,189,89,.12), transparent 60%),
        radial-gradient(900px 620px at 50% 110%, rgba(255,119,51,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }

    /* fixed canvas frame */
    #main{
      width: var(--main-w);
      height: var(--main-h);
      display:flex;
      overflow:hidden;
      border-radius: var(--radius-lg);
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      transform-origin: center;
    }

    #map-container{
      width: var(--map-w);
      height: 100%;
      position: relative;
      background: rgba(0,0,0,.35);
      border-right: 1px solid rgba(255,255,255,.06);
      overflow:hidden;
    }

    #map{
      width:100%;
      height:100%;
      position: relative;

      /* ✅ critical for cross-device sync */
      background-size: contain;
      background-position:center;
      background-repeat:no-repeat;

      /* ✅ critical for touch devices */
      touch-action: none;
    }

    #maskCanvas, #pathCanvas{
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    .unit{
      position:absolute;
      width:30px; height:30px;
      background: rgba(255,255,255,.10);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .unit img{
      width:100%; height:100%;
      border-radius:999px;
      box-shadow: 0 0 12px 2px rgba(255,255,255,0.35);
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.35);
    }
    .unit-label{
      position:absolute;
      top:-18px; left:50%;
      transform: translateX(-50%);
      font-size: 12px;
      font-weight: 900;
      background: rgba(0,0,0,.55);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.10);
      white-space:nowrap;
    }
    .reset-btn{
      position:absolute;
      bottom:-20px; left:50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,.92);
      color:#000;
      font-size: 10px;
      font-weight: 900;
      padding: 2px 6px;
      border: none;
      border-radius: 8px;
      cursor:pointer;
    }

    #sidebar{
      width: var(--sidebar-w);
      height: 100%;
      display:flex;
      flex-direction:column;
      padding: 12px;
      background: rgba(14, 18, 28, .70);
      border-left: 1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      overflow:hidden;
    }

    .side-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 10px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      margin-bottom: 10px;
    }
    .side-title h1{
      margin:0;
      font-family: Orbitron, sans-serif;
      font-size: 1.05rem;
      letter-spacing:.6px;
      color: var(--brand);
      white-space:nowrap;
    }
    .side-title p{
      margin: 4px 0 0 0;
      font-size: .78rem;
      color: var(--muted);
      font-weight: 700;
      white-space:nowrap;
    }

    .userchip{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      max-width: 150px;
    }
    .avatar{
      width:26px;height:26px;border-radius:10px;
      background: linear-gradient(135deg, rgba(255,189,89,.28), rgba(77,211,255,.18));
      border: 1px solid rgba(255,255,255,.12);
    }
    .usertext b{
      display:block;
      font-family: Orbitron, sans-serif;
      font-size:.84rem;
      color: var(--brand);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .usertext span{
      display:block;
      font-size:.72rem;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .icon-grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      justify-items:center;
      padding: 8px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      margin-bottom: 10px;
    }
    .team-icon{
      width: 50px;
      height: 55px;
      border-radius: 12px;
      cursor:pointer;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      object-fit: cover;
    }

    #controls{
      flex:1;
      display:flex;
      flex-direction:column;
      gap: 8px;
      overflow-y:auto;
      padding-right: 6px;
    }

    #controls button, #map-select{
      width: 100%;
      padding: 10px 10px;
      font-weight: 900;
      font-size: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: rgba(244,246,255,.90);
      cursor:pointer;
    }

    .button-row{ display:flex; gap:8px; }
    .button-row button{ flex:1; white-space:nowrap; }

    #realtime-toggle-btn.active{
      background: rgba(77,211,255,.18);
      border-color: rgba(77,211,255,.40);
      box-shadow: 0 0 0 3px rgba(77,211,255,.10);
    }
    #draw-circle.active{
      background: rgba(0,255,255,.18);
      border-color: rgba(0,255,255,.42);
      box-shadow: 0 0 0 3px rgba(0,255,255,.10);
    }

    .note{
      position:absolute;
      background: rgba(255,255,255,.92);
      color: #000;
      border: 1px solid rgba(0,0,0,.28);
      border-radius: 10px;
      max-width: 220px;
      overflow:hidden;
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      user-select:text;
    }
    .drag-handle{
      background: rgba(0,0,0,.12);
      padding: 4px 8px;
      font-weight: 1000;
      cursor: grab;
      user-select:none;
    }
    .note div[contenteditable]{
      padding: 6px 8px;
      min-height: 20px;
      outline:none;
      font-size: 12px;
      line-height: 1.2rem;
    }

    #user-info{
      font-size: .78rem;
      text-align:center;
      margin-top: 10px;
      color: rgba(170,177,197,.85);
      user-select:text;
    }

    /* ✅ Phones only */
    @media (max-width: 600px){
      html,body{ overflow:auto; }
      #main{
        width: 100vw;
        height: 100vh;
        border-radius: 0;
        flex-direction: column;
      }
      #map-container{
        width: 100%;
        height: 58vh;
        border-right: 0;
        border-bottom: 1px solid rgba(255,255,255,.06);
      }
      #sidebar{
        width: 100%;
        height: 42vh;
      }
      .icon-grid{ grid-template-columns: repeat(6, 1fr); }
    }
  </style>
</head>

<body>
<div id="main">
  <div id="map-container">
    <div id="map">
      <canvas id="maskCanvas"></canvas>
      <canvas id="pathCanvas"></canvas>
    </div>
  </div>

  <div id="sidebar">
    <div class="side-head">
      <div class="side-title">
        <h1>Path Planner</h1>
        <p>Draw paths • Circles • Notes</p>
      </div>
      <div class="userchip" id="user-chip">
        <div class="avatar"></div>
        <div class="usertext">
          <b id="user-tag">Player</b>
          <span id="user-email">loading…</span>
        </div>
      </div>
    </div>

    <div class="icon-grid" id="teamIcons"></div>

    <div id="controls">
      <select id="map-select">
        <option value="https://i.imgur.com/V6iUHaA.jpeg">Bermuda</option>
        <option value="https://i.imgur.com/ieY0LHk.jpeg">Purgatory</option>
        <option value="https://i.imgur.com/48O1Jf8.jpeg">Alpine</option>
        <option value="https://i.imgur.com/4Yz12P9.jpeg">Kalahari</option>
        <option value="https://i.imgur.com/x5he05R.jpeg">NeXTerra</option>
        <option value="https://i.imgur.com/IX1oY9Z.jpeg">Solara</option>
      </select>

      <button id="realtime-toggle-btn">Real-time: ON</button>

      <div class="button-row">
        <button id="draw-circle">Draw Circle</button>
        <button id="note-mode">Add Note</button>
      </div>

      <button id="undo-btn">Undo</button>
      <button id="reset-all-btn">Reset All</button>

      <div class="button-row">
        <button id="export-btn">Export</button>
        <button onclick="document.getElementById('import-file').click()">Import</button>
      </div>

      <input type="file" id="import-file" accept=".json" style="display:none;" />

      <div class="button-row">
        <button onclick="location.href='dashboard.html'">← Dashboard</button>
        <button onclick="location.href='team_settings.html'">Team Settings</button>
      </div>

      <button onclick="logout()">Logout</button>
      <p id="user-info">Checking login...</p>
    </div>
  </div>
</div>

<script>
  const map = document.getElementById("map");
  const canvas = document.getElementById("pathCanvas");
  const ctx = canvas.getContext("2d");
  const maskCanvas = document.getElementById("maskCanvas");
  const maskCtx = maskCanvas.getContext("2d");

  // ========= perfect sync storage =========
  // Store everything normalized to visible image area (0..1)
  const teamPaths = {};     // { team1:[{x,y}...] }
  const teamIcons = {};     // dom refs
  const undoStacks = {};
  const circles = [];       // {x,y,r,color} where r is normalized to minDim
  const notes = [];         // {x,y,text} x/y normalized

  const historyStack = [];
  let selectedIcon = null, activeTeam = null;
  let drawCircleMode = false, noteMode = false;

  const teamColors = [
    "#FF0000", "#00FF00", "#00FFFF", "#FFFF00", "#FF00FF", "#FFA500",
    "#00BFFF", "#FF69B4", "#7FFF00", "#FF4500", "#00FF7F", "#1E90FF",
    "#FFD700", "#ADFF2F", "#FF1493", "#40E0D0", "#FF6347", "#87CEEB"
  ];

  // ====== scale #main on iPad/desktop if screen smaller than 1112x800 (NOT phones) ======
  function isPhone(){ return window.matchMedia("(max-width: 600px)").matches; }
  function fitMain(){
    const main = document.getElementById("main");
    if (isPhone()) { main.style.transform = "none"; return; }
    const scale = Math.min(window.innerWidth / 1112, window.innerHeight / 800, 1);
    main.style.transform = `scale(${scale})`;
  }

  // ====== map image natural size for correct image box math ======
  let mapNatural = { w: 1, h: 1 };
  const mapSelect = document.getElementById("map-select");

  function clamp01(v){ return Math.max(0, Math.min(1, v)); }

  async function loadMapNatural(url){
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        mapNatural = { w: img.naturalWidth || 1, h: img.naturalHeight || 1 };
        resolve();
      };
      img.onerror = () => resolve();
      img.src = url + (url.includes("?") ? "&" : "?") + "ts=" + Date.now();
    });
  }

  function getImageBox(){
    const cw = map.clientWidth, ch = map.clientHeight;
    const iw = mapNatural.w, ih = mapNatural.h;
    const s = Math.min(cw / iw, ch / ih);           // contain
    const dw = iw * s, dh = ih * s;
    const ox = (cw - dw) / 2;
    const oy = (ch - dh) / 2;
    return { ox, oy, dw, dh, minDim: Math.min(dw, dh) };
  }

  // Convert pointer -> map-local pixels (undo CSS transform scale)
  function pointerToLocal(e){
    const rect = map.getBoundingClientRect();
    const sx = map.clientWidth  / rect.width;
    const sy = map.clientHeight / rect.height;
    return {
      x: (e.clientX - rect.left) * sx,
      y: (e.clientY - rect.top)  * sy
    };
  }

  function pointerToNorm(e){
    const p = pointerToLocal(e);
    const b = getImageBox();
    return {
      x: clamp01((p.x - b.ox) / b.dw),
      y: clamp01((p.y - b.oy) / b.dh),
    };
  }

  function normToPx(n){
    const b = getImageBox();
    return {
      x: b.ox + n.x * b.dw,
      y: b.oy + n.y * b.dh
    };
  }

  // ====== DPI-safe canvas sizing ======
  function resizeCanvases(){
    const dpr = window.devicePixelRatio || 1;
    const w = map.clientWidth, h = map.clientHeight;

    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    canvas.style.width = w + "px";
    canvas.style.height = h + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    maskCanvas.width = Math.round(w * dpr);
    maskCanvas.height = Math.round(h * dpr);
    maskCanvas.style.width = w + "px";
    maskCanvas.style.height = h + "px";
    maskCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    drawAll();
  }

  // ====== draw ======
  function drawArrow(fromPx, toPx, color){
    const dx = toPx.x - fromPx.x, dy = toPx.y - fromPx.y;
    const angle = Math.atan2(dy, dx);

    ctx.beginPath();
    ctx.shadowColor = color;
    ctx.shadowBlur = 6;
    ctx.moveTo(fromPx.x, fromPx.y);
    ctx.lineTo(toPx.x, toPx.y);

    ctx.lineTo(toPx.x - 10 * Math.cos(angle - Math.PI/6), toPx.y - 10 * Math.sin(angle - Math.PI/6));
    ctx.moveTo(toPx.x, toPx.y);
    ctx.lineTo(toPx.x - 10 * Math.cos(angle + Math.PI/6), toPx.y - 10 * Math.sin(angle + Math.PI/6));

    ctx.strokeStyle = color;
    ctx.lineWidth = 4;
    ctx.stroke();
  }

  function drawOverlayMask(){
    maskCanvas.style.display = "block";
    const b = getImageBox();

    maskCtx.clearRect(0,0,map.clientWidth,map.clientHeight);
    maskCtx.fillStyle = "rgba(0,0,0,.75)";
    maskCtx.fillRect(0,0,map.clientWidth,map.clientHeight);

    maskCtx.globalCompositeOperation = "destination-out";
    circles.forEach(c => {
      const center = normToPx(c);
      const rPx = (c.r || 0) * b.minDim;
      maskCtx.beginPath();
      maskCtx.arc(center.x, center.y, rPx, 0, Math.PI*2);
      maskCtx.fill();
    });
    maskCtx.globalCompositeOperation = "source-over";
  }

  function positionUnits(){
    Object.entries(teamPaths).forEach(([id, pts]) => {
      const unit = teamIcons[id];
      if (!unit || !pts?.length) return;
      const p = normToPx(pts[0]);
      unit.style.left = (p.x - 15) + "px";
      unit.style.top  = (p.y - 15) + "px";
    });
  }

  function positionNotes(){
    document.querySelectorAll(".note").forEach(n => n.remove());
    notes.forEach((n, idx) => {
      const p = normToPx(n);
      createNoteDom(p.x, p.y, n.text, idx);
    });
  }

  function drawPaths(){
    ctx.clearRect(0,0,map.clientWidth,map.clientHeight);

    // circles
    const b = getImageBox();
    circles.forEach(c => {
      const center = normToPx(c);
      const rPx = (c.r || 0) * b.minDim;

      ctx.beginPath();
      ctx.arc(center.x, center.y, rPx, 0, Math.PI*2);
      ctx.strokeStyle = c.color || "#00ffff";
      ctx.setLineDash([3,1]);
      ctx.lineWidth = 5;
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(center.x + rPx, center.y, 4, 0, Math.PI*2);
      ctx.fillStyle = c.color || "#00ffff";
      ctx.fill();
    });

    // paths
    for (let id in teamPaths){
      const path = teamPaths[id];
      const i = parseInt(id.replace("team",""),10) - 1;
      const color = teamColors[i] || "#fff";

      for (let j=0;j<path.length-1;j++){
        drawArrow(normToPx(path[j]), normToPx(path[j+1]), color);
      }
    }
  }

  function drawAll(){
    drawPaths();
    positionUnits();
    positionNotes();
    // mask if needed (you can decide based on map mode; leaving always hidden unless you want it)
    maskCanvas.style.display = "none";
  }

  // ====== notes DOM ======
  function createNoteDom(xPx, yPx, text, idx){
    const noteDiv = document.createElement("div");
    noteDiv.className = "note";
    noteDiv.style.left = `${xPx}px`;
    noteDiv.style.top  = `${yPx}px`;

    const handle = document.createElement("div");
    handle.className = "drag-handle";
    handle.textContent = "☰";

    const content = document.createElement("div");
    content.contentEditable = true;
    content.textContent = text;

    content.addEventListener("input", () => {
      if (notes[idx]) notes[idx].text = content.textContent || "";
      saveMapState();
    });

    noteDiv.appendChild(handle);
    noteDiv.appendChild(content);
    map.appendChild(noteDiv);

    // drag (pointer)
    let dragging = false;
    let ox = 0, oy = 0;

    handle.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      dragging = true;
      handle.setPointerCapture(e.pointerId);

      const p = pointerToLocal(e);
      ox = p.x - parseFloat(noteDiv.style.left || "0");
      oy = p.y - parseFloat(noteDiv.style.top  || "0");
    });

    handle.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      e.preventDefault();
      const p = pointerToLocal(e);
      noteDiv.style.left = `${p.x - ox}px`;
      noteDiv.style.top  = `${p.y - oy}px`;
    });

    const end = () => {
      if (!dragging) return;
      dragging = false;

      const left = parseFloat(noteDiv.style.left || "0");
      const top  = parseFloat(noteDiv.style.top  || "0");

      // update normalized
      const b = getImageBox();
      notes[idx].x = clamp01((left - b.ox) / b.dw);
      notes[idx].y = clamp01((top  - b.oy) / b.dh);
      saveMapState();
    };

    handle.addEventListener("pointerup", end);
    handle.addEventListener("pointercancel", end);
  }

  function addNoteAt(pointerEvent){
    const n = pointerToNorm(pointerEvent);
    const text = prompt("Enter note:");
    if (!text) return;

    notes.push({ x:n.x, y:n.y, text });
    historyStack.push({ type:"note" });

    drawAll();
    saveMapState();
  }

  // ====== team icons load ======
  async function loadTeamIcons() {
    const grid = document.getElementById("teamIcons");
    grid.innerHTML = "";

    const { data, error } = await client
      .from("teams_pathplanner")
      .select("id, team_name, team_tag, logo_url")
      .order("id", { ascending: true });

    if (error || !data?.length) {
      const msg = document.createElement("p");
      msg.textContent = "Failed to load teams / no teams found.";
      msg.style.fontSize = "0.8rem";
      msg.style.color = "#aaa";
      msg.style.gridColumn = "1 / -1";
      grid.appendChild(msg);
      return;
    }

    data.slice(0, teamColors.length).forEach((team, i) => {
      const img = document.createElement("img");
      img.src = team.logo_url;
      img.alt = team.team_name || team.team_tag || `Team ${i+1}`;
      img.className = "team-icon";

      const teamId = "team" + (i + 1);
      img.dataset.id = teamId;
      img.dataset.teamTag = team.team_tag || teamId;

      img.title = `${team.team_name || "Team"} (${team.team_tag || "TAG"})`;
      img.addEventListener("click", () => selectedIcon = img);
      grid.appendChild(img);
    });
  }

  // ====== map setup ======
  async function setMap(url){
    map.style.backgroundImage = `url('${url}')`;
    await loadMapNatural(url);
    resizeCanvases();
  }

  mapSelect.addEventListener("change", async () => {
    await setMap(mapSelect.value);
    saveMapState();
  });

  // ====== modes ======
  document.getElementById("draw-circle").onclick = () => {
    drawCircleMode = !drawCircleMode;
    const btn = document.getElementById("draw-circle");
    btn.textContent = drawCircleMode ? "Circle Mode: ON" : "Draw Circle";
    btn.classList.toggle("active", drawCircleMode);
  };

  document.getElementById("note-mode").onclick = () => {
    noteMode = !noteMode;
    document.getElementById("note-mode").textContent = noteMode ? "Tap on Map to Add Note" : "Add Note";
  };

  // ====== pointer interaction (replaces click/touch/mouse) ======
  let down = false;
  let moved = false;
  let downLocal = {x:0,y:0};

  let resizingCircle = null;
  let draggingCircle = null;

  function findCircleResize(localPx){
    const b = getImageBox();
    for (let i = circles.length - 1; i >= 0; i--){
      const c = circles[i];
      const center = normToPx(c);
      const rPx = (c.r || 0) * b.minDim;
      const dist = Math.hypot(center.x - localPx.x, center.y - localPx.y);
      if (Math.abs(dist - rPx) < 12) return c;
    }
    return null;
  }

  function findCircleDrag(localPx){
    const b = getImageBox();
    for (let i = circles.length - 1; i >= 0; i--){
      const c = circles[i];
      const center = normToPx(c);
      const rPx = (c.r || 0) * b.minDim;
      const dist = Math.hypot(center.x - localPx.x, center.y - localPx.y);
      if (dist < rPx) return c;
    }
    return null;
  }

  map.addEventListener("pointerdown", (e) => {
    // ignore notes interaction
    if (e.target?.closest && e.target.closest(".note")) return;

    e.preventDefault();
    map.setPointerCapture(e.pointerId);

    down = true;
    moved = false;
    downLocal = pointerToLocal(e);

    // check circle interactions first
    resizingCircle = findCircleResize(downLocal);
    if (!resizingCircle) draggingCircle = findCircleDrag(downLocal);
  });

  map.addEventListener("pointermove", (e) => {
    if (!down) return;
    e.preventDefault();

    const pLocal = pointerToLocal(e);
    if (Math.hypot(pLocal.x - downLocal.x, pLocal.y - downLocal.y) > 6) moved = true;

    // circle resize/drag
    const b = getImageBox();

    if (resizingCircle){
      const center = normToPx(resizingCircle);
      const distPx = Math.max(10, Math.hypot(pLocal.x - center.x, pLocal.y - center.y));
      resizingCircle.r = distPx / b.minDim;
      drawAll();
      return;
    }

    if (draggingCircle){
      const n = pointerToNorm(e);
      draggingCircle.x = n.x;
      draggingCircle.y = n.y;
      drawAll();
      return;
    }
  });

  map.addEventListener("pointerup", (e) => {
    if (!down) return;
    e.preventDefault();
    down = false;

    // if we were resizing/dragging circles, just save
    if (resizingCircle || draggingCircle){
      resizingCircle = draggingCircle = null;
      saveMapState();
      return;
    }

    // treat as tap if not moved
    if (moved) return;

    if (noteMode){
      noteMode = false;
      document.getElementById("note-mode").textContent = "Add Note";
      addNoteAt(e);
      return;
    }

    const n = pointerToNorm(e);

    if (drawCircleMode){
      circles.push({ x:n.x, y:n.y, r: 30 / Math.min(map.clientWidth, map.clientHeight), color:"#00ffff" });
      historyStack.push({ type:"circle" });
      drawAll();
      saveMapState();
      return;
    }

    // place team icon
    if (selectedIcon){
      const id = selectedIcon.dataset.id;
      if (teamIcons[id]) { selectedIcon = null; return; }

      const p = normToPx(n);

      const div = document.createElement("div");
      div.className = "unit";
      div.style.left = `${p.x - 15}px`;
      div.style.top  = `${p.y - 15}px`;

      const img = selectedIcon.cloneNode(true);
      img.style.width = img.style.height = "30px";

      const label = document.createElement("div");
      label.className = "unit-label";
      label.textContent = selectedIcon.dataset.teamTag || id;

      const reset = document.createElement("button");
      reset.className = "reset-btn";
      reset.textContent = "Reset";
      reset.onclick = (ev) => {
        ev.stopPropagation();
        div.remove();
        delete teamPaths[id];
        delete teamIcons[id];
        delete undoStacks[id];
        drawAll();
        saveMapState();
      };

      div.append(img, label, reset);
      map.appendChild(div);
      div.onclick = () => activeTeam = id;

      teamPaths[id] = [{ x:n.x, y:n.y }];
      teamIcons[id] = div;
      undoStacks[id] = [];
      activeTeam = id;
      selectedIcon = null;

      historyStack.push({ type:"line", team:id });
      drawAll();
      saveMapState();
      return;
    }

    // add path point
    if (activeTeam && teamPaths[activeTeam]){
      undoStacks[activeTeam].push([...teamPaths[activeTeam]]);
      teamPaths[activeTeam].push({ x:n.x, y:n.y });
      historyStack.push({ type:"line", team:activeTeam });
      drawAll();
      saveMapState();
    }
  });

  map.addEventListener("pointercancel", () => {
    down = false;
    resizingCircle = draggingCircle = null;
  });

  // ====== undo/reset/export/import (kept simple) ======
  document.getElementById("undo-btn").onclick = () => {
    const last = historyStack.pop();
    if (!last) return;

    if (last.type === "circle"){
      circles.pop();
    } else if (last.type === "line"){
      const path = teamPaths[last.team];
      if (path){
        path.pop();
        if (path.length === 0){
          delete teamPaths[last.team];
          const icon = teamIcons[last.team];
          if (icon) icon.remove();
          delete teamIcons[last.team];
        }
      }
    } else if (last.type === "note"){
      notes.pop();
    }

    drawAll();
    saveMapState();
  };

  document.getElementById("reset-all-btn").onclick = () => {
    if (!confirm("Reset all?")) return;

    document.querySelectorAll("#map .unit").forEach(u => u.remove());
    Object.keys(teamPaths).forEach(k => delete teamPaths[k]);
    Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
    Object.keys(undoStacks).forEach(k => delete undoStacks[k]);

    circles.length = 0;
    notes.length = 0;
    historyStack.length = 0;
    activeTeam = selectedIcon = null;

    drawAll();
    saveMapState();
  };

  document.getElementById("export-btn").onclick = () => {
    const data = { map: mapSelect.value, paths: teamPaths, circles, notes };
    const blob = new Blob([JSON.stringify(data)], { type:"application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "team-paths.json";
    a.click();
    URL.revokeObjectURL(url);
  };

  document.getElementById("import-file").onchange = function(){
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (ev) => {
      const data = JSON.parse(ev.target.result || "{}");

      // clear
      document.querySelectorAll("#map .unit").forEach(u => u.remove());
      Object.keys(teamPaths).forEach(k => delete teamPaths[k]);
      Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
      Object.keys(undoStacks).forEach(k => delete undoStacks[k]);
      circles.length = 0;
      notes.length = 0;
      historyStack.length = 0;

      if (data.map){
        mapSelect.value = data.map;
        await setMap(data.map);
      }

      Object.entries(data.paths || {}).forEach(([id, pts]) => {
        if (!pts?.length) return;
        teamPaths[id] = pts;
      });

      (data.circles || []).forEach(c => circles.push(c));
      (data.notes || []).forEach(n => notes.push(n));

      // rebuild units from first path point
      Object.entries(teamPaths).forEach(([id, pts]) => {
        const icon = document.querySelector(`.team-icon[data-id="${id}"]`);
        if (!icon) return;
        const p = normToPx(pts[0]);

        const div = document.createElement("div");
        div.className = "unit";
        div.style.left = `${p.x - 15}px`;
        div.style.top  = `${p.y - 15}px`;

        const img = icon.cloneNode(true);
        img.style.width = img.style.height = "30px";

        const label = document.createElement("div");
        label.className = "unit-label";
        label.textContent = icon.dataset.teamTag || id;

        const reset = document.createElement("button");
        reset.className = "reset-btn";
        reset.textContent = "Reset";
        reset.onclick = (ev2) => {
          ev2.stopPropagation();
          div.remove();
          delete teamPaths[id];
          delete teamIcons[id];
          delete undoStacks[id];
          drawAll();
          saveMapState();
        };

        div.append(img, label, reset);
        map.appendChild(div);
        div.onclick = () => activeTeam = id;

        teamIcons[id] = div;
        undoStacks[id] = [];
      });

      drawAll();
      saveMapState();
    };
    reader.readAsText(file);
  };

  // ====== Supabase realtime (kept from your idea; minimal) ======
  let realtimeEnabled = true;
  let realtimeChannel = null;

  async function loadMapState(){
    const { data, error } = await client.from("map").select("state").eq("id", 1).maybeSingle();
    if (error && error.code !== "PGRST116") return;

    const state = data?.state;
    if (!state){
      await saveMapState();
      return;
    }

    // apply
    if (state.map){
      mapSelect.value = state.map;
      await setMap(state.map);
    }

    // clear
    document.querySelectorAll("#map .unit").forEach(u => u.remove());
    Object.keys(teamPaths).forEach(k => delete teamPaths[k]);
    Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
    Object.keys(undoStacks).forEach(k => delete undoStacks[k]);
    circles.length = 0;
    notes.length = 0;
    historyStack.length = 0;

    Object.assign(teamPaths, state.paths || {});
    (state.circles || []).forEach(c => circles.push(c));
    (state.notes || []).forEach(n => notes.push(n));

    // rebuild units
    Object.entries(teamPaths).forEach(([id, pts]) => {
      const icon = document.querySelector(`.team-icon[data-id="${id}"]`);
      if (!icon || !pts?.length) return;
      const p = normToPx(pts[0]);

      const div = document.createElement("div");
      div.className = "unit";
      div.style.left = `${p.x - 15}px`;
      div.style.top  = `${p.y - 15}px`;

      const img = icon.cloneNode(true);
      img.style.width = img.style.height = "30px";

      const label = document.createElement("div");
      label.className = "unit-label";
      label.textContent = icon.dataset.teamTag || id;

      const reset = document.createElement("button");
      reset.className = "reset-btn";
      reset.textContent = "Reset";
      reset.onclick = (ev) => {
        ev.stopPropagation();
        div.remove();
        delete teamPaths[id];
        delete teamIcons[id];
        delete undoStacks[id];
        drawAll();
        saveMapState();
      };

      div.append(img, label, reset);
      map.appendChild(div);
      div.onclick = () => activeTeam = id;

      teamIcons[id] = div;
      undoStacks[id] = [];
    });

    drawAll();
  }

  async function saveMapState(){
    const state = { map: mapSelect.value, paths: teamPaths, circles, notes };
    await client.from("map").upsert({ id: 1, state, updated_at: new Date().toISOString() });
  }

  function handleMapChange(payload){
    if (!realtimeEnabled) return;
    const row = payload.new;
    if (!row || row.id !== 1) return;
    loadMapState();
  }

  async function enableRealtime(){
    if (realtimeChannel) return;
    realtimeChannel = client.channel("public:map")
      .on("postgres_changes", { event:"INSERT", schema:"public", table:"map" }, handleMapChange)
      .on("postgres_changes", { event:"UPDATE", schema:"public", table:"map" }, handleMapChange);
    await realtimeChannel.subscribe();
  }

  async function disableRealtime(){
    if (!realtimeChannel) return;
    await client.removeChannel(realtimeChannel);
    realtimeChannel = null;
  }

  // ====== realtime toggle ======
  document.getElementById("realtime-toggle-btn").onclick = async () => {
    realtimeEnabled = !realtimeEnabled;
    const btn = document.getElementById("realtime-toggle-btn");
    btn.textContent = realtimeEnabled ? "Real-time: ON" : "Real-time: OFF";
    btn.classList.toggle("active", realtimeEnabled);
    if (realtimeEnabled) await enableRealtime();
    else await disableRealtime();
  };

  // ====== init ======
  window.addEventListener("resize", () => {
    fitMain();
    resizeCanvases();
  });

  window.addEventListener("DOMContentLoaded", async () => {
    fitMain();
    await loadTeamIcons();
    await setMap(mapSelect.value);
    await loadMapState();
    await enableRealtime();
    resizeCanvases();
  });
</script>
</body>
</html>
