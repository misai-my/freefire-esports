<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- ✅ single viewport (remove the conflicting fixed one) -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

  <title>Team Path Planner</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

  <!-- Supabase JS v2 (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg:#07090f;
      --bg2:#0b1020;
      --panel: rgba(20, 26, 38, .72);
      --panel2: rgba(14, 18, 28, .72);
      --line: rgba(255,255,255,.10);
      --ink:#f4f6ff;
      --muted:#aab1c5;

      --brand:#ffbd59;
      --brand2:#ff7733;
      --accent:#4dd3ff;

      --shadow: 0 22px 70px rgba(0,0,0,.55);
      --radius-lg: 18px;
      --radius: 14px;

      /* ✅ base design size (kept consistent across devices) */
      --main-w: 1112px;
      --main-h: 800px;

      --sidebar-w: 320px;
      --map-w: 792px; /* 1112 - 320 */
    }

    *{ box-sizing:border-box; }

    html, body{
      margin:0; padding:0;
      width:100vw; height:100vh;
      overflow:hidden;
      font-family: Roboto, system-ui, -apple-system, Segoe UI, Arial;
      color: var(--ink);
      background:
        radial-gradient(900px 500px at 18% 12%, rgba(77,211,255,.15), transparent 60%),
        radial-gradient(700px 420px at 85% 18%, rgba(255,189,89,.12), transparent 60%),
        radial-gradient(900px 620px at 50% 110%, rgba(255,119,51,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      display:flex;
      align-items:center;
      justify-content:center;

      -webkit-touch-callout:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }

    /* ✅ main fixed canvas frame (we scale this on small screens via JS transform) */
    #main{
      width: var(--main-w);
      height: var(--main-h);
      display:flex;
      overflow:hidden;
      border-radius: var(--radius-lg);
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      position: relative;
      transform-origin: center center;
    }

    /* map area */
    #map-container{
      width: var(--map-w);
      height: 100%;
      position: relative;
      background: rgba(0,0,0,.35);
      border-right: 1px solid rgba(255,255,255,.06);
      overflow:hidden;
    }

    #map{
      width:100%;
      height:100%;
      background-size: auto 100%;
      background-position:center;
      background-repeat:no-repeat;
      position: relative;

      /* ✅ critical for iOS/iPad pointer/touch */
      touch-action: none;
    }

    #maskCanvas, #pathCanvas{
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }
    #maskCanvas{ z-index: 9; }
    #pathCanvas{ z-index: 10; }

    /* unit */
    .unit{
      position:absolute;
      width:30px; height:30px;
      background: rgba(255,255,255,.10);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      z-index: 20;
      touch-action:none;
    }
    .unit img{
      width:100%; height:100%;
      border-radius:999px;
      box-shadow: 0 0 12px 2px rgba(255,255,255,0.35);
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.35);
      display:block;
      pointer-events:none;
    }
    .unit-label{
      position:absolute;
      top:-18px; left:50%;
      transform: translateX(-50%);
      font-size: 12px;
      font-weight: 900;
      background: rgba(0,0,0,.55);
      color: rgba(244,246,255,.92);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.10);
      white-space:nowrap;
      pointer-events:none;
    }
    .reset-btn{
      position:absolute;
      bottom:-20px; left:50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,.92);
      color:#000;
      font-size: 10px;
      font-weight: 900;
      padding: 2px 6px;
      border: none;
      border-radius: 8px;
      cursor:pointer;
      touch-action:none;
    }

    /* right sidebar controls */
    #sidebar{
      width: var(--sidebar-w);
      height: 100%;
      display:flex;
      flex-direction:column;
      padding: 12px;
      background: rgba(14, 18, 28, .70);
      border-left: 1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      overflow:hidden;
    }

    /* ✅ side-head removed */

    /* team icons grid */
    .icon-grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      justify-items:center;
      padding: 8px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      margin-bottom: 10px;
    }

    .team-icon{
      width: 50px;
      height: 55px;
      border-radius: 12px;
      cursor:pointer;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      object-fit: cover;
      touch-action:none;
    }
    .team-icon:hover{
      outline: 2px solid rgba(255,189,89,.35);
      outline-offset: 2px;
    }
    .team-icon.selected{
      outline: 2px solid rgba(255,189,89,.55);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(255,189,89,.12);
    }

    /* controls panel scroll */
    #controls{
      flex:1;
      display:flex;
      flex-direction:column;
      gap: 8px;
      overflow-y:auto;
      padding-right: 6px;
    }
    #controls::-webkit-scrollbar{ width:10px; }
    #controls::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.10); border-radius: 10px; }
    #controls::-webkit-scrollbar-track{ background: transparent; }

    /* shared control styles */
    #controls button, #map-select{
      width: 100%;
      padding: 10px 10px;
      font-weight: 900;
      font-size: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: rgba(244,246,255,.90);
      cursor:pointer;
      transition: .18s ease;
    }
    #controls button:hover, #map-select:hover{
      background: rgba(0,0,0,.30);
      border-color: rgba(77,211,255,.22);
      box-shadow: 0 0 0 3px rgba(77,211,255,.10);
    }

    /* dropdown list (options) not white-on-white */
    #map-select{
      background: rgba(0,0,0,.28);
      color: rgba(244,246,255,.92);
    }
    #map-select option, #map-select optgroup{
      background: #0e111a;
      color: rgba(244,246,255,.92);
    }
    #map-select:focus{
      outline: none;
      box-shadow: 0 0 0 3px rgba(255,189,89,.12);
      border-color: rgba(255,189,89,.30);
    }

    #controls button:active{ transform: scale(.99); }

    /* primary button feel */
    #controls button{ border-color: rgba(255,189,89,.22); }
    #controls button:hover{
      border-color: rgba(255,189,89,.28);
      box-shadow: 0 0 0 3px rgba(255,189,89,.10);
    }

    /* special toggles */
    #realtime-toggle-btn{ border-color: rgba(77,211,255,.28); }
    #realtime-toggle-btn.active{
      background: rgba(77,211,255,.18);
      border-color: rgba(77,211,255,.40);
      color: rgba(244,246,255,.92);
      box-shadow: 0 0 0 3px rgba(77,211,255,.10);
    }

    #draw-circle.active{
      background: rgba(0,255,255,.18);
      border-color: rgba(0,255,255,.42);
      color: rgba(244,246,255,.95);
      box-shadow: 0 0 0 3px rgba(0,255,255,.10);
    }

    #note-mode.active{
      background: rgba(255,189,89,.14);
      border-color: rgba(255,189,89,.40);
      box-shadow: 0 0 0 3px rgba(255,189,89,.10);
    }

    /* row buttons */
    .button-row{
      display:flex;
      gap: 8px;
    }
    .button-row button{
      flex:1;
      white-space:nowrap;
    }

    #import-file{ display:none; }

    /* notes */
    .note{
      position:absolute;
      background: rgba(255,255,255,.92);
      color: #000;
      border: 1px solid rgba(0,0,0,.28);
      border-radius: 10px;
      max-width: 220px;
      overflow:hidden;
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      user-select: text;
      z-index: 30;
    }
    .drag-handle{
      background: rgba(0,0,0,.12);
      padding: 4px 8px;
      font-weight: 1000;
      cursor: grab;
      user-select:none;
      touch-action:none;
    }
    .note div[contenteditable]{
      padding: 6px 8px;
      min-height: 20px;
      outline:none;
      font-size: 12px;
      line-height: 1.2rem;
    }

    /* footer user info */
    #user-info{
      font-size: .78rem;
      text-align:center;
      margin-top: 10px;
      color: rgba(170,177,197,.85);
      user-select:text;
    }
  </style>
</head>

<body>
  <div id="main">
    <div id="map-container">
      <div id="map">
        <canvas id="maskCanvas"></canvas>
        <canvas id="pathCanvas"></canvas>
      </div>
    </div>

    <div id="sidebar">
      <!-- ✅ side-head removed -->

      <div class="icon-grid" id="teamIcons"></div>

      <div id="controls">
        <select id="map-select">
          <option value="https://i.imgur.com/V6iUHaA.jpeg" data-mode="">Bermuda</option>
          <option value="https://i.imgur.com/ieY0LHk.jpeg" data-mode="">Purgatory</option>
          <option value="https://i.imgur.com/48O1Jf8.jpeg" data-mode="">Alpine</option>
          <option value="https://i.imgur.com/4Yz12P9.jpeg" data-mode="">Kalahari</option>
          <option value="https://i.imgur.com/x5he05R.jpeg" data-mode="">NeXTerra</option>
          <option value="https://i.imgur.com/IX1oY9Z.jpeg" data-mode="">Solara</option>
        </select>

        <button id="realtime-toggle-btn" type="button">Real-time: ON</button>

        <div class="button-row">
          <button id="draw-circle" type="button">Draw Circle</button>
          <button id="note-mode" type="button">Add Note</button>
        </div>

        <button id="undo-btn" type="button">Undo</button>
        <button id="reset-all-btn" type="button">Reset All</button>

        <div class="button-row">
          <button id="export-btn" type="button">Export</button>
          <button type="button" onclick="document.getElementById('import-file').click()">Import</button>
        </div>

        <input type="file" id="import-file" accept=".json" />

        <div class="button-row">
          <button type="button" onclick="location.href='dashboard.html'">← Dashboard</button>
          <button type="button" onclick="location.href='team_settings.html'">Team Settings</button>
        </div>

        <button id="logoutBtn" type="button">Logout</button>

        <p id="user-info">Checking login...</p>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * Supabase
     ***********************/
    const client = supabase.createClient(
      'https://ooutjrewmwsixghbouxi.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9vdXRqcmV3bXdzaXhnaGJvdXhpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwMjg3NTMsImV4cCI6MjA4MjYwNDc1M30.13WkdGiQH39lZH3iDgVDd_tZrHlI0twhGeiZNdwaMSg'
    );

    async function ensureSession(){
      const { data: { session } } = await client.auth.getSession();
      if (!session) {
        window.location.href = "index.html";
        return null;
      }
      return session;
    }

    async function logout(){
      await client.auth.signOut();
      window.location.href = "index.html";
    }

    document.getElementById("logoutBtn").addEventListener("click", logout);

    /***********************
     * Fixed base + scaling on small screens
     ***********************/
    const MAIN_W = 1112, MAIN_H = 800;
    const mainEl = document.getElementById("main");

    function fitMainToScreen(){
      const pad = 16;
      const vw = window.innerWidth - pad;
      const vh = window.innerHeight - pad;
      const s = Math.min(1, vw / MAIN_W, vh / MAIN_H);
      mainEl.style.transform = `scale(${s})`;
    }

    window.addEventListener("resize", () => {
      fitMainToScreen();
      resizeCanvases();
    });

    /***********************
     * Canvas + drawing
     ***********************/
    const map = document.getElementById("map");
    const mapSelect = document.getElementById("map-select");
    const canvas = document.getElementById("pathCanvas");
    const ctx = canvas.getContext("2d");
    const maskCanvas = document.getElementById("maskCanvas");
    const ctxMask = maskCanvas.getContext("2d");

    function setMapBg(){
      map.style.backgroundImage = `url('${mapSelect.value}')`;
    }
    setMapBg();

    function resizeCanvases(){
      const dpr = window.devicePixelRatio || 1;

      // path canvas
      canvas.width = Math.round(map.clientWidth * dpr);
      canvas.height = Math.round(map.clientHeight * dpr);
      canvas.style.width = map.clientWidth + "px";
      canvas.style.height = map.clientHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // mask canvas
      maskCanvas.width = Math.round(map.clientWidth * dpr);
      maskCanvas.height = Math.round(map.clientHeight * dpr);
      maskCanvas.style.width = map.clientWidth + "px";
      maskCanvas.style.height = map.clientHeight + "px";
      ctxMask.setTransform(dpr, 0, 0, dpr, 0, 0);

      drawAll();
      const selectedOption = mapSelect.options[mapSelect.selectedIndex];
      if (selectedOption?.dataset.mode === "CS") drawOverlayMask(circles);
      else maskCanvas.style.display = "none";
    }

    function drawArrow(from, to, color) {
      const dx = to.x - from.x, dy = to.y - from.y;
      const angle = Math.atan2(dy, dx);
      ctx.beginPath();
      ctx.shadowColor = color;
      ctx.shadowBlur = 6;
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.lineTo(to.x - 10 * Math.cos(angle - Math.PI / 6), to.y - 10 * Math.sin(angle - Math.PI / 6));
      ctx.moveTo(to.x, to.y);
      ctx.lineTo(to.x - 10 * Math.cos(angle + Math.PI / 6), to.y - 10 * Math.sin(angle + Math.PI / 6));
      ctx.strokeStyle = color;
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    /***********************
     * State
     ***********************/
    const teamPaths = {};      // { teamId: [{x,y}, ...] }
    const teamIcons = {};      // { teamId: DOMElement }
    const circles = [];        // [{x,y,r,color}]
    const notesData = [];      // [{id,x,y,text}]

    const historyStack = [];   // undo stack

    let selectedIcon = null;
    let activeTeam = null;

    let drawCircleMode = false;
    let noteMode = false;

    const DRAG_THRESHOLD = 8; // px

    const teamColors = [
      "#FF0000", "#00FF00", "#00FFFF", "#FFFF00", "#FF00FF", "#FFA500",
      "#00BFFF", "#FF69B4", "#7FFF00", "#FF4500", "#00FF7F", "#1E90FF",
      "#FFD700", "#ADFF2F", "#FF1493", "#40E0D0", "#FF6347", "#87CEEB"
    ];

    function typeSortIndex(id){
      const n = parseInt(String(id).replace("team",""), 10);
      return Number.isFinite(n) ? (n-1) : 0;
    }

    /***********************
     * Coordinate helpers (✅ correct under scaling + iOS)
     ***********************/
    function pointerToLocal(e){
      const rect = map.getBoundingClientRect();
      // map.clientWidth/Height are the unscaled base size (because transform doesn't change layout)
      const sx = map.clientWidth / rect.width;
      const sy = map.clientHeight / rect.height;

      return {
        x: (e.clientX - rect.left) * sx,
        y: (e.clientY - rect.top) * sy
      };
    }

    /***********************
     * Circles: hit tests
     ***********************/
    function findCircleResize(pt) {
      for (let i = circles.length - 1; i >= 0; i--) {
        const c = circles[i];
        const dist = Math.hypot(c.x - pt.x, c.y - pt.y);
        if (Math.abs(dist - c.r) < 12) return c;
      }
      return null;
    }

    function findCircleDrag(pt) {
      for (let i = circles.length - 1; i >= 0; i--) {
        const c = circles[i];
        const dist = Math.hypot(c.x - pt.x, c.y - pt.y);
        if (dist < c.r) return c;
      }
      return null;
    }

    /***********************
     * Notes
     ***********************/
    function createNote(x, y, text, forcedId){
      const noteId = forcedId || ("n_" + Math.random().toString(16).slice(2));
      const noteDiv = document.createElement("div");
      noteDiv.className = "note";
      noteDiv.dataset.noteId = noteId;
      noteDiv.style.left = `${x}px`;
      noteDiv.style.top = `${y}px`;

      const handle = document.createElement("div");
      handle.className = "drag-handle";
      handle.textContent = "☰";

      const content = document.createElement("div");
      content.textContent = text || "";
      content.contentEditable = true;

      noteDiv.appendChild(handle);
      noteDiv.appendChild(content);
      map.appendChild(noteDiv);

      // store data
      if (!notesData.find(n => n.id === noteId)) {
        notesData.push({ id: noteId, x, y, text: text || "" });
        historyStack.push({ type: "note", id: noteId });
      }

      // update text on edit
      content.addEventListener("input", () => {
        const nd = notesData.find(n => n.id === noteId);
        if (nd) nd.text = content.textContent || "";
        saveMapState();
      });

      // pointer-drag with handle only
      let dragging = false;
      let offX = 0, offY = 0;

      handle.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        handle.setPointerCapture(e.pointerId);
        dragging = true;
        const p = pointerToLocal(e);
        offX = p.x - noteDiv.offsetLeft;
        offY = p.y - noteDiv.offsetTop;
      });

      handle.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        e.preventDefault();
        e.stopPropagation();
        const p = pointerToLocal(e);
        const nx = p.x - offX;
        const ny = p.y - offY;
        noteDiv.style.left = `${nx}px`;
        noteDiv.style.top = `${ny}px`;

        const nd = notesData.find(n => n.id === noteId);
        if (nd){ nd.x = nx; nd.y = ny; }
        drawAll();
      });

      handle.addEventListener("pointerup", (e) => {
        if (!dragging) return;
        e.preventDefault();
        e.stopPropagation();
        dragging = false;
        saveMapState();
      });

      handle.addEventListener("pointercancel", () => { dragging = false; });

      return noteDiv;
    }

    /***********************
     * Units
     ***********************/
    function createUnit(teamIconEl, teamId, x, y){
      const div = document.createElement("div");
      div.className = "unit";
      div.style.left = `${x - 15}px`;
      div.style.top = `${y - 15}px`;

      const img = teamIconEl.cloneNode(true);
      img.classList.remove("selected");
      img.style.width = img.style.height = "30px";

      const label = document.createElement("div");
      label.className = "unit-label";
      label.textContent = teamIconEl.dataset.teamTag || teamId;

      const reset = document.createElement("button");
      reset.className = "reset-btn";
      reset.textContent = "Reset";
      reset.addEventListener("pointerdown", (e) => { e.stopPropagation(); });
      reset.addEventListener("click", (e) => {
        e.stopPropagation();
        div.remove();
        delete teamPaths[teamId];
        delete teamIcons[teamId];
        if (activeTeam === teamId) activeTeam = null;
        drawAll();
        saveMapState();
      });

      div.append(img, label, reset);
      map.appendChild(div);

      // select active team on tap
      div.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
        activeTeam = teamId;
      });

      return div;
    }

    /***********************
     * Drawing
     ***********************/
    function drawAll(){
      ctx.clearRect(0,0,map.clientWidth,map.clientHeight);

      // circles
      for (const c of circles) {
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.r, 0, 2 * Math.PI);
        ctx.strokeStyle = c.color;
        ctx.setLineDash([3, 1]);
        ctx.lineWidth = 5;
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.beginPath();
        ctx.arc(c.x + c.r, c.y, 4, 0, 2 * Math.PI);
        ctx.fillStyle = c.color;
        ctx.fill();
      }

      // team paths
      for (const id in teamPaths) {
        const path = teamPaths[id];
        const idx = typeSortIndex(id);
        const color = teamColors[idx] || "#fff";
        for (let j = 0; j < path.length - 1; j++) {
          drawArrow(path[j], path[j + 1], color);
        }
      }
    }

    function drawOverlayMask(circlesToReveal) {
      maskCanvas.style.display = "block";

      ctxMask.clearRect(0,0,map.clientWidth,map.clientHeight);
      ctxMask.fillStyle = "rgba(0, 0, 0, 0.75)";
      ctxMask.fillRect(0, 0, map.clientWidth, map.clientHeight);

      ctxMask.globalCompositeOperation = "destination-out";
      circlesToReveal.forEach(c => {
        ctxMask.beginPath();
        ctxMask.arc(c.x, c.y, c.r, 0, 2 * Math.PI);
        ctxMask.fill();
      });
      ctxMask.globalCompositeOperation = "source-over";
    }

    /***********************
     * Team icons (Supabase)
     ***********************/
    async function loadTeamIcons() {
      const grid = document.getElementById("teamIcons");
      grid.innerHTML = "";

      const { data, error } = await client
        .from("teams_pathplanner")
        .select("id, team_name, team_tag, logo_url")
        .order("id", { ascending: true });

      if (error) {
        console.error("❌ Failed to load teams:", error);
        const msg = document.createElement("p");
        msg.textContent = "Failed to load teams.";
        msg.style.fontSize = "0.8rem";
        msg.style.color = "#aaa";
        msg.style.gridColumn = "1 / -1";
        grid.appendChild(msg);
        return;
      }

      if (!data || !data.length) {
        const msg = document.createElement("p");
        msg.textContent = "No teams configured. Go to Team Settings to add some.";
        msg.style.fontSize = "0.8rem";
        msg.style.color = "#aaa";
        msg.style.gridColumn = "1 / -1";
        grid.appendChild(msg);
        return;
      }

      data.slice(0, teamColors.length).forEach((team, i) => {
        const wrapper = document.createElement("div");
        wrapper.style.display = "flex";
        wrapper.style.flexDirection = "column";
        wrapper.style.alignItems = "center";

        const img = document.createElement("img");
        img.src = team.logo_url;
        img.alt = team.team_name || team.team_tag || `Team ${i + 1}`;
        img.className = "team-icon";

        const teamId = "team" + (i + 1);
        img.dataset.id = teamId;
        img.dataset.teamTag = team.team_tag || "";
        img.dataset.teamName = team.team_name || "";
        img.dataset.teamDbId = team.id;
        img.title = `${team.team_name || "Team"} (${team.team_tag || "TAG"})`;

        img.addEventListener("click", () => {
          // highlight selection
          document.querySelectorAll(".team-icon").forEach(el => el.classList.remove("selected"));
          img.classList.add("selected");
          selectedIcon = img;
        });

        const colorBar = document.createElement("div");
        colorBar.style.width = "60%";
        colorBar.style.height = "6px";
        colorBar.style.marginTop = "6px";
        colorBar.style.borderRadius = "999px";
        colorBar.style.backgroundColor = teamColors[i] || "#fff";
        colorBar.style.boxShadow = "0 8px 18px rgba(0,0,0,.35)";

        wrapper.appendChild(img);
        wrapper.appendChild(colorBar);
        grid.appendChild(wrapper);
      });
    }

    /***********************
     * Buttons: modes
     ***********************/
    const drawCircleBtn = document.getElementById("draw-circle");
    const noteBtn = document.getElementById("note-mode");

    drawCircleBtn.onclick = () => {
      drawCircleMode = !drawCircleMode;
      drawCircleBtn.textContent = drawCircleMode ? "Circle Mode: ON" : "Draw Circle";
      drawCircleBtn.classList.toggle("active", drawCircleMode);
    };

    noteBtn.onclick = () => {
      noteMode = !noteMode;
      noteBtn.textContent = noteMode ? "Note Mode: ON" : "Add Note";
      noteBtn.classList.toggle("active", noteMode);
    };

    /***********************
     * Map interactions (✅ pointer-based tap vs drag)
     * Fixes: "can't place team logo inside circle"
     ***********************/
    let down = false;
    let moved = false;
    let downLocal = {x:0,y:0};

    let candResize = null;
    let candDrag = null;
    let resizingCircle = null;
    let draggingCircle = null;

    map.addEventListener("pointerdown", (e) => {
      if (e.target?.closest && e.target.closest(".note")) return;
      if (e.target?.closest && e.target.closest(".unit")) return;

      e.preventDefault();
      map.setPointerCapture(e.pointerId);

      down = true;
      moved = false;
      downLocal = pointerToLocal(e);

      // candidates only (do not lock drag yet)
      candResize = findCircleResize(downLocal);
      candDrag = candResize ? null : findCircleDrag(downLocal);

      resizingCircle = null;
      draggingCircle = null;
    });

    map.addEventListener("pointermove", (e) => {
      if (!down) return;
      e.preventDefault();

      const p = pointerToLocal(e);
      const dist = Math.hypot(p.x - downLocal.x, p.y - downLocal.y);

      // start drag only after threshold
      if (!moved && dist > DRAG_THRESHOLD) {
        moved = true;
        resizingCircle = candResize;
        draggingCircle = candDrag;
      }

      if (!moved) return;

      if (resizingCircle) {
        resizingCircle.r = Math.max(10, Math.hypot(p.x - resizingCircle.x, p.y - resizingCircle.y));
        drawAll();
        return;
      }

      if (draggingCircle) {
        draggingCircle.x = p.x;
        draggingCircle.y = p.y;
        drawAll();
      }
    });

    map.addEventListener("pointerup", (e) => {
      if (!down) return;
      e.preventDefault();
      down = false;

      // if we dragged a circle -> save and exit
      if (moved && (resizingCircle || draggingCircle)) {
        candResize = candDrag = null;
        resizingCircle = draggingCircle = null;
        saveMapState();
        return;
      }

      // tap
      candResize = candDrag = null;
      resizingCircle = draggingCircle = null;

      // ignore taps on notes/units (safety)
      if (e.target?.closest && (e.target.closest(".note") || e.target.closest(".unit"))) return;

      const { x, y } = pointerToLocal(e);

      if (noteMode) {
        const text = prompt("Enter note:");
        if (!text) return;
        createNote(x, y, text);
        noteMode = false;
        noteBtn.textContent = "Add Note";
        noteBtn.classList.remove("active");
        saveMapState();
        return;
      }

      if (drawCircleMode) {
        circles.push({ x, y, r: 30, color: "#00ffff" });
        historyStack.push({ type: "circle" });
        drawAll();
        saveMapState();
        return;
      }

      if (selectedIcon) {
        const id = selectedIcon.dataset.id;
        if (teamIcons[id]) {
          // already placed; just set active team
          activeTeam = id;
          selectedIcon.classList.remove("selected");
          selectedIcon = null;
          return;
        }

        const unit = createUnit(selectedIcon, id, x, y);
        teamIcons[id] = unit;
        teamPaths[id] = [{ x, y }];
        activeTeam = id;

        selectedIcon.classList.remove("selected");
        selectedIcon = null;

        historyStack.push({ type: "line", team: id });
        drawAll();
        saveMapState();
        return;
      }

      if (activeTeam) {
        if (!teamPaths[activeTeam]) return;
        teamPaths[activeTeam].push({ x, y });
        historyStack.push({ type: "line", team: activeTeam });
        drawAll();
        saveMapState();
      }
    });

    map.addEventListener("pointercancel", () => {
      down = false; moved = false;
      candResize = candDrag = null;
      resizingCircle = draggingCircle = null;
    });

    /***********************
     * Undo / Reset / Export / Import
     ***********************/
    document.getElementById("undo-btn").onclick = () => {
      const last = historyStack.pop();
      if (!last) return;

      if (last.type === "circle") {
        circles.pop();
      } else if (last.type === "line") {
        const path = teamPaths[last.team];
        if (path) {
          path.pop();
          if (path.length === 0) {
            delete teamPaths[last.team];
            const icon = teamIcons[last.team];
            if (icon) icon.remove();
            delete teamIcons[last.team];
            if (activeTeam === last.team) activeTeam = null;
          }
        }
      } else if (last.type === "note") {
        const id = last.id;
        const el = map.querySelector(`.note[data-note-id="${id}"]`);
        if (el) el.remove();
        const idx = notesData.findIndex(n => n.id === id);
        if (idx !== -1) notesData.splice(idx, 1);
      }

      drawAll();
      saveMapState();
    };

    document.getElementById("reset-all-btn").onclick = () => {
      if (!confirm("Reset all?")) return;

      // remove units
      Object.values(teamIcons).forEach(el => el?.remove());
      Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
      Object.keys(teamPaths).forEach(k => delete teamPaths[k]);

      // remove notes
      map.querySelectorAll(".note").forEach(n => n.remove());
      notesData.length = 0;

      circles.length = 0;
      activeTeam = null;
      selectedIcon = null;

      // clear icon selection highlight
      document.querySelectorAll(".team-icon").forEach(el => el.classList.remove("selected"));

      historyStack.length = 0;

      drawAll();
      saveMapState();
    };

    document.getElementById("export-btn").onclick = () => {
      const data = {
        map: mapSelect.value,
        paths: teamPaths,
        circles,
        notes: notesData
      };
      const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "team-paths.json";
      a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById("import-file").onchange = function () {
      const file = this.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const data = JSON.parse(e.target.result);

        if (data.map) {
          mapSelect.value = data.map;
          setMapBg();
        }

        // clear current
        Object.values(teamIcons).forEach(el => el?.remove());
        Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
        Object.keys(teamPaths).forEach(k => delete teamPaths[k]);
        circles.length = 0;
        map.querySelectorAll(".note").forEach(n => n.remove());
        notesData.length = 0;
        activeTeam = null;
        selectedIcon = null;
        historyStack.length = 0;

        // restore paths
        Object.entries(data.paths || {}).forEach(([id, points]) => {
          const icon = document.querySelector(`.team-icon[data-id="${id}"]`);
          if (!icon || !points?.length) return;

          const first = points[0];
          const unit = createUnit(icon, id, first.x, first.y);
          teamIcons[id] = unit;
          teamPaths[id] = points.map(p => ({ x: p.x, y: p.y }));
        });

        // restore circles
        (data.circles || []).forEach(c => circles.push({ x:c.x, y:c.y, r:c.r, color:c.color || "#00ffff" }));

        // restore notes
        (data.notes || []).forEach(n => {
          createNote(n.x, n.y, n.text || "", n.id);
          // ensure data stored
          if (!notesData.find(x => x.id === n.id)) notesData.push({ id:n.id, x:n.x, y:n.y, text:n.text || "" });
        });

        drawAll();
        saveMapState();
      };
      reader.readAsText(file);
      this.value = "";
    };

    /***********************
     * Map select change
     ***********************/
    mapSelect.addEventListener("change", () => {
      setMapBg();

      const selectedOption = mapSelect.options[mapSelect.selectedIndex];
      const mode = selectedOption.dataset.mode || "";

      if (mode === "CS") {
        drawOverlayMask(circles);
      } else {
        maskCanvas.style.display = "none";
      }

      saveMapState();
    });

    /***********************
     * Realtime + DB state
     ***********************/
    let realtimeEnabled = true;
    let realtimeChannel = null;

    async function loadMapState() {
      const { data, error } = await client
        .from('map')
        .select('state')
        .eq('id', 1)
        .maybeSingle();

      if (error && error.code !== 'PGRST116') {
        console.error('❌ Failed to load map state:', error);
        return;
      }

      if (!data || !data.state) {
        // create default row
        await saveMapState();
        return;
      }

      applyMapState(data.state);
    }

    async function saveMapState() {
      const state = {
        map: mapSelect.value,
        paths: teamPaths,
        circles,
        notes: notesData
      };

      const { error } = await client
        .from('map')
        .upsert({
          id: 1,
          state,
          updated_at: new Date().toISOString()
        });

      if (error) console.error('❌ Failed to save map state:', error);
    }

    function applyMapState(state) {
      // map
      if (state?.map) {
        mapSelect.value = state.map;
        setMapBg();
      }

      // clear current
      Object.values(teamIcons).forEach(el => el?.remove());
      Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
      Object.keys(teamPaths).forEach(k => delete teamPaths[k]);

      circles.length = 0;

      map.querySelectorAll(".note").forEach(n => n.remove());
      notesData.length = 0;

      activeTeam = null;
      selectedIcon = null;
      document.querySelectorAll(".team-icon").forEach(el => el.classList.remove("selected"));

      // restore paths
      Object.entries(state?.paths || {}).forEach(([id, points]) => {
        const icon = document.querySelector(`.team-icon[data-id="${id}"]`);
        if (!icon || !points?.length) return;

        const first = points[0];
        const unit = createUnit(icon, id, first.x, first.y);
        teamIcons[id] = unit;
        teamPaths[id] = points.map(p => ({ x: p.x, y: p.y }));
      });

      // circles
      (state?.circles || []).forEach(c => circles.push({ x:c.x, y:c.y, r:c.r, color:c.color || "#00ffff" }));

      // notes
      (state?.notes || []).forEach(n => {
        createNote(n.x, n.y, n.text || "", n.id);
        if (!notesData.find(x => x.id === n.id)) notesData.push({ id:n.id, x:n.x, y:n.y, text:n.text || "" });
      });

      drawAll();

      const selectedOption = mapSelect.options[mapSelect.selectedIndex];
      if (selectedOption?.dataset.mode === "CS") drawOverlayMask(circles);
      else maskCanvas.style.display = "none";
    }

    function handleMapChange(payload) {
      if (!realtimeEnabled) return;
      const row = payload.new;
      if (!row || row.id !== 1) return;
      applyMapState(row.state || {});
    }

    async function enableRealtime() {
      if (realtimeChannel) return;

      realtimeChannel = client
        .channel('public:map')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'map' }, handleMapChange)
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'map' }, handleMapChange);

      const { error } = await realtimeChannel.subscribe();
      if (error) console.error("❌ Error subscribing to real-time:", error.message);
    }

    async function disableRealtime() {
      if (!realtimeChannel) return;
      await client.removeChannel(realtimeChannel);
      realtimeChannel = null;
    }

    /***********************
     * Realtime toggle
     ***********************/
    const realtimeBtn = document.getElementById("realtime-toggle-btn");
    realtimeBtn.onclick = async () => {
      realtimeEnabled = !realtimeEnabled;
      realtimeBtn.textContent = realtimeEnabled ? "Real-time: ON" : "Real-time: OFF";
      realtimeBtn.classList.toggle("active", realtimeEnabled);

      if (realtimeEnabled) await enableRealtime();
      else await disableRealtime();
    };

    /***********************
     * Init
     ***********************/
    window.addEventListener("DOMContentLoaded", async () => {
      fitMainToScreen();

      const session = await ensureSession();
      if (!session) return;

      document.getElementById("user-info").textContent =
        "Logged in as: " + (session.user?.email || "unknown");

      await loadTeamIcons();
      setMapBg();

      resizeCanvases();

      await loadMapState();
      await enableRealtime();

      realtimeBtn.textContent = realtimeEnabled ? "Real-time: ON" : "Real-time: OFF";
      realtimeBtn.classList.toggle("active", realtimeEnabled);
    });
  </script>
</body>
</html>
