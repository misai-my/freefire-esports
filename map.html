<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Team Path Planner</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">

  <!-- Supabase JS v2 (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg:#07090f;
      --bg2:#0b1020;
      --line: rgba(255,255,255,.10);
      --ink:#f4f6ff;
      --muted:#aab1c5;

      --brand:#ffbd59;
      --accent:#4dd3ff;

      --shadow: 0 22px 70px rgba(0,0,0,.55);
      --radius-lg: 18px;

      /* Desktop fixed intent */
      --main-w: 1112px;
      --main-h: 800px;

      --sidebar-w: 320px;
      --map-w: 792px; /* 1112 - 320 */

      /* Phone layout */
      --phone-panel-h: 320px;
    }

    *{ box-sizing:border-box; }
    html, body{
      margin:0; padding:0;
      width:100vw; height:100vh;
      overflow:hidden;
      font-family: Roboto, system-ui, -apple-system, Segoe UI, Arial;
      color: var(--ink);
      background:
        radial-gradient(900px 500px at 18% 12%, rgba(77,211,255,.15), transparent 60%),
        radial-gradient(700px 420px at 85% 18%, rgba(255,189,89,.12), transparent 60%),
        radial-gradient(900px 620px at 50% 110%, rgba(255,119,51,.10), transparent 60%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      display:flex;
      align-items:center;
      justify-content:center;

      -webkit-touch-callout:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }

    /* Desktop fixed canvas frame */
    #main{
      width: var(--main-w);
      height: var(--main-h);
      display:flex;
      overflow:hidden;
      border-radius: var(--radius-lg);
      border: 1px solid var(--line);
      background: rgba(0,0,0,.22);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      position: relative;
    }

    /* Map area */
    #map-container{
      width: var(--map-w);
      height: 100%;
      position: relative;
      background: rgba(0,0,0,.35);
      border-right: 1px solid rgba(255,255,255,.06);
      overflow:hidden;
    }

    #map{
      width:100%;
      height:100%;
      position: relative;

      /* IMPORTANT: keep touch + pointer reliable on iOS */
      touch-action: none;

      /* IMPORTANT: linear mapping across devices (no letterboxing math) */
      background-size: 100% 100%;
      background-position:center;
      background-repeat:no-repeat;
    }

    #maskCanvas, #pathCanvas{
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }
    #maskCanvas{ z-index: 9; }
    #pathCanvas{ z-index: 10; }

    /* Sidebar */
    #sidebar{
      width: var(--sidebar-w);
      height: 100%;
      display:flex;
      flex-direction:column;
      padding: 12px;
      background: rgba(14, 18, 28, .70);
      border-left: 1px solid rgba(255,255,255,.06);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      overflow:hidden;
    }

    /* Team icons */
    .icon-grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      justify-items:center;
      padding: 8px;
      border-radius: 14px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      margin-bottom: 10px;
    }

    .team-icon{
      width: 50px;
      height: 55px;
      border-radius: 12px;
      cursor:pointer;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      object-fit: cover;
      touch-action:none;
    }
    .team-icon.selected{
      outline: 2px solid rgba(255,189,89,.55);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(255,189,89,.12);
    }

    /* Controls */
    #controls{
      flex:1;
      display:flex;
      flex-direction:column;
      gap: 8px;
      overflow-y:auto;
      padding-right: 6px;
    }
    #controls::-webkit-scrollbar{ width:10px; }
    #controls::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.10); border-radius: 10px; }
    #controls::-webkit-scrollbar-track{ background: transparent; }

    #controls button, #map-select{
      width: 100%;
      padding: 10px 10px;
      font-weight: 900;
      font-size: 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: rgba(244,246,255,.90);
      cursor:pointer;
      transition: .18s ease;
    }

    #map-select{
      background: rgba(0,0,0,.28);
      color: rgba(244,246,255,.92);
    }
    #map-select option, #map-select optgroup{
      background: #0e111a;
      color: rgba(244,246,255,.92);
    }

    .button-row{ display:flex; gap: 8px; }
    .button-row button{ flex:1; white-space:nowrap; }

    #realtime-toggle-btn{ border-color: rgba(77,211,255,.28); }
    #realtime-toggle-btn.active{
      background: rgba(77,211,255,.18);
      border-color: rgba(77,211,255,.40);
      box-shadow: 0 0 0 3px rgba(77,211,255,.10);
    }

    #draw-circle.active{
      background: rgba(0,255,255,.18);
      border-color: rgba(0,255,255,.42);
      box-shadow: 0 0 0 3px rgba(0,255,255,.10);
    }

    #note-mode.active{
      background: rgba(255,189,89,.14);
      border-color: rgba(255,189,89,.40);
      box-shadow: 0 0 0 3px rgba(255,189,89,.10);
    }

    #import-file{ display:none; }

    /* Unit */
    .unit{
      position:absolute;
      width:30px; height:30px;
      background: rgba(255,255,255,.10);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      z-index: 20;
      touch-action:none;
    }
    .unit img{
      width:100%; height:100%;
      border-radius:999px;
      box-shadow: 0 0 12px 2px rgba(255,255,255,0.35);
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.35);
      display:block;
      pointer-events:none;
    }
    .unit-label{
      position:absolute;
      top:-18px; left:50%;
      transform: translateX(-50%);
      font-size: 12px;
      font-weight: 900;
      background: rgba(0,0,0,.55);
      color: rgba(244,246,255,.92);
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.10);
      white-space:nowrap;
      pointer-events:none;
    }
    .reset-btn{
      position:absolute;
      bottom:-20px; left:50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,.92);
      color:#000;
      font-size: 10px;
      font-weight: 900;
      padding: 2px 6px;
      border: none;
      border-radius: 8px;
      cursor:pointer;
      touch-action:none;
    }

    /* Notes */
    .note{
      position:absolute;
      background: rgba(255,255,255,.92);
      color: #000;
      border: 1px solid rgba(0,0,0,.28);
      border-radius: 10px;
      max-width: 220px;
      overflow:hidden;
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      user-select: text;
      z-index: 30;
    }
    .drag-handle{
      background: rgba(0,0,0,.12);
      padding: 4px 8px;
      font-weight: 1000;
      cursor: grab;
      user-select:none;
      touch-action:none;
    }
    .note div[contenteditable]{
      padding: 6px 8px;
      min-height: 20px;
      outline:none;
      font-size: 12px;
      line-height: 1.2rem;
    }

    #user-info{
      font-size: .78rem;
      text-align:center;
      margin-top: 10px;
      color: rgba(170,177,197,.85);
      user-select:text;
    }

    /* ✅ PHONE ONLY: stack layout (map full screen, controls bottom) */
    @media (max-width: 700px){
      body{ align-items:stretch; justify-content:stretch; }
      #main{
        width:100vw;
        height:100vh;
        border-radius:0;
        flex-direction:column;
      }
      #map-container{
        width:100%;
        height: calc(100vh - var(--phone-panel-h));
        border-right:none;
        border-bottom: 1px solid rgba(255,255,255,.06);
      }
      #sidebar{
        width:100%;
        height: var(--phone-panel-h);
        border-left:none;
      }
      .icon-grid{
        grid-template-columns: repeat(6, 1fr);
      }
      .team-icon{
        width: 44px;
        height: 48px;
      }
      #controls button, #map-select{
        font-size: 13px;
        padding: 12px 10px;
      }
    }

    @media (max-width: 700px) and (orientation: landscape){
      :root{ --phone-panel-h: 240px; }
    }
  </style>
</head>

<body>
  <div id="main">
    <div id="map-container">
      <div id="map">
        <canvas id="maskCanvas"></canvas>
        <canvas id="pathCanvas"></canvas>
      </div>
    </div>

    <div id="sidebar">
      <div class="icon-grid" id="teamIcons"></div>

      <div id="controls">
        <select id="map-select">
          <option value="https://i.imgur.com/V6iUHaA.jpeg" data-mode="">Bermuda</option>
          <option value="https://i.imgur.com/ieY0LHk.jpeg" data-mode="">Purgatory</option>
          <option value="https://i.imgur.com/48O1Jf8.jpeg" data-mode="">Alpine</option>
          <option value="https://i.imgur.com/4Yz12P9.jpeg" data-mode="">Kalahari</option>
          <option value="https://i.imgur.com/x5he05R.jpeg" data-mode="">NeXTerra</option>
          <option value="https://i.imgur.com/IX1oY9Z.jpeg" data-mode="">Solara</option>
        </select>

        <button id="realtime-toggle-btn" type="button">Real-time: ON</button>

        <div class="button-row">
          <button id="draw-circle" type="button">Draw Circle</button>
          <button id="note-mode" type="button">Add Note</button>
        </div>

        <button id="undo-btn" type="button">Undo</button>
        <button id="reset-all-btn" type="button">Reset All</button>

        <div class="button-row">
          <button id="export-btn" type="button">Export</button>
          <button type="button" onclick="document.getElementById('import-file').click()">Import</button>
        </div>

        <input type="file" id="import-file" accept=".json" />

        <div class="button-row">
          <button type="button" onclick="location.href='dashboard.html'">← Dashboard</button>
          <button type="button" onclick="location.href='team_settings.html'">Team Settings</button>
        </div>

        <button id="logoutBtn" type="button">Logout</button>

        <p id="user-info">Checking login...</p>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * Supabase
     ***********************/
    const client = supabase.createClient(
      'https://ooutjrewmwsixghbouxi.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9vdXRqcmV3bXdzaXhnaGJvdXhpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjcwMjg3NTMsImV4cCI6MjA4MjYwNDc1M30.13WkdGiQH39lZH3iDgVDd_tZrHlI0twhGeiZNdwaMSg'
    );

    async function ensureSession(){
      const { data: { session } } = await client.auth.getSession();
      if (!session) { window.location.href = "index.html"; return null; }
      return session;
    }
    async function logout(){
      await client.auth.signOut();
      window.location.href = "index.html";
    }
    document.getElementById("logoutBtn").addEventListener("click", logout);

    /***********************
     * LOGICAL COORDINATES (perfect sync across devices)
     * Map area is logically 792 x 800 always.
     ***********************/
    const LOGICAL_W = 792;
    const LOGICAL_H = 800;

    const map = document.getElementById("map");
    const mapSelect = document.getElementById("map-select");

    const pathCanvas = document.getElementById("pathCanvas");
    const ctx = pathCanvas.getContext("2d");

    const maskCanvas = document.getElementById("maskCanvas");
    const ctxMask = maskCanvas.getContext("2d");

    function setMapBg(){ map.style.backgroundImage = `url('${mapSelect.value}')`; }
    setMapBg();

    function clientToLogical(e){
      const rect = map.getBoundingClientRect();
      return {
        x: ((e.clientX - rect.left) / rect.width) * LOGICAL_W,
        y: ((e.clientY - rect.top) / rect.height) * LOGICAL_H
      };
    }

    function logicalToPx(p){
      return {
        x: (p.x / LOGICAL_W) * map.clientWidth,
        y: (p.y / LOGICAL_H) * map.clientHeight
      };
    }

    function scaleFactors(){
      return {
        sx: map.clientWidth / LOGICAL_W,
        sy: map.clientHeight / LOGICAL_H,
        s: Math.min(map.clientWidth / LOGICAL_W, map.clientHeight / LOGICAL_H)
      };
    }

    /***********************
     * State
     ***********************/
    const teamPaths = {};     // logical points
    const teamIcons = {};     // DOM
    const circles = [];       // logical
    const notesData = [];     // logical

    const historyStack = [];
    let selectedIcon = null;
    let activeTeam = null;

    let drawCircleMode = false;
    let noteMode = false;

    const DRAG_THRESHOLD_PX = 8;

    const teamColors = [
      "#FF0000", "#00FF00", "#00FFFF", "#FFFF00", "#FF00FF", "#FFA500",
      "#00BFFF", "#FF69B4", "#7FFF00", "#FF4500", "#00FF7F", "#1E90FF",
      "#FFD700", "#ADFF2F", "#FF1493", "#40E0D0", "#FF6347", "#87CEEB"
    ];

    function teamIndex(id){
      const n = parseInt(String(id).replace("team",""), 10);
      return Number.isFinite(n) ? (n-1) : 0;
    }

    /***********************
     * Resize canvases
     ***********************/
    function resizeCanvases(){
      const dpr = window.devicePixelRatio || 1;

      pathCanvas.width = Math.round(map.clientWidth * dpr);
      pathCanvas.height = Math.round(map.clientHeight * dpr);
      pathCanvas.style.width = map.clientWidth + "px";
      pathCanvas.style.height = map.clientHeight + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      maskCanvas.width = Math.round(map.clientWidth * dpr);
      maskCanvas.height = Math.round(map.clientHeight * dpr);
      maskCanvas.style.width = map.clientWidth + "px";
      maskCanvas.style.height = map.clientHeight + "px";
      ctxMask.setTransform(dpr, 0, 0, dpr, 0, 0);

      repositionOverlays();
      drawAll();

      const opt = mapSelect.options[mapSelect.selectedIndex];
      if (opt?.dataset.mode === "CS") drawOverlayMask(circles);
      else maskCanvas.style.display = "none";
    }
    window.addEventListener("resize", resizeCanvases);

    /***********************
     * Draw
     ***********************/
    function drawArrow(fromL, toL, color){
      const { sx, sy } = scaleFactors();
      const from = { x: fromL.x * sx, y: fromL.y * sy };
      const to   = { x: toL.x * sx,   y: toL.y * sy };

      const dx = to.x - from.x, dy = to.y - from.y;
      const angle = Math.atan2(dy, dx);

      ctx.beginPath();
      ctx.shadowColor = color;
      ctx.shadowBlur = 6;

      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);

      ctx.lineTo(to.x - 10 * Math.cos(angle - Math.PI / 6), to.y - 10 * Math.sin(angle - Math.PI / 6));
      ctx.moveTo(to.x, to.y);
      ctx.lineTo(to.x - 10 * Math.cos(angle + Math.PI / 6), to.y - 10 * Math.sin(angle + Math.PI / 6));

      ctx.strokeStyle = color;
      ctx.lineWidth = 4;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }

    function drawAll(){
      ctx.clearRect(0, 0, map.clientWidth, map.clientHeight);

      const { sx, sy, s } = scaleFactors();

      // circles
      for (const c of circles){
        const cx = c.x * sx, cy = c.y * sy;
        const r  = c.r * s;

        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, 2*Math.PI);
        ctx.strokeStyle = c.color || "#00ffff";
        ctx.setLineDash([3,1]);
        ctx.lineWidth = 5;
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.beginPath();
        ctx.arc(cx + r, cy, 4, 0, 2*Math.PI);
        ctx.fillStyle = c.color || "#00ffff";
        ctx.fill();
      }

      // paths
      for (const id in teamPaths){
        const path = teamPaths[id];
        const color = teamColors[teamIndex(id)] || "#fff";
        for (let i=0;i<path.length-1;i++){
          drawArrow(path[i], path[i+1], color);
        }
      }
    }

    function drawOverlayMask(circlesToReveal){
      maskCanvas.style.display = "block";
      ctxMask.clearRect(0,0,map.clientWidth,map.clientHeight);

      ctxMask.fillStyle = "rgba(0,0,0,0.75)";
      ctxMask.fillRect(0,0,map.clientWidth,map.clientHeight);

      const { sx, sy, s } = scaleFactors();
      ctxMask.globalCompositeOperation = "destination-out";
      circlesToReveal.forEach(c => {
        ctxMask.beginPath();
        ctxMask.arc(c.x*sx, c.y*sy, c.r*s, 0, 2*Math.PI);
        ctxMask.fill();
      });
      ctxMask.globalCompositeOperation = "source-over";
    }

    /***********************
     * Overlays: units + notes reposition on resize
     ***********************/
    function repositionOverlays(){
      // units
      for (const id in teamIcons){
        const el = teamIcons[id];
        const first = teamPaths[id]?.[0];
        if (!el || !first) continue;
        const p = logicalToPx(first);
        el.style.left = `${p.x - 15}px`;
        el.style.top  = `${p.y - 15}px`;
      }
      // notes
      document.querySelectorAll(".note").forEach(noteEl => {
        const id = noteEl.dataset.noteId;
        const n = notesData.find(x => x.id === id);
        if (!n) return;
        const p = logicalToPx(n);
        noteEl.style.left = `${p.x}px`;
        noteEl.style.top  = `${p.y}px`;
      });
    }

    /***********************
     * Circles hit tests (logical)
     ***********************/
    function findCircleResize(ptL){
      for (let i = circles.length - 1; i >= 0; i--){
        const c = circles[i];
        const dist = Math.hypot(c.x - ptL.x, c.y - ptL.y);
        if (Math.abs(dist - c.r) < 12) return c;
      }
      return null;
    }
    function findCircleDrag(ptL){
      for (let i = circles.length - 1; i >= 0; i--){
        const c = circles[i];
        const dist = Math.hypot(c.x - ptL.x, c.y - ptL.y);
        if (dist < c.r) return c;
      }
      return null;
    }

    /***********************
     * Notes
     ***********************/
    function createNote(logicalX, logicalY, text, forcedId, pushHistory=true){
      const id = forcedId || ("n_" + Math.random().toString(16).slice(2));

      const noteDiv = document.createElement("div");
      noteDiv.className = "note";
      noteDiv.dataset.noteId = id;

      const handle = document.createElement("div");
      handle.className = "drag-handle";
      handle.textContent = "☰";

      const content = document.createElement("div");
      content.contentEditable = true;
      content.textContent = text || "";

      noteDiv.appendChild(handle);
      noteDiv.appendChild(content);
      map.appendChild(noteDiv);

      if (!notesData.find(n => n.id === id)){
        notesData.push({ id, x: logicalX, y: logicalY, text: text || "" });
        if (pushHistory) historyStack.push({ type:"note", id });
      }

      // initial position
      const p = logicalToPx({ x: logicalX, y: logicalY });
      noteDiv.style.left = `${p.x}px`;
      noteDiv.style.top  = `${p.y}px`;

      content.addEventListener("input", () => {
        const nd = notesData.find(n => n.id === id);
        if (nd) nd.text = content.textContent || "";
        saveMapState();
      });

      // drag with pointer (store logical)
      let dragging = false;
      let offPxX = 0, offPxY = 0;

      handle.addEventListener("pointerdown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        handle.setPointerCapture(e.pointerId);
        dragging = true;

        const rect = map.getBoundingClientRect();
        const curLeft = parseFloat(noteDiv.style.left || "0");
        const curTop  = parseFloat(noteDiv.style.top  || "0");

        offPxX = (e.clientX - rect.left) - curLeft;
        offPxY = (e.clientY - rect.top)  - curTop;
      });

      handle.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        e.preventDefault();
        e.stopPropagation();

        const rect = map.getBoundingClientRect();
        const newPxX = (e.clientX - rect.left) - offPxX;
        const newPxY = (e.clientY - rect.top)  - offPxY;

        noteDiv.style.left = `${newPxX}px`;
        noteDiv.style.top  = `${newPxY}px`;

        // convert px -> logical
        const lx = (newPxX / map.clientWidth) * LOGICAL_W;
        const ly = (newPxY / map.clientHeight) * LOGICAL_H;

        const nd = notesData.find(n => n.id === id);
        if (nd){ nd.x = lx; nd.y = ly; }

        drawAll();
      });

      handle.addEventListener("pointerup", (e) => {
        if (!dragging) return;
        e.preventDefault();
        e.stopPropagation();
        dragging = false;
        saveMapState();
      });

      handle.addEventListener("pointercancel", () => dragging = false);

      return noteDiv;
    }

    /***********************
     * Units
     ***********************/
    function createUnit(iconEl, teamId, logicalX, logicalY, pushHistory=true){
      const div = document.createElement("div");
      div.className = "unit";

      const img = iconEl.cloneNode(true);
      img.classList.remove("selected");
      img.style.width = img.style.height = "30px";

      const label = document.createElement("div");
      label.className = "unit-label";
      label.textContent = iconEl.dataset.teamTag || teamId;

      const reset = document.createElement("button");
      reset.className = "reset-btn";
      reset.textContent = "Reset";
      reset.addEventListener("pointerdown", (e) => e.stopPropagation());
      reset.addEventListener("click", (e) => {
        e.stopPropagation();
        div.remove();
        delete teamPaths[teamId];
        delete teamIcons[teamId];
        if (activeTeam === teamId) activeTeam = null;
        drawAll();
        saveMapState();
      });

      div.append(img, label, reset);
      map.appendChild(div);

      div.addEventListener("pointerdown", (e) => {
        e.stopPropagation();
        activeTeam = teamId;
      });

      const p = logicalToPx({ x: logicalX, y: logicalY });
      div.style.left = `${p.x - 15}px`;
      div.style.top  = `${p.y - 15}px`;

      if (pushHistory) historyStack.push({ type:"line", team: teamId });

      return div;
    }

    /***********************
     * Team icons (Supabase)
     ***********************/
    async function loadTeamIcons(){
      const grid = document.getElementById("teamIcons");
      grid.innerHTML = "";

      const { data, error } = await client
        .from("teams_pathplanner")
        .select("id, team_name, team_tag, logo_url")
        .order("id", { ascending: true });

      if (error){
        console.error("❌ Failed to load teams:", error);
        const msg = document.createElement("p");
        msg.textContent = "Failed to load teams.";
        msg.style.fontSize = "0.8rem";
        msg.style.color = "#aaa";
        msg.style.gridColumn = "1 / -1";
        grid.appendChild(msg);
        return;
      }

      if (!data || !data.length){
        const msg = document.createElement("p");
        msg.textContent = "No teams configured. Go to Team Settings to add some.";
        msg.style.fontSize = "0.8rem";
        msg.style.color = "#aaa";
        msg.style.gridColumn = "1 / -1";
        grid.appendChild(msg);
        return;
      }

      data.slice(0, teamColors.length).forEach((team, i) => {
        const wrapper = document.createElement("div");
        wrapper.style.display = "flex";
        wrapper.style.flexDirection = "column";
        wrapper.style.alignItems = "center";

        const img = document.createElement("img");
        img.src = team.logo_url;
        img.alt = team.team_name || team.team_tag || `Team ${i+1}`;
        img.className = "team-icon";

        const teamId = "team" + (i+1);
        img.dataset.id = teamId;
        img.dataset.teamTag = team.team_tag || "";
        img.dataset.teamName = team.team_name || "";
        img.dataset.teamDbId = team.id;

        img.addEventListener("click", () => {
          document.querySelectorAll(".team-icon").forEach(el => el.classList.remove("selected"));
          img.classList.add("selected");
          selectedIcon = img;
        });

        const colorBar = document.createElement("div");
        colorBar.style.width = "60%";
        colorBar.style.height = "6px";
        colorBar.style.marginTop = "6px";
        colorBar.style.borderRadius = "999px";
        colorBar.style.backgroundColor = teamColors[i] || "#fff";

        wrapper.appendChild(img);
        wrapper.appendChild(colorBar);
        grid.appendChild(wrapper);
      });
    }

    /***********************
     * Mode toggles
     ***********************/
    const drawCircleBtn = document.getElementById("draw-circle");
    const noteBtn = document.getElementById("note-mode");

    drawCircleBtn.onclick = () => {
      drawCircleMode = !drawCircleMode;
      drawCircleBtn.textContent = drawCircleMode ? "Circle Mode: ON" : "Draw Circle";
      drawCircleBtn.classList.toggle("active", drawCircleMode);
    };

    noteBtn.onclick = () => {
      noteMode = !noteMode;
      noteBtn.textContent = noteMode ? "Note Mode: ON" : "Add Note";
      noteBtn.classList.toggle("active", noteMode);
    };

    /***********************
     * Map pointer interactions (tap vs drag)
     * (Fix: circle dragging won't block placing logos)
     ***********************/
    let down = false;
    let moved = false;
    let downClient = { x:0, y:0 };
    let downLogical = { x:0, y:0 };

    let candResize = null, candDrag = null;
    let resizingCircle = null, draggingCircle = null;

    map.addEventListener("pointerdown", (e) => {
      if (e.target?.closest && (e.target.closest(".note") || e.target.closest(".unit"))) return;

      e.preventDefault();
      map.setPointerCapture(e.pointerId);

      down = true;
      moved = false;

      downClient = { x: e.clientX, y: e.clientY };
      downLogical = clientToLogical(e);

      candResize = findCircleResize(downLogical);
      candDrag = candResize ? null : findCircleDrag(downLogical);

      resizingCircle = null;
      draggingCircle = null;
    });

    map.addEventListener("pointermove", (e) => {
      if (!down) return;
      e.preventDefault();

      const distPx = Math.hypot(e.clientX - downClient.x, e.clientY - downClient.y);

      if (!moved && distPx > DRAG_THRESHOLD_PX){
        moved = true;
        resizingCircle = candResize;
        draggingCircle = candDrag;
      }

      if (!moved) return;

      const pL = clientToLogical(e);

      if (resizingCircle){
        resizingCircle.r = Math.max(10, Math.hypot(pL.x - resizingCircle.x, pL.y - resizingCircle.y));
        drawAll();
        return;
      }
      if (draggingCircle){
        draggingCircle.x = pL.x;
        draggingCircle.y = pL.y;
        drawAll();
      }
    });

    map.addEventListener("pointerup", (e) => {
      if (!down) return;
      e.preventDefault();
      down = false;

      if (moved && (resizingCircle || draggingCircle)){
        candResize = candDrag = null;
        resizingCircle = draggingCircle = null;
        saveMapState();
        return;
      }

      // TAP
      candResize = candDrag = null;
      resizingCircle = draggingCircle = null;

      if (e.target?.closest && (e.target.closest(".note") || e.target.closest(".unit"))) return;

      const pL = clientToLogical(e);

      if (noteMode){
        const text = prompt("Enter note:");
        if (!text) return;
        createNote(pL.x, pL.y, text, null, true);
        noteMode = false;
        noteBtn.textContent = "Add Note";
        noteBtn.classList.remove("active");
        saveMapState();
        return;
      }

      if (drawCircleMode){
        circles.push({ x: pL.x, y: pL.y, r: 30, color: "#00ffff" });
        historyStack.push({ type:"circle" });
        drawAll();
        saveMapState();
        return;
      }

      if (selectedIcon){
        const id = selectedIcon.dataset.id;

        if (!teamIcons[id]){
          teamPaths[id] = [{ x: pL.x, y: pL.y }];
          teamIcons[id] = createUnit(selectedIcon, id, pL.x, pL.y, true);
          activeTeam = id;
        } else {
          activeTeam = id;
        }

        selectedIcon.classList.remove("selected");
        selectedIcon = null;

        drawAll();
        saveMapState();
        return;
      }

      if (activeTeam && teamPaths[activeTeam]){
        teamPaths[activeTeam].push({ x: pL.x, y: pL.y });
        historyStack.push({ type:"line", team: activeTeam });
        drawAll();
        saveMapState();
      }
    });

    map.addEventListener("pointercancel", () => {
      down = false; moved = false;
      candResize = candDrag = null;
      resizingCircle = draggingCircle = null;
    });

    /***********************
     * Buttons: undo/reset/export/import
     ***********************/
    document.getElementById("undo-btn").onclick = () => {
      const last = historyStack.pop();
      if (!last) return;

      if (last.type === "circle"){
        circles.pop();
      } else if (last.type === "line"){
        const path = teamPaths[last.team];
        if (path){
          path.pop();
          if (path.length === 0){
            delete teamPaths[last.team];
            teamIcons[last.team]?.remove();
            delete teamIcons[last.team];
            if (activeTeam === last.team) activeTeam = null;
          } else {
            // unit stays at first point; no change needed
          }
        }
      } else if (last.type === "note"){
        const el = map.querySelector(`.note[data-note-id="${last.id}"]`);
        if (el) el.remove();
        const idx = notesData.findIndex(n => n.id === last.id);
        if (idx !== -1) notesData.splice(idx, 1);
      }

      drawAll();
      saveMapState();
    };

    document.getElementById("reset-all-btn").onclick = () => {
      if (!confirm("Reset all?")) return;

      Object.values(teamIcons).forEach(el => el?.remove());
      Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
      Object.keys(teamPaths).forEach(k => delete teamPaths[k]);

      circles.length = 0;

      map.querySelectorAll(".note").forEach(n => n.remove());
      notesData.length = 0;

      historyStack.length = 0;
      activeTeam = null;
      selectedIcon = null;
      document.querySelectorAll(".team-icon").forEach(el => el.classList.remove("selected"));

      drawAll();
      saveMapState();
    };

    document.getElementById("export-btn").onclick = () => {
      const data = { map: mapSelect.value, paths: teamPaths, circles, notes: notesData };
      const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "team-paths.json";
      a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById("import-file").onchange = function(){
      const file = this.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const data = JSON.parse(e.target.result);

        if (data.map){
          mapSelect.value = data.map;
          setMapBg();
        }

        // clear
        Object.values(teamIcons).forEach(el => el?.remove());
        Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
        Object.keys(teamPaths).forEach(k => delete teamPaths[k]);
        circles.length = 0;
        map.querySelectorAll(".note").forEach(n => n.remove());
        notesData.length = 0;
        historyStack.length = 0;
        activeTeam = null;
        selectedIcon = null;
        document.querySelectorAll(".team-icon").forEach(el => el.classList.remove("selected"));

        // restore
        Object.entries(data.paths || {}).forEach(([id, points]) => {
          const icon = document.querySelector(`.team-icon[data-id="${id}"]`);
          if (!icon || !points?.length) return;
          teamPaths[id] = points.map(p => ({ x:p.x, y:p.y }));
          teamIcons[id] = createUnit(icon, id, points[0].x, points[0].y, false);
        });

        (data.circles || []).forEach(c => circles.push({ x:c.x, y:c.y, r:c.r, color:c.color || "#00ffff" }));

        (data.notes || []).forEach(n => {
          const nid = n.id || ("n_" + Math.random().toString(16).slice(2));
          notesData.push({ id:nid, x:n.x, y:n.y, text:n.text || "" });
          createNote(n.x, n.y, n.text || "", nid, false);
        });

        resizeCanvases();
        saveMapState();
      };
      reader.readAsText(file);
      this.value = "";
    };

    /***********************
     * Map change
     ***********************/
    mapSelect.addEventListener("change", () => {
      setMapBg();
      const opt = mapSelect.options[mapSelect.selectedIndex];
      if (opt?.dataset.mode === "CS") drawOverlayMask(circles);
      else maskCanvas.style.display = "none";
      saveMapState();
    });

    /***********************
     * Realtime + DB state
     ***********************/
    let realtimeEnabled = true;
    let realtimeChannel = null;

    async function loadMapState(){
      const { data, error } = await client
        .from('map')
        .select('state')
        .eq('id', 1)
        .maybeSingle();

      if (error && error.code !== 'PGRST116'){
        console.error('❌ Failed to load map state:', error);
        return;
      }
      if (!data || !data.state){
        await saveMapState();
        return;
      }
      applyMapState(data.state);
    }

    async function saveMapState(){
      const state = { map: mapSelect.value, paths: teamPaths, circles, notes: notesData };
      const { error } = await client
        .from('map')
        .upsert({ id: 1, state, updated_at: new Date().toISOString() });
      if (error) console.error('❌ Failed to save map state:', error);
    }

    function applyMapState(state){
      if (state?.map){
        mapSelect.value = state.map;
        setMapBg();
      }

      // clear
      Object.values(teamIcons).forEach(el => el?.remove());
      Object.keys(teamIcons).forEach(k => delete teamIcons[k]);
      Object.keys(teamPaths).forEach(k => delete teamPaths[k]);
      circles.length = 0;
      map.querySelectorAll(".note").forEach(n => n.remove());
      notesData.length = 0;

      activeTeam = null;
      selectedIcon = null;
      document.querySelectorAll(".team-icon").forEach(el => el.classList.remove("selected"));

      // restore
      Object.entries(state?.paths || {}).forEach(([id, points]) => {
        const icon = document.querySelector(`.team-icon[data-id="${id}"]`);
        if (!icon || !points?.length) return;
        teamPaths[id] = points.map(p => ({ x:p.x, y:p.y }));
        teamIcons[id] = createUnit(icon, id, points[0].x, points[0].y, false);
      });

      (state?.circles || []).forEach(c => circles.push({ x:c.x, y:c.y, r:c.r, color:c.color || "#00ffff" }));

      // notes can be old format without id
      (state?.notes || []).forEach(n => {
        const nid = n.id || ("n_" + Math.random().toString(16).slice(2));
        notesData.push({ id:nid, x:n.x, y:n.y, text:n.text || "" });
        createNote(n.x, n.y, n.text || "", nid, false);
      });

      resizeCanvases();
    }

    function handleMapChange(payload){
      if (!realtimeEnabled) return;
      const row = payload.new;
      if (!row || row.id !== 1) return;
      applyMapState(row.state || {});
    }

    async function enableRealtime(){
      if (realtimeChannel) return;
      realtimeChannel = client
        .channel('public:map')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'map' }, handleMapChange)
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'map' }, handleMapChange);

      const { error } = await realtimeChannel.subscribe();
      if (error) console.error("❌ realtime subscribe:", error.message);
    }

    async function disableRealtime(){
      if (!realtimeChannel) return;
      await client.removeChannel(realtimeChannel);
      realtimeChannel = null;
    }

    const realtimeBtn = document.getElementById("realtime-toggle-btn");
    realtimeBtn.onclick = async () => {
      realtimeEnabled = !realtimeEnabled;
      realtimeBtn.textContent = realtimeEnabled ? "Real-time: ON" : "Real-time: OFF";
      realtimeBtn.classList.toggle("active", realtimeEnabled);
      if (realtimeEnabled) await enableRealtime();
      else await disableRealtime();
    };

    /***********************
     * Init
     ***********************/
    window.addEventListener("DOMContentLoaded", async () => {
      const session = await ensureSession();
      if (!session) return;

      document.getElementById("user-info").textContent =
        "Logged in as: " + (session.user?.email || "unknown");

      await loadTeamIcons();
      setMapBg();

      resizeCanvases();
      await loadMapState();
      await enableRealtime();

      realtimeBtn.classList.toggle("active", realtimeEnabled);
      realtimeBtn.textContent = realtimeEnabled ? "Real-time: ON" : "Real-time: OFF";
    });
  </script>
</body>
</html>
